üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.6.2 Mod√®les et relations

## Introduction aux relations entre tables

Dans une base de donn√©es relationnelle, les tables sont souvent li√©es entre elles. Par exemple, un auteur peut √©crire plusieurs livres, un √©tudiant peut s'inscrire √† plusieurs cours, etc. SQLAlchemy facilite grandement la gestion de ces relations.

Dans ce chapitre, nous allons explorer les quatre types de relations principales :
- **One-to-Many** (un √† plusieurs) : Un auteur peut avoir plusieurs livres
- **Many-to-One** (plusieurs √† un) : Plusieurs livres appartiennent √† un auteur
- **Many-to-Many** (plusieurs √† plusieurs) : Un √©tudiant peut suivre plusieurs cours, et un cours peut avoir plusieurs √©tudiants
- **One-to-One** (un √† un) : Un utilisateur a un seul profil

## Configuration initiale

Avant de commencer, voici la configuration de base que nous utiliserons dans tous nos exemples :

```python
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Table
from sqlalchemy.orm import declarative_base, relationship, sessionmaker

# Configuration
Base = declarative_base()
engine = create_engine('sqlite:///relations.db', echo=True)
Session = sessionmaker(bind=engine)
session = Session()
```

## Relation One-to-Many (Un √† Plusieurs)

C'est la relation la plus courante. Un enregistrement dans une table peut √™tre li√© √† plusieurs enregistrements dans une autre table.

### Exemple : Auteur et Livres

Un auteur peut √©crire plusieurs livres, mais chaque livre n'a qu'un seul auteur.

```python
class Auteur(Base):
    __tablename__ = 'auteurs'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100), nullable=False)
    nationalite = Column(String(50))

    # Relation : un auteur a plusieurs livres
    # back_populates cr√©e une liaison bidirectionnelle
    livres = relationship("Livre", back_populates="auteur")

    def __repr__(self):
        return f"<Auteur(nom='{self.nom}')>"


class Livre(Base):
    __tablename__ = 'livres'

    id = Column(Integer, primary_key=True)
    titre = Column(String(200), nullable=False)
    annee_publication = Column(Integer)

    # Cl√© √©trang√®re : lie chaque livre √† un auteur
    auteur_id = Column(Integer, ForeignKey('auteurs.id'))

    # Relation : plusieurs livres appartiennent √† un auteur
    auteur = relationship("Auteur", back_populates="livres")

    def __repr__(self):
        return f"<Livre(titre='{self.titre}')>"
```

**Explication d√©taill√©e :**

- `ForeignKey('auteurs.id')` : Cr√©e une cl√© √©trang√®re qui r√©f√©rence la colonne `id` de la table `auteurs`
- `relationship("Livre", ...)` : D√©finit la relation au niveau Python (pas au niveau SQL)
- `back_populates` : Cr√©e une liaison bidirectionnelle automatique entre les deux mod√®les

### Utilisation pratique

```python
# Cr√©ation des tables
Base.metadata.create_all(engine)

# Cr√©ation d'un auteur
victor_hugo = Auteur(nom="Victor Hugo", nationalite="Fran√ßaise")

# Cr√©ation de livres
livre1 = Livre(titre="Les Mis√©rables", annee_publication=1862)
livre2 = Livre(titre="Notre-Dame de Paris", annee_publication=1831)
livre3 = Livre(titre="Les Contemplations", annee_publication=1856)

# Association des livres √† l'auteur (m√©thode 1)
victor_hugo.livres.append(livre1)
victor_hugo.livres.append(livre2)
victor_hugo.livres.append(livre3)

# Sauvegarde
session.add(victor_hugo)
session.commit()

print(f"Auteur cr√©√© avec {len(victor_hugo.livres)} livres")
```

**M√©thode alternative :**

```python
# Cr√©ation d'un auteur
moliere = Auteur(nom="Moli√®re", nationalite="Fran√ßaise")
session.add(moliere)
session.commit()

# Cr√©ation de livres en assignant directement l'auteur (m√©thode 2)
livre4 = Livre(
    titre="Le Malade imaginaire",
    annee_publication=1673,
    auteur=moliere  # Association directe
)
livre5 = Livre(
    titre="Tartuffe",
    annee_publication=1664,
    auteur_id=moliere.id  # Ou en utilisant l'ID
)

session.add_all([livre4, livre5])
session.commit()
```

### R√©cup√©ration des donn√©es li√©es

```python
# R√©cup√©rer un auteur et ses livres
auteur = session.query(Auteur).filter(Auteur.nom == "Victor Hugo").first()
print(f"\n{auteur.nom} a √©crit {len(auteur.livres)} livres :")
for livre in auteur.livres:
    print(f"  - {livre.titre} ({livre.annee_publication})")

# R√©cup√©rer un livre et son auteur
livre = session.query(Livre).filter(Livre.titre == "Les Mis√©rables").first()
print(f"\n'{livre.titre}' a √©t√© √©crit par {livre.auteur.nom}")
```

## Relation Many-to-One (Plusieurs √† Un)

C'est l'inverse de One-to-Many. Techniquement, nous l'avons d√©j√† vue dans l'exemple pr√©c√©dent (plusieurs livres ‚Üí un auteur). La diff√©rence est principalement une question de perspective.

### Exemple : Commentaires et Articles

Plusieurs commentaires peuvent √™tre associ√©s √† un seul article.

```python
class Article(Base):
    __tablename__ = 'articles'

    id = Column(Integer, primary_key=True)
    titre = Column(String(200), nullable=False)
    contenu = Column(String)

    # Un article a plusieurs commentaires
    commentaires = relationship("Commentaire", back_populates="article")

    def __repr__(self):
        return f"<Article(titre='{self.titre}')>"


class Commentaire(Base):
    __tablename__ = 'commentaires'

    id = Column(Integer, primary_key=True)
    texte = Column(String(500), nullable=False)
    auteur = Column(String(100))

    # Plusieurs commentaires appartiennent √† un article
    article_id = Column(Integer, ForeignKey('articles.id'))
    article = relationship("Article", back_populates="commentaires")

    def __repr__(self):
        return f"<Commentaire(auteur='{self.auteur}')>"
```

### Utilisation

```python
# Cr√©ation d'un article
article = Article(
    titre="Introduction √† SQLAlchemy",
    contenu="SQLAlchemy est un ORM puissant..."
)

# Ajout de commentaires
commentaire1 = Commentaire(texte="Excellent article !", auteur="Alice")
commentaire2 = Commentaire(texte="Tr√®s instructif", auteur="Bob")
commentaire3 = Commentaire(texte="Merci pour le partage", auteur="Claire")

# Association
article.commentaires.extend([commentaire1, commentaire2, commentaire3])

session.add(article)
session.commit()

# Affichage
print(f"\nArticle : {article.titre}")
print(f"Nombre de commentaires : {len(article.commentaires)}")
for comm in article.commentaires:
    print(f"  - {comm.auteur} : {comm.texte}")
```

## Relation Many-to-Many (Plusieurs √† Plusieurs)

Cette relation est plus complexe. Elle n√©cessite une **table d'association** (aussi appel√©e table de jonction) pour lier les deux tables principales.

### Exemple : √âtudiants et Cours

Un √©tudiant peut s'inscrire √† plusieurs cours, et un cours peut avoir plusieurs √©tudiants.

```python
# Table d'association (table interm√©diaire)
# Cette table n'a pas besoin d'√™tre une classe, juste une Table
inscription = Table(
    'inscriptions',
    Base.metadata,
    Column('etudiant_id', Integer, ForeignKey('etudiants.id'), primary_key=True),
    Column('cours_id', Integer, ForeignKey('cours.id'), primary_key=True)
)


class Etudiant(Base):
    __tablename__ = 'etudiants'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100), nullable=False)
    prenom = Column(String(100), nullable=False)
    email = Column(String(100), unique=True)

    # Relation Many-to-Many avec les cours
    # secondary indique la table d'association √† utiliser
    cours = relationship("Cours", secondary=inscription, back_populates="etudiants")

    def __repr__(self):
        return f"<Etudiant(nom='{self.nom} {self.prenom}')>"


class Cours(Base):
    __tablename__ = 'cours'

    id = Column(Integer, primary_key=True)
    code = Column(String(20), unique=True, nullable=False)
    intitule = Column(String(200), nullable=False)
    credits = Column(Integer)

    # Relation Many-to-Many avec les √©tudiants
    etudiants = relationship("Etudiant", secondary=inscription, back_populates="cours")

    def __repr__(self):
        return f"<Cours(code='{self.code}', intitule='{self.intitule}')>"
```

**Explication de la table d'association :**

- `inscription` : Table interm√©diaire qui stocke les liens entre √©tudiants et cours
- Elle contient deux cl√©s √©trang√®res (une vers `etudiants`, une vers `cours`)
- Les deux colonnes forment ensemble la cl√© primaire (pas de duplicata)
- `secondary=inscription` : Indique √† SQLAlchemy quelle table utiliser pour la liaison

### Utilisation

```python
# Cr√©ation des tables
Base.metadata.create_all(engine)

# Cr√©ation d'√©tudiants
etudiant1 = Etudiant(nom="Durand", prenom="Sophie", email="sophie.durand@school.com")
etudiant2 = Etudiant(nom="Martin", prenom="Lucas", email="lucas.martin@school.com")
etudiant3 = Etudiant(nom="Bernard", prenom="Emma", email="emma.bernard@school.com")

# Cr√©ation de cours
cours1 = Cours(code="MATH101", intitule="Math√©matiques avanc√©es", credits=6)
cours2 = Cours(code="INFO202", intitule="Programmation Python", credits=5)
cours3 = Cours(code="PHYS150", intitule="Physique quantique", credits=4)

# Inscription des √©tudiants aux cours
# Sophie s'inscrit √† Math et Python
etudiant1.cours.append(cours1)
etudiant1.cours.append(cours2)

# Lucas s'inscrit √† Python et Physique
etudiant2.cours.extend([cours2, cours3])

# Emma s'inscrit aux trois cours
etudiant3.cours = [cours1, cours2, cours3]

# Sauvegarde
session.add_all([etudiant1, etudiant2, etudiant3])
session.commit()

# Affichage des inscriptions
print("\n=== Inscriptions par √©tudiant ===")
for etudiant in session.query(Etudiant).all():
    print(f"\n{etudiant.prenom} {etudiant.nom} :")
    for cours in etudiant.cours:
        print(f"  - {cours.code} : {cours.intitule}")

print("\n=== √âtudiants par cours ===")
for cours in session.query(Cours).all():
    print(f"\n{cours.code} - {cours.intitule} ({len(cours.etudiants)} √©tudiants) :")
    for etudiant in cours.etudiants:
        print(f"  - {etudiant.prenom} {etudiant.nom}")
```

### Manipulation des relations Many-to-Many

```python
# Ajouter un cours √† un √©tudiant
sophie = session.query(Etudiant).filter(Etudiant.prenom == "Sophie").first()
physique = session.query(Cours).filter(Cours.code == "PHYS150").first()
sophie.cours.append(physique)
session.commit()

# Retirer un cours d'un √©tudiant
sophie.cours.remove(physique)
session.commit()

# V√©rifier si un √©tudiant est inscrit √† un cours
if cours2 in etudiant2.cours:
    print("Lucas est inscrit au cours de Python")
```

## Relation One-to-One (Un √† Un)

Dans cette relation, un enregistrement d'une table correspond √† un seul enregistrement d'une autre table.

### Exemple : Utilisateur et Profil

Chaque utilisateur a un seul profil, et chaque profil appartient √† un seul utilisateur.

```python
class Utilisateur(Base):
    __tablename__ = 'utilisateurs'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)

    # Relation One-to-One avec Profil
    # uselist=False indique qu'il s'agit d'une relation 1:1 (pas une liste)
    profil = relationship("Profil", back_populates="utilisateur", uselist=False)

    def __repr__(self):
        return f"<Utilisateur(username='{self.username}')>"


class Profil(Base):
    __tablename__ = 'profils'

    id = Column(Integer, primary_key=True)
    bio = Column(String(500))
    site_web = Column(String(200))
    date_naissance = Column(String(20))

    # Cl√© √©trang√®re vers utilisateur (unique=True pour garantir 1:1)
    utilisateur_id = Column(Integer, ForeignKey('utilisateurs.id'), unique=True)

    # Relation inverse
    utilisateur = relationship("Utilisateur", back_populates="profil")

    def __repr__(self):
        return f"<Profil(utilisateur='{self.utilisateur.username if self.utilisateur else None}')>"
```

**Point cl√© :** `uselist=False` transforme la relation en One-to-One. Sans cela, `utilisateur.profil` serait une liste.

### Utilisation

```python
# Cr√©ation d'un utilisateur avec son profil
user = Utilisateur(username="alice_dev", email="alice@dev.com")
profil = Profil(
    bio="D√©veloppeuse Python passionn√©e",
    site_web="https://alice-dev.com",
    date_naissance="15/03/1990"
)

# Association
user.profil = profil

session.add(user)
session.commit()

# Acc√®s aux donn√©es
print(f"\nUtilisateur : {user.username}")
print(f"Bio : {user.profil.bio}")
print(f"Site web : {user.profil.site_web}")

# Sens inverse
profil_recupere = session.query(Profil).first()
print(f"\nCe profil appartient √† : {profil_recupere.utilisateur.username}")
```

## Relations en cascade

Les cascades permettent de d√©finir ce qui se passe avec les objets li√©s lors de certaines op√©rations (suppression, mise √† jour, etc.).

### Options de cascade courantes

```python
class Auteur(Base):
    __tablename__ = 'auteurs_cascade'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100))

    # Cascade : si on supprime l'auteur, ses livres sont aussi supprim√©s
    livres = relationship(
        "Livre",
        back_populates="auteur",
        cascade="all, delete-orphan"
    )


class Livre(Base):
    __tablename__ = 'livres_cascade'

    id = Column(Integer, primary_key=True)
    titre = Column(String(200))
    auteur_id = Column(Integer, ForeignKey('auteurs_cascade.id'))
    auteur = relationship("Auteur", back_populates="livres")
```

**Options de cascade :**

- `all` : Propage toutes les op√©rations (save, merge, refresh, expunge, delete)
- `delete` : Supprime les objets li√©s quand l'objet parent est supprim√©
- `delete-orphan` : Supprime les objets li√©s s'ils ne sont plus associ√©s au parent
- `save-update` : Propage les ajouts et modifications
- `merge` : Propage les fusions d'objets
- `refresh` : Propage les rafra√Æchissements
- `expunge` : Propage les expulsions de session

### Exemple pratique

```python
# Sans cascade delete-orphan
auteur = session.query(Auteur).first()
livre = auteur.livres[0]

# Retirer le livre de la liste (mais il reste en base)
auteur.livres.remove(livre)
session.commit()
# Le livre existe toujours en base, mais sans auteur

# Avec cascade delete-orphan
auteur = session.query(Auteur).first()
livre = auteur.livres[0]

# Retirer le livre de la liste
auteur.livres.remove(livre)
session.commit()
# Le livre est automatiquement supprim√© de la base
```

## Chargement des relations (Lazy Loading vs Eager Loading)

Par d√©faut, SQLAlchemy utilise le "lazy loading" : les objets li√©s ne sont charg√©s que lorsqu'on y acc√®de.

### Lazy Loading (par d√©faut)

```python
# R√©cup√©ration d'un auteur
auteur = session.query(Auteur).first()
# √Ä ce stade, les livres ne sont pas encore charg√©s

# Acc√®s aux livres ‚Üí d√©clenche une nouvelle requ√™te SQL
for livre in auteur.livres:  # Requ√™te SQL ici !
    print(livre.titre)
```

**Probl√®me potentiel :** Le "N+1 query problem" - si vous parcourez 100 auteurs et leurs livres, vous ferez 101 requ√™tes SQL (1 pour les auteurs + 100 pour les livres).

### Eager Loading (chargement anticip√©)

Pour √©viter le probl√®me N+1, utilisez `joinedload` ou `selectinload` :

```python
from sqlalchemy.orm import joinedload, selectinload

# M√©thode 1 : joinedload (utilise un JOIN SQL)
auteurs = session.query(Auteur).options(joinedload(Auteur.livres)).all()
# Une seule requ√™te SQL avec JOIN

# M√©thode 2 : selectinload (utilise un SELECT IN)
auteurs = session.query(Auteur).options(selectinload(Auteur.livres)).all()
# Deux requ√™tes SQL optimis√©es

# Maintenant, parcourir les livres ne g√©n√®re pas de requ√™tes suppl√©mentaires
for auteur in auteurs:
    print(f"\n{auteur.nom} :")
    for livre in auteur.livres:  # Pas de requ√™te SQL !
        print(f"  - {livre.titre}")
```

**Configuration au niveau du mod√®le :**

```python
class Auteur(Base):
    __tablename__ = 'auteurs'
    id = Column(Integer, primary_key=True)
    nom = Column(String(100))

    # Configuration du chargement par d√©faut
    livres = relationship(
        "Livre",
        back_populates="auteur",
        lazy="select"  # Options: 'select', 'joined', 'selectin', 'subquery'
    )
```

## Relations auto-r√©f√©rentielles

Une table peut avoir une relation avec elle-m√™me. Exemple typique : employ√©s et managers.

```python
class Employe(Base):
    __tablename__ = 'employes'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100), nullable=False)
    poste = Column(String(100))

    # Cl√© √©trang√®re vers le manager (qui est aussi un employ√©)
    manager_id = Column(Integer, ForeignKey('employes.id'))

    # Relation vers le manager
    manager = relationship("Employe", remote_side=[id], backref="equipe")

    def __repr__(self):
        return f"<Employe(nom='{self.nom}', poste='{self.poste}')>"
```

**Explication :**
- `remote_side=[id]` : Indique le c√¥t√© "distant" de la relation
- `backref="equipe"` : Cr√©e automatiquement l'attribut `equipe` pour acc√©der aux subordonn√©s

### Utilisation

```python
# Cr√©ation de la hi√©rarchie
ceo = Employe(nom="Directrice G√©n√©rale", poste="CEO")

manager1 = Employe(nom="Chef Ventes", poste="Manager", manager=ceo)
manager2 = Employe(nom="Chef IT", poste="Manager", manager=ceo)

employe1 = Employe(nom="Vendeur 1", poste="Commercial", manager=manager1)
employe2 = Employe(nom="Vendeur 2", poste="Commercial", manager=manager1)
employe3 = Employe(nom="D√©veloppeur", poste="Developer", manager=manager2)

session.add(ceo)
session.commit()

# Affichage de la hi√©rarchie
print(f"\n{ceo.nom} manage :")
for manager in ceo.equipe:
    print(f"  - {manager.nom} ({manager.poste})")
    if manager.equipe:
        for employe in manager.equipe:
            print(f"    - {employe.nom} ({employe.poste})")
```

## Association Object (Table d'association avec attributs)

Parfois, la table d'association elle-m√™me a besoin d'attributs suppl√©mentaires. Dans ce cas, elle doit √™tre une vraie classe.

### Exemple : √âtudiants et Cours avec notes

```python
class Inscription(Base):
    __tablename__ = 'inscriptions_notes'

    etudiant_id = Column(Integer, ForeignKey('etudiants.id'), primary_key=True)
    cours_id = Column(Integer, ForeignKey('cours.id'), primary_key=True)

    # Attributs suppl√©mentaires
    note = Column(Integer)
    date_inscription = Column(String)
    statut = Column(String(20))  # 'en_cours', 'termin√©', 'abandonn√©'

    # Relations
    etudiant = relationship("Etudiant", back_populates="inscriptions")
    cours = relationship("Cours", back_populates="inscriptions")

    def __repr__(self):
        return f"<Inscription(note={self.note}, statut='{self.statut}')>"


class Etudiant(Base):
    __tablename__ = 'etudiants_v2'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100))
    prenom = Column(String(100))

    inscriptions = relationship("Inscription", back_populates="etudiant")


class Cours(Base):
    __tablename__ = 'cours_v2'

    id = Column(Integer, primary_key=True)
    code = Column(String(20))
    intitule = Column(String(200))

    inscriptions = relationship("Inscription", back_populates="cours")
```

### Utilisation

```python
# Cr√©ation
etudiant = Etudiant(nom="Dupont", prenom="Marie")
cours = Cours(code="MATH101", intitule="Math√©matiques")

# Inscription avec attributs suppl√©mentaires
inscription = Inscription(
    etudiant=etudiant,
    cours=cours,
    note=15,
    date_inscription="2024-09-01",
    statut="en_cours"
)

session.add_all([etudiant, cours, inscription])
session.commit()

# Consultation
for insc in etudiant.inscriptions:
    print(f"{etudiant.prenom} a eu {insc.note}/20 en {insc.cours.intitule}")
```

## Bonnes pratiques

### 1. Nommage coh√©rent

```python
# Bon : noms clairs et coh√©rents
class Auteur(Base):
    livres = relationship("Livre", back_populates="auteur")

class Livre(Base):
    auteur = relationship("Auteur", back_populates="livres")
```

### 2. Utiliser back_populates plut√¥t que backref

```python
# Pr√©f√©rable : explicite et bidirectionnel
livres = relationship("Livre", back_populates="auteur")

# Moins pr√©f√©rable : implicite (mais fonctionne)
livres = relationship("Livre", backref="auteur")
```

### 3. √âviter les boucles infinies dans __repr__

```python
# Mauvais : peut causer une boucle infinie
def __repr__(self):
    return f"<Auteur(nom='{self.nom}', livres={self.livres})>"

# Bon : n'inclut pas les objets li√©s
def __repr__(self):
    return f"<Auteur(nom='{self.nom}')>"
```

### 4. Utiliser des contraintes de base de donn√©es

```python
# Bon : contrainte au niveau SQL
auteur_id = Column(Integer, ForeignKey('auteurs.id', ondelete='CASCADE'))
# ondelete='CASCADE' : supprime les livres si l'auteur est supprim√©
# ondelete='SET NULL' : met auteur_id √† NULL
# ondelete='RESTRICT' : emp√™che la suppression de l'auteur
```

## Exemple complet : Biblioth√®que

Voici un exemple complet int√©grant plusieurs types de relations :

```python
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Table
from sqlalchemy.orm import declarative_base, relationship, sessionmaker

Base = declarative_base()
engine = create_engine('sqlite:///bibliotheque.db', echo=False)
Session = sessionmaker(bind=engine)

# Table d'association pour Many-to-Many
emprunt_livre = Table(
    'emprunts_livres',
    Base.metadata,
    Column('emprunt_id', Integer, ForeignKey('emprunts.id')),
    Column('livre_id', Integer, ForeignKey('livres.id'))
)


class Bibliotheque(Base):
    __tablename__ = 'bibliotheques'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100), nullable=False)
    adresse = Column(String(200))

    # One-to-Many : une biblioth√®que a plusieurs livres
    livres = relationship("Livre", back_populates="bibliotheque")


class Livre(Base):
    __tablename__ = 'livres'

    id = Column(Integer, primary_key=True)
    titre = Column(String(200), nullable=False)
    isbn = Column(String(20), unique=True)

    # Many-to-One : plusieurs livres appartiennent √† une biblioth√®que
    bibliotheque_id = Column(Integer, ForeignKey('bibliotheques.id'))
    bibliotheque = relationship("Bibliotheque", back_populates="livres")

    # Many-to-One : plusieurs livres d'un auteur
    auteur_id = Column(Integer, ForeignKey('auteurs.id'))
    auteur = relationship("Auteur", back_populates="livres")

    # Many-to-Many : un livre peut √™tre dans plusieurs emprunts
    emprunts = relationship("Emprunt", secondary=emprunt_livre, back_populates="livres")


class Auteur(Base):
    __tablename__ = 'auteurs'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100), nullable=False)
    nationalite = Column(String(50))

    # One-to-Many : un auteur a plusieurs livres
    livres = relationship("Livre", back_populates="auteur")


class Membre(Base):
    __tablename__ = 'membres'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100), nullable=False)
    email = Column(String(100), unique=True)

    # One-to-Many : un membre a plusieurs emprunts
    emprunts = relationship("Emprunt", back_populates="membre")


class Emprunt(Base):
    __tablename__ = 'emprunts'

    id = Column(Integer, primary_key=True)
    date_emprunt = Column(String(20), nullable=False)
    date_retour_prevue = Column(String(20))

    # Many-to-One : plusieurs emprunts pour un membre
    membre_id = Column(Integer, ForeignKey('membres.id'))
    membre = relationship("Membre", back_populates="emprunts")

    # Many-to-Many : un emprunt peut contenir plusieurs livres
    livres = relationship("Livre", secondary=emprunt_livre, back_populates="emprunts")


# Cr√©ation de la base de donn√©es
Base.metadata.create_all(engine)

# Utilisation
session = Session()

# Cr√©ation d'une biblioth√®que
bibli = Bibliotheque(nom="Biblioth√®que Municipale", adresse="12 rue de la Paix")

# Cr√©ation d'auteurs
hugo = Auteur(nom="Victor Hugo", nationalite="Fran√ßaise")
dumas = Auteur(nom="Alexandre Dumas", nationalite="Fran√ßaise")

# Cr√©ation de livres
livre1 = Livre(titre="Les Mis√©rables", isbn="978-0-1234-5678-9", auteur=hugo, bibliotheque=bibli)
livre2 = Livre(titre="Notre-Dame de Paris", isbn="978-0-1234-5679-6", auteur=hugo, bibliotheque=bibli)
livre3 = Livre(titre="Les Trois Mousquetaires", isbn="978-0-1234-5680-2", auteur=dumas, bibliotheque=bibli)

# Cr√©ation d'un membre
membre = Membre(nom="Sophie Martin", email="sophie.martin@email.com")

# Cr√©ation d'un emprunt
emprunt = Emprunt(
    date_emprunt="2024-01-15",
    date_retour_prevue="2024-02-15",
    membre=membre
)
emprunt.livres.extend([livre1, livre3])

# Sauvegarde
session.add_all([bibli, hugo, dumas, membre, emprunt])
session.commit()

# Affichage
print(f"\n=== {bibli.nom} ===")
print(f"Nombre de livres : {len(bibli.livres)}")
print(f"\nLivres de Victor Hugo :")
for livre in hugo.livres:
    print(f"  - {livre.titre}")

print(f"\nEmprunts de {membre.nom} :")
for emp in membre.emprunts:
    print(f"  Date : {emp.date_emprunt}")
    print(f"  Livres emprunt√©s :")
    for livre in emp.livres:
        print(f"    - {livre.titre} par {livre.auteur.nom}")

session.close()
```

## R√©sum√©

**Types de relations :**
- **One-to-Many** : `ForeignKey` dans la table "Many" + `relationship` des deux c√¥t√©s
- **Many-to-One** : Perspective inverse de One-to-Many
- **Many-to-Many** : Table d'association + `secondary` dans `relationship`
- **One-to-One** : Comme One-to-Many mais avec `uselist=False`

**Concepts cl√©s :**
- `ForeignKey` : D√©finit la contrainte au niveau SQL
- `relationship` : D√©finit la relation au niveau Python ORM
- `back_populates` : Cr√©e une liaison bidirectionnelle explicite
- `cascade` : Contr√¥le la propagation des op√©rations
- Lazy vs Eager loading : Contr√¥le du moment de chargement des donn√©es li√©es

**Bonnes pratiques :**
- Utiliser `back_populates` pour plus de clart√©
- √âviter les boucles infinies dans `__repr__`
- Optimiser avec eager loading si n√©cessaire
- Utiliser les contraintes SQL (`ondelete`, etc.)

Vous ma√Ætrisez maintenant les relations dans SQLAlchemy ! Ces concepts vous permettent de mod√©liser des structures de donn√©es complexes et de naviguer facilement entre les objets li√©s.

‚è≠Ô∏è [Requ√™tes et migrations](/11-developpement-web-et-apis/06.3-requetes-et-migrations.md)
