üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.6.3 Requ√™tes et migrations

## Introduction

Dans ce chapitre, nous allons explorer deux aspects essentiels du travail avec SQLAlchemy :
- **Les requ√™tes avanc√©es** : Comment interroger efficacement votre base de donn√©es
- **Les migrations** : Comment g√©rer l'√©volution de votre sch√©ma de base de donn√©es

## Partie 1 : Requ√™tes avanc√©es

### Configuration de base pour les exemples

Nous utiliserons les mod√®les suivants pour nos exemples :

```python
from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey, func
from sqlalchemy.orm import declarative_base, relationship, sessionmaker

Base = declarative_base()
engine = create_engine('sqlite:///requetes.db', echo=False)
Session = sessionmaker(bind=engine)
session = Session()


class Auteur(Base):
    __tablename__ = 'auteurs'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100), nullable=False)
    nationalite = Column(String(50))
    annee_naissance = Column(Integer)

    livres = relationship("Livre", back_populates="auteur")

    def __repr__(self):
        return f"<Auteur(nom='{self.nom}')>"


class Livre(Base):
    __tablename__ = 'livres'

    id = Column(Integer, primary_key=True)
    titre = Column(String(200), nullable=False)
    annee_publication = Column(Integer)
    prix = Column(Float)
    nb_pages = Column(Integer)

    auteur_id = Column(Integer, ForeignKey('auteurs.id'))
    auteur = relationship("Auteur", back_populates="livres")

    def __repr__(self):
        return f"<Livre(titre='{self.titre}')>"


# Cr√©ation des tables
Base.metadata.create_all(engine)
```

### Filtres multiples

Vous pouvez combiner plusieurs conditions de filtrage de diff√©rentes mani√®res.

#### M√©thode 1 : Cha√Ænage de filter()

```python
# Livres publi√©s apr√®s 1900 ET co√ªtant moins de 20‚Ç¨
livres = session.query(Livre)\
    .filter(Livre.annee_publication > 1900)\
    .filter(Livre.prix < 20)\
    .all()

for livre in livres:
    print(f"{livre.titre} - {livre.prix}‚Ç¨")
```

#### M√©thode 2 : Plusieurs conditions dans un seul filter()

```python
# M√™me r√©sultat avec une seule ligne filter
livres = session.query(Livre)\
    .filter(
        Livre.annee_publication > 1900,
        Livre.prix < 20
    ).all()
```

#### M√©thode 3 : Utilisation des op√©rateurs logiques

```python
from sqlalchemy import and_, or_, not_

# Op√©rateur AND (ET)
livres = session.query(Livre).filter(
    and_(
        Livre.annee_publication > 1900,
        Livre.prix < 20
    )
).all()

# Op√©rateur OR (OU)
# Livres publi√©s avant 1900 OU apr√®s 2000
livres = session.query(Livre).filter(
    or_(
        Livre.annee_publication < 1900,
        Livre.annee_publication > 2000
    )
).all()

# Op√©rateur NOT (NON)
# Livres dont le titre ne contient pas "Python"
livres = session.query(Livre).filter(
    not_(Livre.titre.like('%Python%'))
).all()

# Combinaison complexe
# (ann√©e > 2000 ET prix < 30) OU (auteur fran√ßais ET plus de 300 pages)
livres = session.query(Livre)\
    .join(Auteur)\
    .filter(
        or_(
            and_(Livre.annee_publication > 2000, Livre.prix < 30),
            and_(Auteur.nationalite == "Fran√ßaise", Livre.nb_pages > 300)
        )
    ).all()
```

### Op√©rateurs de comparaison

SQLAlchemy offre de nombreux op√©rateurs pour affiner vos recherches.

```python
# √âgalit√©
livres = session.query(Livre).filter(Livre.prix == 15.99).all()

# Diff√©rent de
livres = session.query(Livre).filter(Livre.prix != 15.99).all()

# Plus grand que / Plus petit que
livres = session.query(Livre).filter(Livre.annee_publication > 2000).all()
livres = session.query(Livre).filter(Livre.prix < 20).all()

# Plus grand ou √©gal / Plus petit ou √©gal
livres = session.query(Livre).filter(Livre.nb_pages >= 300).all()
livres = session.query(Livre).filter(Livre.prix <= 25).all()

# LIKE (contient)
# Livres dont le titre contient "Python"
livres = session.query(Livre).filter(Livre.titre.like('%Python%')).all()

# Commence par
livres = session.query(Livre).filter(Livre.titre.like('Le%')).all()

# Termine par
livres = session.query(Livre).filter(Livre.titre.like('%Wars')).all()

# ILIKE (insensible √† la casse, uniquement PostgreSQL)
# Pour SQLite, utilisez func.lower()
livres = session.query(Livre).filter(
    func.lower(Livre.titre).like('%python%')
).all()

# IN (dans une liste)
livres = session.query(Livre).filter(
    Livre.annee_publication.in_([1990, 1995, 2000, 2005])
).all()

# NOT IN
livres = session.query(Livre).filter(
    Livre.annee_publication.notin_([1990, 1995])
).all()

# BETWEEN (entre deux valeurs)
livres = session.query(Livre).filter(
    Livre.annee_publication.between(1990, 2000)
).all()

# IS NULL
livres = session.query(Livre).filter(Livre.prix.is_(None)).all()

# IS NOT NULL
livres = session.query(Livre).filter(Livre.prix.isnot(None)).all()
```

### Tri des r√©sultats

```python
# Tri croissant (A ‚Üí Z, 0 ‚Üí 9)
livres = session.query(Livre).order_by(Livre.titre).all()

# Tri d√©croissant (Z ‚Üí A, 9 ‚Üí 0)
livres = session.query(Livre).order_by(Livre.prix.desc()).all()

# Tri sur plusieurs colonnes
# D'abord par nationalit√©, puis par nom
auteurs = session.query(Auteur)\
    .order_by(Auteur.nationalite, Auteur.nom)\
    .all()

# M√©lange croissant et d√©croissant
livres = session.query(Livre)\
    .order_by(Livre.annee_publication.desc(), Livre.titre)\
    .all()
```

### Limitation et pagination

```python
# R√©cup√©rer les 5 premiers r√©sultats
livres = session.query(Livre).limit(5).all()

# Sauter les 10 premiers r√©sultats et prendre les 5 suivants
livres = session.query(Livre).offset(10).limit(5).all()

# Pagination : page 3, avec 10 r√©sultats par page
page = 3
par_page = 10
livres = session.query(Livre)\
    .offset((page - 1) * par_page)\
    .limit(par_page)\
    .all()

# R√©cup√©rer un seul r√©sultat
# .first() : retourne le premier ou None
livre = session.query(Livre).filter(Livre.id == 1).first()

# .one() : retourne un r√©sultat ou l√®ve une exception
livre = session.query(Livre).filter(Livre.id == 1).one()

# .one_or_none() : retourne un r√©sultat, None, ou l√®ve une exception si plusieurs
livre = session.query(Livre).filter(Livre.titre == "Unique Title").one_or_none()
```

### S√©lection de colonnes sp√©cifiques

Au lieu de r√©cup√©rer tous les attributs d'un objet, vous pouvez s√©lectionner uniquement certaines colonnes.

```python
# R√©cup√©rer seulement le titre et le prix
resultats = session.query(Livre.titre, Livre.prix).all()
for titre, prix in resultats:
    print(f"{titre} : {prix}‚Ç¨")

# Avec plusieurs tables
resultats = session.query(Livre.titre, Auteur.nom)\
    .join(Auteur)\
    .all()
for titre_livre, nom_auteur in resultats:
    print(f"{titre_livre} par {nom_auteur}")

# Utilisation de labels pour renommer
from sqlalchemy import label

resultats = session.query(
    Livre.titre.label('titre_livre'),
    Auteur.nom.label('nom_auteur')
).join(Auteur).all()

# Acc√®s par nom d'attribut
for row in resultats:
    print(f"{row.titre_livre} par {row.nom_auteur}")
```

### Jointures (JOIN)

Les jointures permettent de combiner des donn√©es de plusieurs tables.

#### JOIN implicite

```python
# R√©cup√©rer les livres avec leurs auteurs
livres = session.query(Livre).join(Auteur).all()

# Acc√©der aux donn√©es de l'auteur
for livre in livres:
    print(f"{livre.titre} par {livre.auteur.nom}")
```

#### JOIN explicite avec condition

```python
# Jointure avec condition personnalis√©e
livres = session.query(Livre)\
    .join(Auteur, Livre.auteur_id == Auteur.id)\
    .filter(Auteur.nationalite == "Fran√ßaise")\
    .all()
```

#### LEFT JOIN (jointure externe)

```python
# R√©cup√®re tous les livres, m√™me ceux sans auteur
from sqlalchemy.orm import outerjoin

livres = session.query(Livre).outerjoin(Auteur).all()

# Ou avec la m√©thode isouter
livres = session.query(Livre).join(Auteur, isouter=True).all()
```

#### Filtrer apr√®s une jointure

```python
# Livres d'auteurs fran√ßais publi√©s apr√®s 2000
livres = session.query(Livre)\
    .join(Auteur)\
    .filter(Auteur.nationalite == "Fran√ßaise")\
    .filter(Livre.annee_publication > 2000)\
    .all()
```

### Agr√©gations et fonctions

SQLAlchemy permet d'utiliser des fonctions d'agr√©gation SQL.

```python
from sqlalchemy import func

# COUNT - Compter le nombre d'enregistrements
nombre_livres = session.query(func.count(Livre.id)).scalar()
print(f"Nombre total de livres : {nombre_livres}")

# Ou plus simplement
nombre_livres = session.query(Livre).count()

# SUM - Somme
valeur_totale = session.query(func.sum(Livre.prix)).scalar()
print(f"Valeur totale : {valeur_totale}‚Ç¨")

# AVG - Moyenne
prix_moyen = session.query(func.avg(Livre.prix)).scalar()
print(f"Prix moyen : {prix_moyen:.2f}‚Ç¨")

# MIN et MAX
prix_min = session.query(func.min(Livre.prix)).scalar()
prix_max = session.query(func.max(Livre.prix)).scalar()
print(f"Prix entre {prix_min}‚Ç¨ et {prix_max}‚Ç¨")

# GROUP BY - Grouper par auteur et compter
resultats = session.query(
    Auteur.nom,
    func.count(Livre.id).label('nombre_livres')
)\
    .join(Livre)\
    .group_by(Auteur.nom)\
    .all()

for nom, nb in resultats:
    print(f"{nom} a √©crit {nb} livre(s)")

# HAVING - Filtrer apr√®s groupement
# Auteurs ayant √©crit plus de 3 livres
auteurs_prolifiques = session.query(
    Auteur.nom,
    func.count(Livre.id).label('nombre_livres')
)\
    .join(Livre)\
    .group_by(Auteur.nom)\
    .having(func.count(Livre.id) > 3)\
    .all()
```

### Sous-requ√™tes

Les sous-requ√™tes permettent d'utiliser le r√©sultat d'une requ√™te dans une autre requ√™te.

```python
# Trouver les livres plus chers que la moyenne
prix_moyen_subq = session.query(func.avg(Livre.prix)).scalar_subquery()

livres_chers = session.query(Livre)\
    .filter(Livre.prix > prix_moyen_subq)\
    .all()

# Trouver les auteurs qui ont √©crit au moins un livre apr√®s 2000
subq = session.query(Livre.auteur_id)\
    .filter(Livre.annee_publication > 2000)\
    .subquery()

auteurs = session.query(Auteur)\
    .filter(Auteur.id.in_(subq))\
    .all()

# Sous-requ√™te corr√©l√©e
# Auteurs avec le nombre de leurs livres
from sqlalchemy.orm import aliased

livre_subq = session.query(
    func.count(Livre.id)
).filter(Livre.auteur_id == Auteur.id).correlate(Auteur).scalar_subquery()

auteurs_avec_compte = session.query(
    Auteur.nom,
    livre_subq.label('nb_livres')
).all()
```

### Requ√™tes SQL brutes

Parfois, vous aurez besoin d'ex√©cuter du SQL directement.

```python
from sqlalchemy import text

# Requ√™te SQL simple
resultat = session.execute(
    text("SELECT * FROM livres WHERE prix > :prix"),
    {"prix": 20}
)
for row in resultat:
    print(row)

# Mapper les r√©sultats sur des objets
resultat = session.execute(
    text("SELECT * FROM livres WHERE annee_publication > :annee"),
    {"annee": 2000}
)
livres = [Livre(**dict(row._mapping)) for row in resultat]
```

### Requ√™tes optimis√©es avec joinedload et selectinload

Pour √©viter le probl√®me N+1 (vu dans le chapitre pr√©c√©dent), utilisez le chargement anticip√©.

```python
from sqlalchemy.orm import joinedload, selectinload

# Charger les auteurs avec leurs livres en une seule requ√™te
auteurs = session.query(Auteur)\
    .options(selectinload(Auteur.livres))\
    .all()

# Parcourir sans requ√™tes suppl√©mentaires
for auteur in auteurs:
    print(f"\n{auteur.nom} :")
    for livre in auteur.livres:  # Pas de requ√™te SQL ici !
        print(f"  - {livre.titre}")

# joinedload utilise un JOIN SQL
auteurs = session.query(Auteur)\
    .options(joinedload(Auteur.livres))\
    .all()
```

### Exemple complet de recherche avanc√©e

```python
def rechercher_livres(
    titre=None,
    auteur_nom=None,
    annee_min=None,
    annee_max=None,
    prix_max=None,
    nationalite=None,
    tri_par='titre',
    ordre='asc',
    page=1,
    par_page=10
):
    """
    Fonction de recherche flexible avec multiples crit√®res.
    """
    query = session.query(Livre).join(Auteur)

    # Application des filtres
    if titre:
        query = query.filter(Livre.titre.like(f'%{titre}%'))

    if auteur_nom:
        query = query.filter(Auteur.nom.like(f'%{auteur_nom}%'))

    if annee_min:
        query = query.filter(Livre.annee_publication >= annee_min)

    if annee_max:
        query = query.filter(Livre.annee_publication <= annee_max)

    if prix_max:
        query = query.filter(Livre.prix <= prix_max)

    if nationalite:
        query = query.filter(Auteur.nationalite == nationalite)

    # Tri
    if tri_par == 'titre':
        colonne = Livre.titre
    elif tri_par == 'prix':
        colonne = Livre.prix
    elif tri_par == 'annee':
        colonne = Livre.annee_publication
    else:
        colonne = Livre.titre

    if ordre == 'desc':
        query = query.order_by(colonne.desc())
    else:
        query = query.order_by(colonne)

    # Pagination
    total = query.count()
    livres = query.offset((page - 1) * par_page).limit(par_page).all()

    return {
        'livres': livres,
        'total': total,
        'page': page,
        'par_page': par_page,
        'total_pages': (total + par_page - 1) // par_page
    }


# Utilisation
resultats = rechercher_livres(
    titre='Python',
    annee_min=2015,
    prix_max=40,
    tri_par='annee',
    ordre='desc',
    page=1,
    par_page=5
)

print(f"Trouv√© {resultats['total']} livre(s)")
print(f"Page {resultats['page']}/{resultats['total_pages']}")
for livre in resultats['livres']:
    print(f"- {livre.titre} ({livre.annee_publication}) - {livre.prix}‚Ç¨")
```

## Partie 2 : Migrations avec Alembic

### Qu'est-ce qu'une migration ?

Une **migration** est une modification contr√¥l√©e du sch√©ma de votre base de donn√©es. Par exemple :
- Ajouter une nouvelle colonne √† une table
- Supprimer une table
- Renommer une colonne
- Changer le type d'une colonne
- Ajouter une contrainte

**Pourquoi utiliser des migrations ?**
- Versionner l'√©volution de votre base de donn√©es
- Appliquer les m√™mes changements sur diff√©rents environnements (d√©veloppement, test, production)
- Pouvoir annuler des changements (rollback)
- Collaborer efficacement en √©quipe

### Introduction √† Alembic

**Alembic** est l'outil de migration officiel pour SQLAlchemy. Il permet de :
- G√©n√©rer automatiquement des scripts de migration
- Appliquer ou annuler des migrations
- Garder un historique des changements

### Installation

```bash
pip install alembic
```

### Configuration initiale

Dans le r√©pertoire de votre projet, initialisez Alembic :

```bash
alembic init alembic
```

Cette commande cr√©e :
- Un dossier `alembic/` contenant les scripts de migration
- Un fichier `alembic.ini` de configuration

**Structure cr√©√©e :**
```
mon_projet/
‚îú‚îÄ‚îÄ alembic/
‚îÇ   ‚îú‚îÄ‚îÄ versions/          # Dossier des migrations
‚îÇ   ‚îú‚îÄ‚îÄ env.py             # Configuration de l'environnement
‚îÇ   ‚îú‚îÄ‚îÄ script.py.mako     # Template pour les migrations
‚îÇ   ‚îî‚îÄ‚îÄ README
‚îú‚îÄ‚îÄ alembic.ini            # Fichier de configuration principal
‚îî‚îÄ‚îÄ models.py              # Vos mod√®les SQLAlchemy
```

### Configuration de la connexion

#### 1. Modifier alembic.ini

Ouvrez `alembic.ini` et modifiez la ligne `sqlalchemy.url` :

```ini
# alembic.ini
sqlalchemy.url = sqlite:///ma_base.db

# Pour PostgreSQL
# sqlalchemy.url = postgresql://user:password@localhost/ma_base

# Pour MySQL
# sqlalchemy.url = mysql://user:password@localhost/ma_base
```

#### 2. Configurer env.py

Ouvrez `alembic/env.py` et importez vos mod√®les :

```python
# alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context

# Importez votre Base et vos mod√®les
from models import Base  # Ajustez selon votre structure

# Configuration d'Alembic
config = context.config

# D√©finir le metadata pour la d√©tection automatique
target_metadata = Base.metadata

# Le reste du fichier reste identique...
```

### Cr√©er votre premi√®re migration

Supposons que vous avez ces mod√®les initiaux :

```python
# models.py
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
```

**G√©n√©rer la migration initiale :**

```bash
alembic revision --autogenerate -m "Cr√©ation table users"
```

**Explication :**
- `revision` : Cr√©er une nouvelle migration
- `--autogenerate` : D√©tecter automatiquement les changements
- `-m` : Message d√©crivant la migration

Cette commande cr√©e un fichier dans `alembic/versions/` :

```python
# alembic/versions/xxxx_creation_table_users.py
"""Cr√©ation table users

Revision ID: xxxx
Revises:
Create Date: 2024-01-15 10:30:00

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'xxxx'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # Cr√©er la table users
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=100), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('username'),
        sa.UniqueConstraint('email')
    )


def downgrade():
    # Annuler : supprimer la table
    op.drop_table('users')
```

### Appliquer une migration

```bash
# Appliquer toutes les migrations en attente
alembic upgrade head

# Appliquer jusqu'√† une r√©vision sp√©cifique
alembic upgrade xxxx

# Appliquer une migration √† la fois
alembic upgrade +1
```

**R√©sultat :**
```
INFO [alembic.runtime.migration] Running upgrade  -> xxxx, Cr√©ation table users
```

### Annuler une migration (rollback)

```bash
# Annuler la derni√®re migration
alembic downgrade -1

# Revenir √† une r√©vision sp√©cifique
alembic downgrade xxxx

# Tout annuler
alembic downgrade base
```

### Modifier le sch√©ma : ajouter une colonne

Modifions notre mod√®le pour ajouter une colonne :

```python
# models.py
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    age = Column(Integer)  # Nouvelle colonne
```

**G√©n√©rer la migration :**

```bash
alembic revision --autogenerate -m "Ajout colonne age"
```

**Fichier g√©n√©r√© :**

```python
# alembic/versions/yyyy_ajout_colonne_age.py
def upgrade():
    op.add_column('users', sa.Column('age', sa.Integer(), nullable=True))


def downgrade():
    op.drop_column('users', 'age')
```

**Appliquer :**

```bash
alembic upgrade head
```

### Op√©rations courantes de migration

#### Ajouter une colonne

```python
def upgrade():
    op.add_column('users', sa.Column('date_creation', sa.DateTime(), nullable=True))
```

#### Supprimer une colonne

```python
def upgrade():
    op.drop_column('users', 'age')
```

#### Renommer une colonne

```python
def upgrade():
    op.alter_column('users', 'username', new_column_name='nom_utilisateur')
```

#### Modifier le type d'une colonne

```python
def upgrade():
    # SQLite ne supporte pas ALTER COLUMN, il faut recr√©er la table
    op.alter_column('users', 'age',
                    existing_type=sa.Integer(),
                    type_=sa.String(length=3),
                    existing_nullable=True)
```

#### Cr√©er une table

```python
def upgrade():
    op.create_table(
        'articles',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('titre', sa.String(200), nullable=False),
        sa.Column('contenu', sa.Text()),
        sa.Column('user_id', sa.Integer(), sa.ForeignKey('users.id'))
    )
```

#### Supprimer une table

```python
def upgrade():
    op.drop_table('articles')
```

#### Ajouter un index

```python
def upgrade():
    op.create_index('idx_user_email', 'users', ['email'])

def downgrade():
    op.drop_index('idx_user_email', table_name='users')
```

#### Ajouter une cl√© √©trang√®re

```python
def upgrade():
    op.create_foreign_key(
        'fk_article_user',      # Nom de la contrainte
        'articles',              # Table source
        'users',                 # Table r√©f√©renc√©e
        ['user_id'],             # Colonne source
        ['id']                   # Colonne r√©f√©renc√©e
    )
```

### Migration de donn√©es

Parfois, vous devez aussi migrer les donn√©es existantes :

```python
def upgrade():
    # Ajouter une colonne
    op.add_column('users', sa.Column('full_name', sa.String(100), nullable=True))

    # Migrer les donn√©es
    connection = op.get_bind()
    connection.execute(
        text("UPDATE users SET full_name = username WHERE full_name IS NULL")
    )

    # Rendre la colonne obligatoire
    op.alter_column('users', 'full_name', nullable=False)
```

### Migrations manuelles

Si l'autogenerate ne d√©tecte pas vos changements, cr√©ez une migration manuelle :

```bash
alembic revision -m "Migration personnalis√©e"
```

√âditez ensuite le fichier cr√©√© :

```python
def upgrade():
    # Vos op√©rations personnalis√©es
    op.execute("INSERT INTO users (username, email) VALUES ('admin', 'admin@example.com')")


def downgrade():
    # Annulation
    op.execute("DELETE FROM users WHERE username = 'admin'")
```

### V√©rifier l'√©tat des migrations

```bash
# Afficher la r√©vision actuelle
alembic current

# Afficher l'historique
alembic history

# Afficher les d√©tails
alembic history --verbose

# Voir les migrations en attente
alembic show head
```

### Bonnes pratiques

#### 1. Versionner les migrations

Ajoutez le dossier `alembic/versions/` √† votre syst√®me de contr√¥le de version (Git).

```bash
git add alembic/versions/
git commit -m "Ajout migration: cr√©ation table users"
```

#### 2. Toujours tester les migrations

```bash
# Appliquer la migration
alembic upgrade head

# Tester votre application

# Tester le rollback
alembic downgrade -1

# R√©appliquer
alembic upgrade head
```

#### 3. Nommer clairement les migrations

```bash
# Bon
alembic revision --autogenerate -m "Ajout colonne email_verified dans users"

# Moins bon
alembic revision --autogenerate -m "Update"
```

#### 4. Ne pas modifier les migrations appliqu√©es

Une fois qu'une migration est appliqu√©e en production, ne la modifiez jamais. Cr√©ez plut√¥t une nouvelle migration corrective.

#### 5. Sauvegarder avant migration en production

```bash
# Sauvegarder la base
pg_dump ma_base > backup_avant_migration.sql

# Appliquer la migration
alembic upgrade head

# En cas de probl√®me
psql ma_base < backup_avant_migration.sql
```

### Exemple complet : √©volution d'un projet

**√âtat initial :**

```python
# models.py - version 1
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String(50))
```

```bash
alembic revision --autogenerate -m "Initial: table users"
alembic upgrade head
```

**√âvolution 1 : Ajouter email**

```python
# models.py - version 2
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String(50))
    email = Column(String(100))  # Nouveau
```

```bash
alembic revision --autogenerate -m "Ajout colonne email"
alembic upgrade head
```

**√âvolution 2 : Cr√©er table articles**

```python
# models.py - version 3
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String(50))
    email = Column(String(100))
    articles = relationship("Article", back_populates="auteur")

class Article(Base):  # Nouvelle table
    __tablename__ = 'articles'
    id = Column(Integer, primary_key=True)
    titre = Column(String(200))
    contenu = Column(Text)
    user_id = Column(Integer, ForeignKey('users.id'))
    auteur = relationship("User", back_populates="articles")
```

```bash
alembic revision --autogenerate -m "Cr√©ation table articles"
alembic upgrade head
```

**Historique complet :**

```bash
alembic history
```

R√©sultat :
```
abc123 -> def456 (head), Cr√©ation table articles
xyz789 -> abc123, Ajout colonne email
<base> -> xyz789, Initial: table users
```

### Gestion d'environnements multiples

#### Configuration pour plusieurs environnements

Cr√©ez diff√©rents fichiers de configuration :

```python
# config.py
import os

class Config:
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URL', 'sqlite:///dev.db')

class DevelopmentConfig(Config):
    SQLALCHEMY_DATABASE_URI = 'sqlite:///dev.db'

class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URL')

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig
}
```

#### Utilisation

```bash
# D√©veloppement
export DATABASE_URL="sqlite:///dev.db"
alembic upgrade head

# Production
export DATABASE_URL="postgresql://user:pass@prod-server/ma_base"
alembic upgrade head
```

### D√©bogage des migrations

```bash
# Mode verbeux pour voir les requ√™tes SQL
alembic --verbose upgrade head

# Afficher le SQL sans l'ex√©cuter
alembic upgrade head --sql

# G√©n√©rer le SQL dans un fichier
alembic upgrade head --sql > migration.sql
```

### R√©solution de probl√®mes courants

#### Probl√®me 1 : Migration non d√©tect√©e

```python
# V√©rifiez que target_metadata est bien d√©fini dans env.py
from models import Base
target_metadata = Base.metadata
```

#### Probl√®me 2 : Conflit de r√©vision

```bash
# Si deux d√©veloppeurs cr√©ent des migrations en parall√®le
alembic merge -m "Fusion des branches" head1 head2
```

#### Probl√®me 3 : Base d√©synchronis√©e

```bash
# Marquer la base comme √† jour sans ex√©cuter les migrations
alembic stamp head
```

## R√©sum√©

### Requ√™tes avanc√©es

**Points cl√©s :**
- Filtres multiples avec `filter()`, `and_()`, `or_()`
- Op√©rateurs : `like()`, `in_()`, `between()`, etc.
- Tri avec `order_by()` et pagination avec `limit()`/`offset()`
- Jointures avec `join()` et `outerjoin()`
- Agr√©gations : `count()`, `sum()`, `avg()`, `min()`, `max()`
- Optimisation avec `joinedload()` et `selectinload()`

### Migrations

**Points cl√©s :**
- Alembic g√®re l'√©volution du sch√©ma de base de donn√©es
- `alembic init` : Initialiser
- `alembic revision --autogenerate` : Cr√©er une migration
- `alembic upgrade head` : Appliquer les migrations
- `alembic downgrade -1` : Annuler une migration
- Toujours versionner les migrations
- Tester avant la production

**Commandes essentielles :**
```bash
alembic init alembic                           # Initialisation
alembic revision --autogenerate -m "message"   # Nouvelle migration
alembic upgrade head                           # Appliquer tout
alembic downgrade -1                           # Annuler une
alembic current                                # √âtat actuel
alembic history                                # Historique
```

Vous ma√Ætrisez maintenant les requ√™tes avanc√©es et la gestion des migrations avec SQLAlchemy et Alembic ! Ces comp√©tences sont essentielles pour construire et maintenir des applications professionnelles avec des bases de donn√©es √©volutives.

‚è≠Ô∏è [Projets pratiques et bonnes pratiques](/12-projets-et-bonnes-pratiques/README.md)
