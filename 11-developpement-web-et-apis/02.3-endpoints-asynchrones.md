üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.2.3 Endpoints asynchrones et performances

## Introduction

L'une des grandes forces de FastAPI est sa capacit√© √† g√©rer facilement la **programmation asynchrone**. Ce concept peut sembler intimidant au d√©but, mais il est en r√©alit√© assez simple √† comprendre et extr√™mement puissant pour cr√©er des APIs performantes.

Dans cette section, nous allons d√©couvrir ce qu'est la programmation asynchrone, pourquoi elle est importante, et comment l'utiliser avec FastAPI pour cr√©er des applications ultra-rapides.

## Qu'est-ce que la programmation asynchrone ?

### Analogie avec un restaurant

Imaginez un restaurant avec un seul serveur :

**Mode synchrone (traditionnel) :**
1. Le serveur prend la commande du client 1
2. Le serveur attend que la cuisine pr√©pare le plat (il ne fait rien d'autre)
3. Le serveur apporte le plat au client 1
4. Seulement maintenant, il peut prendre la commande du client 2

C'est inefficace ! Le serveur perd du temps √† attendre.

**Mode asynchrone :**
1. Le serveur prend la commande du client 1
2. Il envoie la commande en cuisine
3. **Pendant que la cuisine pr√©pare**, il prend la commande du client 2
4. Il envoie la commande 2 en cuisine
5. Il prend la commande du client 3
6. Quand un plat est pr√™t, il le livre
7. Il continue √† prendre d'autres commandes

Le serveur est beaucoup plus productif ! C'est exactement le principe de la programmation asynchrone.

### En informatique

**Code synchrone :** Chaque op√©ration attend que la pr√©c√©dente soit termin√©e avant de commencer.

**Code asynchrone :** Pendant qu'une op√©ration attend (une r√©ponse d'une base de donn√©es, d'une API externe, etc.), le programme peut faire autre chose.

### Quand est-ce utile ?

La programmation asynchrone est particuli√®rement utile quand votre application passe beaucoup de temps √† **attendre** :
- ‚è≥ Requ√™tes vers des bases de donn√©es
- ‚è≥ Appels vers des APIs externes
- ‚è≥ Lecture/√©criture de fichiers
- ‚è≥ Op√©rations r√©seau

C'est ce qu'on appelle des **op√©rations I/O** (Input/Output).

## Programmation synchrone vs asynchrone

### Exemple synchrone

```python
from fastapi import FastAPI
import time

app = FastAPI()

@app.get("/utilisateur/{id}")
def lire_utilisateur(id: int):
    # Simuler une requ√™te base de donn√©es (prend 2 secondes)
    time.sleep(2)
    return {"id": id, "nom": f"Utilisateur {id}"}
```

Si 3 clients font une requ√™te en m√™me temps :
- Client 1 : attend 2 secondes
- Client 2 : attend 4 secondes (2 + 2)
- Client 3 : attend 6 secondes (2 + 2 + 2)

**Temps total : 6 secondes**

### Exemple asynchrone

```python
from fastapi import FastAPI
import asyncio

app = FastAPI()

@app.get("/utilisateur/{id}")
async def lire_utilisateur(id: int):
    # Simuler une requ√™te base de donn√©es (prend 2 secondes)
    await asyncio.sleep(2)
    return {"id": id, "nom": f"Utilisateur {id}"}
```

Si 3 clients font une requ√™te en m√™me temps :
- Les 3 requ√™tes sont trait√©es en parall√®le
- Tous re√ßoivent leur r√©ponse apr√®s environ 2 secondes

**Temps total : ~2 secondes**

C'est beaucoup plus rapide ! üöÄ

## Les mots-cl√©s async et await

La programmation asynchrone en Python utilise deux mots-cl√©s principaux :

### async

Le mot-cl√© `async` d√©finit une fonction asynchrone (aussi appel√©e **coroutine**) :

```python
async def ma_fonction():
    return "Bonjour"
```

Une fonction asynchrone ne s'ex√©cute pas imm√©diatement quand elle est appel√©e. Elle retourne un objet qui peut √™tre "attendu".

### await

Le mot-cl√© `await` est utilis√© pour attendre le r√©sultat d'une op√©ration asynchrone :

```python
async def ma_fonction():
    resultat = await operation_asynchrone()
    return resultat
```

**Important :** Vous ne pouvez utiliser `await` que dans une fonction `async`.

### R√®gles de base

```python
# ‚úÖ Correct
async def fonction_async():
    resultat = await autre_fonction_async()
    return resultat

# ‚ùå Incorrect - await sans async
def fonction_normale():
    resultat = await autre_fonction_async()  # Erreur !
    return resultat

# ‚úÖ Correct - async sans await (mais moins utile)
async def fonction_async_simple():
    return "Hello"  # Pas d'attente, mais c'est quand m√™me async
```

## Cr√©er des endpoints asynchrones avec FastAPI

FastAPI rend la cr√©ation d'endpoints asynchrones extr√™mement simple. Il suffit d'ajouter `async` devant votre fonction !

### Endpoint synchrone classique

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def lire_racine():
    return {"message": "Hello World"}
```

### Endpoint asynchrone

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def lire_racine():
    return {"message": "Hello World"}
```

La seule diff√©rence ? Le mot `async` ! C'est tout.

## Quand utiliser async ?

Voici un guide simple pour savoir quand utiliser `async` :

### ‚úÖ Utilisez async quand vous faites :

- Des requ√™tes vers une **base de donn√©es** (avec un driver asynchrone)
- Des appels vers des **APIs externes**
- De la **lecture/√©criture de fichiers** (avec des biblioth√®ques async)
- Des **op√©rations r√©seau**
- N'importe quelle op√©ration qui **attend** quelque chose

### ‚ùå N'utilisez PAS async quand vous faites :

- Des **calculs intensifs** (math√©matiques, traitement de donn√©es)
- Des op√©rations **purement CPU** sans attente
- Des op√©rations tr√®s rapides qui ne bloquent pas

### Exemple : Calcul intensif (ne pas utiliser async)

```python
@app.get("/calcul")
def calculer_fibonacci(n: int):
    # Calcul intensif - mieux en synchrone
    def fib(x):
        if x <= 1:
            return x
        return fib(x-1) + fib(x-2)

    return {"resultat": fib(n)}
```

### Exemple : Requ√™te externe (utiliser async)

```python
import httpx

@app.get("/meteo")
async def obtenir_meteo(ville: str):
    async with httpx.AsyncClient() as client:
        # Requ√™te HTTP vers une API externe
        response = await client.get(f"https://api.meteo.com/{ville}")
        return response.json()
```

## Biblioth√®ques asynchrones courantes

Pour profiter pleinement de l'asynchrone, vous devez utiliser des biblioth√®ques qui le supportent.

### Pour les requ√™tes HTTP : httpx

`httpx` est l'√©quivalent asynchrone de `requests` :

```bash
pip install httpx
```

**Utilisation synchrone (requests) :**
```python
import requests

@app.get("/utilisateurs")
def lire_utilisateurs():
    response = requests.get("https://api.example.com/users")
    return response.json()
```

**Utilisation asynchrone (httpx) :**
```python
import httpx

@app.get("/utilisateurs")
async def lire_utilisateurs():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/users")
        return response.json()
```

### Pour les bases de donn√©es

**SQLAlchemy avec support async :**
```bash
pip install sqlalchemy[asyncio]
```

**Motor (MongoDB async) :**
```bash
pip install motor
```

**Databases (multi-DB async) :**
```bash
pip install databases
```

### Pour les fichiers

**aiofiles (lecture/√©criture async) :**
```bash
pip install aiofiles
```

```python
import aiofiles

@app.get("/lire-fichier")
async def lire_fichier():
    async with aiofiles.open('mon_fichier.txt', mode='r') as f:
        contenu = await f.read()
    return {"contenu": contenu}
```

## Exemple pratique : API avec appels externes

Cr√©ons une API qui r√©cup√®re des informations depuis plusieurs sources externes :

```python
from fastapi import FastAPI
import httpx
import asyncio

app = FastAPI()

@app.get("/informations/{nom_utilisateur}")
async def obtenir_informations(nom_utilisateur: str):
    """
    R√©cup√®re les informations d'un utilisateur depuis plusieurs APIs
    """

    async with httpx.AsyncClient() as client:
        # Lancer toutes les requ√™tes en parall√®le
        taches = [
            client.get(f"https://api.github.com/users/{nom_utilisateur}"),
            client.get(f"https://api.twitter.com/users/{nom_utilisateur}"),
            client.get(f"https://api.linkedin.com/users/{nom_utilisateur}")
        ]

        # Attendre que toutes les requ√™tes se terminent
        reponses = await asyncio.gather(*taches, return_exceptions=True)

        resultats = {
            "github": reponses[0].json() if not isinstance(reponses[0], Exception) else None,
            "twitter": reponses[1].json() if not isinstance(reponses[1], Exception) else None,
            "linkedin": reponses[2].json() if not isinstance(reponses[2], Exception) else None
        }

        return resultats
```

### Explications

- `async with` : Context manager asynchrone
- `asyncio.gather()` : Ex√©cute plusieurs op√©rations asynchrones en parall√®le
- `return_exceptions=True` : Continue m√™me si certaines requ√™tes √©chouent

**Avantage :** Les 3 requ√™tes se font en parall√®le au lieu de l'une apr√®s l'autre !

**Temps synchrone :** Si chaque requ√™te prend 1 seconde = 3 secondes total
**Temps asynchrone :** Toutes en parall√®le = ~1 seconde total

## asyncio.gather() pour les op√©rations parall√®les

`asyncio.gather()` est un outil puissant pour ex√©cuter plusieurs t√¢ches asynchrones en m√™me temps.

### Exemple simple

```python
import asyncio

@app.get("/multi-fetch")
async def recuperer_multiple():
    async def fetch_data(id: int):
        await asyncio.sleep(1)  # Simule une op√©ration longue
        return {"id": id, "data": f"Donn√©es {id}"}

    # Ex√©cuter 5 requ√™tes en parall√®le
    resultats = await asyncio.gather(
        fetch_data(1),
        fetch_data(2),
        fetch_data(3),
        fetch_data(4),
        fetch_data(5)
    )

    return resultats
```

Au lieu de prendre 5 secondes (1 seconde √ó 5), cela ne prend qu'environ 1 seconde !

### gather vs create_task

```python
import asyncio

# M√©thode 1 : gather (simple et direct)
async def avec_gather():
    resultats = await asyncio.gather(
        operation1(),
        operation2(),
        operation3()
    )
    return resultats

# M√©thode 2 : create_task (plus de contr√¥le)
async def avec_tasks():
    task1 = asyncio.create_task(operation1())
    task2 = asyncio.create_task(operation2())
    task3 = asyncio.create_task(operation3())

    resultat1 = await task1
    resultat2 = await task2
    resultat3 = await task3

    return [resultat1, resultat2, resultat3]
```

`gather` est plus simple, `create_task` offre plus de flexibilit√©.

## G√©rer les timeouts

Vous pouvez d√©finir des limites de temps pour vos op√©rations asynchrones :

```python
import asyncio

@app.get("/avec-timeout")
async def endpoint_avec_timeout():
    try:
        # Timeout de 5 secondes
        resultat = await asyncio.wait_for(
            operation_longue(),
            timeout=5.0
        )
        return resultat
    except asyncio.TimeoutError:
        return {"erreur": "L'op√©ration a pris trop de temps"}

async def operation_longue():
    await asyncio.sleep(10)  # Prend 10 secondes
    return {"data": "Termin√©"}
```

## Concurrence vs Parall√©lisme

Il est important de comprendre la diff√©rence :

### Concurrence (Asynchrone)

Plusieurs t√¢ches progressent pendant des p√©riodes de temps qui se chevauchent, mais **pas exactement en m√™me temps**.

```
T√¢che A: ===|wait|========|wait|===
T√¢che B:    |wait|====|wait|========
T√¢che C:         |wait|====|wait|===
```

C'est ce que fait `async/await` - pendant qu'une t√¢che attend, une autre peut travailler.

### Parall√©lisme (Multiprocessing)

Plusieurs t√¢ches s'ex√©cutent **litt√©ralement en m√™me temps** sur plusieurs c≈ìurs CPU.

```
Core 1: T√¢che A ====================
Core 2: T√¢che B ====================
Core 3: T√¢che C ====================
```

FastAPI avec `async/await` fait de la **concurrence**, pas du parall√©lisme.

## Performances : Benchmark

Comparons les performances avec un exemple concret :

### Version synchrone

```python
import time

@app.get("/sync/utilisateurs")
def obtenir_utilisateurs_sync():
    resultats = []
    for i in range(10):
        time.sleep(0.5)  # Simule une requ√™te base de donn√©es
        resultats.append({"id": i, "nom": f"Utilisateur {i}"})
    return resultats
```

**Temps d'ex√©cution :** 10 √ó 0.5 = **5 secondes**

### Version asynchrone

```python
import asyncio

@app.get("/async/utilisateurs")
async def obtenir_utilisateurs_async():
    async def fetch_user(i):
        await asyncio.sleep(0.5)  # Simule une requ√™te base de donn√©es
        return {"id": i, "nom": f"Utilisateur {i}"}

    resultats = await asyncio.gather(*[fetch_user(i) for i in range(10)])
    return resultats
```

**Temps d'ex√©cution :** **0.5 secondes** (toutes en parall√®le !)

**Am√©lioration :** 10x plus rapide ! üöÄ

## Pi√®ges courants et comment les √©viter

### 1. M√©langer sync et async

‚ùå **Mauvais :**
```python
import time

@app.get("/mauvais")
async def mauvais_endpoint():
    time.sleep(2)  # Bloque tout !
    return {"message": "Termin√©"}
```

‚úÖ **Bon :**
```python
import asyncio

@app.get("/bon")
async def bon_endpoint():
    await asyncio.sleep(2)  # Permet √† d'autres t√¢ches de s'ex√©cuter
    return {"message": "Termin√©"}
```

### 2. Oublier await

‚ùå **Mauvais :**
```python
@app.get("/oubli-await")
async def oubli_await():
    resultat = operation_async()  # Manque await !
    return resultat  # Retourne un objet coroutine, pas le r√©sultat
```

‚úÖ **Bon :**
```python
@app.get("/bon-await")
async def bon_await():
    resultat = await operation_async()  # Avec await
    return resultat
```

### 3. Utiliser des biblioth√®ques synchrones dans du code async

‚ùå **Mauvais :**
```python
import requests

@app.get("/mauvais-requete")
async def mauvais_requete():
    # requests est synchrone, bloque l'event loop
    response = requests.get("https://api.example.com")
    return response.json()
```

‚úÖ **Bon :**
```python
import httpx

@app.get("/bonne-requete")
async def bonne_requete():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com")
        return response.json()
```

### 4. Trop de t√¢ches en parall√®le

Attention √† ne pas cr√©er des milliers de t√¢ches en m√™me temps. Utilisez des limiteurs de concurrence :

```python
from asyncio import Semaphore

@app.get("/avec-limite")
async def avec_limite():
    semaphore = Semaphore(10)  # Maximum 10 t√¢ches simultan√©es

    async def fetch_with_limit(id: int):
        async with semaphore:
            await asyncio.sleep(1)
            return {"id": id}

    resultats = await asyncio.gather(*[fetch_with_limit(i) for i in range(100)])
    return resultats
```

## Background tasks : T√¢ches en arri√®re-plan

Parfois, vous voulez d√©clencher une t√¢che mais r√©pondre imm√©diatement au client sans attendre :

```python
from fastapi import BackgroundTasks

def envoyer_email(destinataire: str):
    # Fonction qui prend du temps
    time.sleep(5)
    print(f"Email envoy√© √† {destinataire}")

@app.post("/inscription")
async def inscription(email: str, background_tasks: BackgroundTasks):
    # Ajouter une t√¢che en arri√®re-plan
    background_tasks.add_task(envoyer_email, email)

    # R√©ponse imm√©diate sans attendre l'email
    return {"message": "Inscription r√©ussie, email de confirmation en cours d'envoi"}
```

Le client re√ßoit une r√©ponse imm√©diate, et l'email est envoy√© en arri√®re-plan.

### Version asynchrone des background tasks

```python
async def envoyer_email_async(destinataire: str):
    await asyncio.sleep(5)  # Op√©ration asynchrone
    print(f"Email envoy√© √† {destinataire}")

@app.post("/inscription-async")
async def inscription_async(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(envoyer_email_async, email)
    return {"message": "Inscription r√©ussie"}
```

## Exemple complet : API de m√©t√©o avec cache

Voici un exemple complet qui combine plusieurs concepts :

```python
from fastapi import FastAPI, HTTPException
import httpx
import asyncio
from datetime import datetime, timedelta
from typing import Optional

app = FastAPI()

# Cache simple en m√©moire
cache_meteo = {}

@app.get("/meteo/{ville}")
async def obtenir_meteo(ville: str):
    """
    R√©cup√®re la m√©t√©o d'une ville avec mise en cache
    """

    # V√©rifier le cache
    if ville in cache_meteo:
        donnees_cache = cache_meteo[ville]
        if datetime.now() - donnees_cache["timestamp"] < timedelta(minutes=30):
            return {
                "source": "cache",
                "data": donnees_cache["data"]
            }

    # Pas en cache ou expir√©, faire la requ√™te
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"https://api.openweathermap.org/data/2.5/weather",
                params={"q": ville, "appid": "VOTRE_CLE_API"},
                timeout=5.0
            )
            response.raise_for_status()
            data = response.json()

            # Mettre en cache
            cache_meteo[ville] = {
                "data": data,
                "timestamp": datetime.now()
            }

            return {
                "source": "api",
                "data": data
            }

    except httpx.TimeoutException:
        raise HTTPException(status_code=504, detail="Timeout lors de la r√©cup√©ration de la m√©t√©o")
    except httpx.HTTPError as e:
        raise HTTPException(status_code=500, detail=f"Erreur API: {str(e)}")

@app.get("/meteo-multiple")
async def obtenir_meteo_multiple(villes: str):
    """
    R√©cup√®re la m√©t√©o de plusieurs villes en parall√®le
    Exemple: /meteo-multiple?villes=Paris,Londres,Berlin
    """
    liste_villes = [v.strip() for v in villes.split(",")]

    # R√©cup√©rer toutes les m√©t√©os en parall√®le
    resultats = await asyncio.gather(
        *[obtenir_meteo(ville) for ville in liste_villes],
        return_exceptions=True
    )

    # Formater les r√©sultats
    reponse = {}
    for ville, resultat in zip(liste_villes, resultats):
        if isinstance(resultat, Exception):
            reponse[ville] = {"erreur": str(resultat)}
        else:
            reponse[ville] = resultat

    return reponse

@app.delete("/cache")
async def vider_cache():
    """Vider le cache de m√©t√©o"""
    cache_meteo.clear()
    return {"message": "Cache vid√© avec succ√®s"}
```

## Monitoring et profiling

Pour mesurer les performances de vos endpoints :

### Avec un middleware de timing

```python
from fastapi import FastAPI, Request
import time

app = FastAPI()

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

Maintenant, chaque r√©ponse inclura le temps de traitement dans les headers !

### Logging des performances

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.get("/test-perf")
async def test_performance():
    start = time.time()

    # Votre code ici
    await asyncio.sleep(0.5)

    duree = time.time() - start
    logger.info(f"Endpoint ex√©cut√© en {duree:.2f} secondes")

    return {"duree": duree}
```

## Bonnes pratiques pour les performances

### 1. Utilisez async pour les op√©rations I/O

Toutes les op√©rations qui attendent (base de donn√©es, API, fichiers) doivent √™tre asynchrones.

### 2. Limitez la concurrence

Ne lancez pas des milliers de t√¢ches en m√™me temps. Utilisez des limiteurs.

### 3. Mettez en cache

Les donn√©es qui changent peu doivent √™tre mises en cache pour √©viter des requ√™tes inutiles.

### 4. Utilisez des timeouts

D√©finissez toujours des timeouts pour vos op√©rations externes.

### 5. Monitez vos performances

Utilisez des outils pour mesurer et identifier les goulots d'√©tranglement.

### 6. Connection pooling

Pour les bases de donn√©es, utilisez un pool de connexions :

```python
from sqlalchemy.ext.asyncio import create_async_engine

engine = create_async_engine(
    "postgresql+asyncpg://user:pass@localhost/db",
    pool_size=20,  # 20 connexions dans le pool
    max_overflow=10
)
```

## Quand NE PAS utiliser async

L'asynchrone n'est pas toujours la solution. N'utilisez pas async si :

1. **Calculs intensifs CPU** : Les calculs purs ne b√©n√©ficient pas d'async
2. **Code bloquant in√©vitable** : Si vous devez utiliser des biblioth√®ques synchrones
3. **Simplicit√© n√©cessaire** : Pour des scripts simples, le synchrone est plus simple
4. **Pas d'op√©rations I/O** : Si votre code ne fait qu'ex√©cuter de la logique

Pour les calculs intensifs, utilisez plut√¥t le **multiprocessing**.

## R√©capitulatif

Dans cette section, vous avez appris :

‚úÖ Ce qu'est la programmation asynchrone et pourquoi elle est importante
‚úÖ Comment utiliser `async` et `await` en Python
‚úÖ Quand utiliser async et quand ne pas l'utiliser
‚úÖ Comment cr√©er des endpoints asynchrones avec FastAPI
‚úÖ Comment utiliser des biblioth√®ques asynchrones (httpx, aiofiles, etc.)
‚úÖ Comment ex√©cuter plusieurs t√¢ches en parall√®le avec `asyncio.gather()`
‚úÖ Comment g√©rer les timeouts et les erreurs
‚úÖ Les pi√®ges courants et comment les √©viter
‚úÖ Comment utiliser les background tasks
‚úÖ Les bonnes pratiques pour optimiser les performances

Avec la programmation asynchrone, vous pouvez cr√©er des APIs FastAPI incroyablement performantes capables de g√©rer des milliers de requ√™tes simultan√©es ! C'est l'un des grands avantages de FastAPI par rapport √† d'autres frameworks Python.

---


‚è≠Ô∏è [Flask - Micro-framework l√©ger](/11-developpement-web-et-apis/03-flask-micro-framework.md)
