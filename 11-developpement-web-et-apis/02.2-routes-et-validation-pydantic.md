üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.2.2 Routes et validation avec Pydantic

## Introduction

Dans la section pr√©c√©dente, vous avez cr√©√© votre premi√®re API FastAPI avec des routes simples. Maintenant, nous allons aller plus loin en d√©couvrant **Pydantic**, l'une des fonctionnalit√©s les plus puissantes de FastAPI. Pydantic permet de valider automatiquement les donn√©es que vous recevez et envoyez, rendant votre API robuste et fiable.

## Qu'est-ce que Pydantic ?

**Pydantic** est une biblioth√®que Python qui permet de valider des donn√©es en utilisant les annotations de type Python. C'est comme avoir un garde du corps pour vos donn√©es : il v√©rifie que tout est conforme avant de laisser entrer quoi que ce soit dans votre application.

### Analogie simple

Imaginez un formulaire d'inscription sur un site web :
- Sans validation : N'importe qui peut √©crire n'importe quoi (un √¢ge n√©gatif, un email invalide, etc.)
- Avec Pydantic : Le formulaire v√©rifie automatiquement que l'email est valide, que l'√¢ge est un nombre positif, etc.

Pydantic fait cela pour vous, automatiquement, en utilisant simplement les annotations de type Python !

## Pourquoi Pydantic est essentiel avec FastAPI

FastAPI utilise Pydantic pour :

1. **Valider automatiquement** les donn√©es entrantes
2. **Convertir** les donn√©es dans les bons types
3. **G√©n√©rer automatiquement** la documentation de l'API
4. **Fournir des messages d'erreur clairs** quand les donn√©es sont invalides
5. **Assurer la coh√©rence** des donn√©es dans toute votre application

Le meilleur ? Vous n'avez presque rien √† faire ! Il suffit de d√©finir vos mod√®les de donn√©es, et FastAPI + Pydantic s'occupent du reste.

## Installation de Pydantic

Bonne nouvelle : Pydantic est automatiquement install√© avec FastAPI ! Vous n'avez rien de plus √† installer.

Si toutefois vous voulez v√©rifier :

```bash
pip list | grep pydantic
```

Vous devriez voir `pydantic` dans la liste.

## Les mod√®les Pydantic : BaseModel

Un **mod√®le Pydantic** est une classe Python qui h√©rite de `BaseModel`. C'est dans cette classe que vous d√©finissez la structure de vos donn√©es.

### Votre premier mod√®le

Cr√©ons un mod√®le simple pour repr√©senter un utilisateur :

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

# D√©finir un mod√®le Pydantic
class Utilisateur(BaseModel):
    nom: str
    age: int
    email: str
```

C'est tout ! Vous avez cr√©√© un mod√®le qui d√©finit qu'un utilisateur doit avoir :
- Un `nom` (cha√Æne de caract√®res)
- Un `age` (nombre entier)
- Un `email` (cha√Æne de caract√®res)

### Utiliser le mod√®le dans une route POST

Maintenant, utilisons ce mod√®le dans une route pour cr√©er un utilisateur :

```python
@app.post("/utilisateurs")
def creer_utilisateur(utilisateur: Utilisateur):
    return {
        "message": "Utilisateur cr√©√© avec succ√®s",
        "utilisateur": utilisateur
    }
```

Que se passe-t-il ici ?

1. Le client envoie des donn√©es JSON dans le corps de la requ√™te
2. FastAPI utilise Pydantic pour **valider** ces donn√©es
3. Si les donn√©es sont valides, elles sont converties en objet `Utilisateur`
4. Si les donn√©es sont invalides, FastAPI renvoie automatiquement une erreur 422 avec des d√©tails

### Tester avec la documentation interactive

Lancez votre serveur et allez sur `http://127.0.0.1:8000/docs`. Vous verrez votre route avec un formulaire g√©n√©r√© automatiquement !

Essayez d'envoyer :

```json
{
  "nom": "Alice",
  "age": 25,
  "email": "alice@example.com"
}
```

**R√©ponse :** ‚úÖ Succ√®s !

Maintenant, essayez avec des donn√©es invalides :

```json
{
  "nom": "Bob",
  "age": "vingt-cinq",
  "email": "bob@example.com"
}
```

**R√©ponse :** ‚ùå Erreur ! Pydantic d√©tecte que `"vingt-cinq"` n'est pas un nombre entier et renvoie un message d'erreur clair.

## Types de param√®tres dans FastAPI

FastAPI supporte trois types de param√®tres principaux. Comprendre la diff√©rence est essentiel.

### 1. Param√®tres de chemin (Path Parameters)

Ce sont les param√®tres qui font partie de l'URL elle-m√™me :

```python
@app.get("/utilisateurs/{utilisateur_id}")
def lire_utilisateur(utilisateur_id: int):
    return {"utilisateur_id": utilisateur_id}
```

**Exemple d'URL :** `http://127.0.0.1:8000/utilisateurs/42`

Le `42` est un param√®tre de chemin qui sera automatiquement converti en entier.

### 2. Param√®tres de requ√™te (Query Parameters)

Ce sont les param√®tres qui viennent apr√®s le `?` dans l'URL :

```python
@app.get("/recherche")
def rechercher(q: str, limite: int = 10):
    return {
        "requete": q,
        "limite": limite
    }
```

**Exemple d'URL :** `http://127.0.0.1:8000/recherche?q=python&limite=5`

Les param√®tres de requ√™te sont s√©par√©s par `&`. Remarquez que `limite` a une valeur par d√©faut (`10`), ce qui le rend optionnel.

### 3. Corps de requ√™te (Request Body)

Ce sont les donn√©es envoy√©es dans le corps de la requ√™te (g√©n√©ralement en POST, PUT, PATCH) :

```python
class Article(BaseModel):
    titre: str
    contenu: str

@app.post("/articles")
def creer_article(article: Article):
    return {"article": article}
```

**Donn√©es envoy√©es :**
```json
{
  "titre": "Mon article",
  "contenu": "Contenu de l'article..."
}
```

## Validation avanc√©e avec Pydantic

Pydantic offre de nombreuses fonctionnalit√©s pour valider vos donn√©es de mani√®re pr√©cise.

### Champs optionnels

Certains champs peuvent √™tre optionnels :

```python
from typing import Optional

class Utilisateur(BaseModel):
    nom: str
    age: int
    email: str
    telephone: Optional[str] = None  # Optionnel
```

Avec `Optional[str]`, le champ `telephone` peut √™tre :
- Une cha√Æne de caract√®res
- `None` (la valeur par d√©faut)
- Absent de la requ√™te

### Valeurs par d√©faut

Vous pouvez d√©finir des valeurs par d√©faut pour vos champs :

```python
class Article(BaseModel):
    titre: str
    contenu: str
    publie: bool = False  # Faux par d√©faut
    vues: int = 0         # 0 par d√©faut
```

Si le client n'envoie pas ces champs, les valeurs par d√©faut seront utilis√©es.

### Contraintes de validation

Pydantic permet d'ajouter des contraintes sur vos champs avec `Field` :

```python
from pydantic import BaseModel, Field

class Utilisateur(BaseModel):
    nom: str = Field(..., min_length=2, max_length=50)
    age: int = Field(..., ge=0, le=150)  # ge = greater or equal, le = less or equal
    email: str = Field(..., pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$')
```

Explications :
- `...` signifie "requis" (pas de valeur par d√©faut)
- `min_length=2` : Minimum 2 caract√®res
- `max_length=50` : Maximum 50 caract√®res
- `ge=0` : Greater or Equal (‚â• 0)
- `le=150` : Less or Equal (‚â§ 150)
- `pattern=...` : Expression r√©guli√®re pour valider le format

### Descriptions pour la documentation

Ajoutez des descriptions pour am√©liorer votre documentation automatique :

```python
class Utilisateur(BaseModel):
    nom: str = Field(..., description="Le nom complet de l'utilisateur")
    age: int = Field(..., description="L'√¢ge en ann√©es", ge=0, le=150)
    email: str = Field(..., description="L'adresse email de l'utilisateur")
```

Ces descriptions appara√Ætront dans la documentation Swagger !

### Validation d'email avec EmailStr

Pydantic offre des types sp√©ciaux pour certaines validations courantes :

```python
from pydantic import BaseModel, EmailStr

class Utilisateur(BaseModel):
    nom: str
    age: int
    email: EmailStr  # Valide automatiquement le format email !
```

**Note :** Pour utiliser `EmailStr`, vous devez installer `email-validator` :

```bash
pip install email-validator
```

### Autres types sp√©ciaux Pydantic

```python
from pydantic import BaseModel, HttpUrl, conint, constr

class Profil(BaseModel):
    nom: constr(min_length=2, max_length=50)  # String avec contraintes
    age: conint(ge=0, le=150)                  # Integer avec contraintes
    site_web: HttpUrl                          # Valide les URLs
    email: EmailStr                            # Valide les emails
```

## Combinaison de diff√©rents types de param√®tres

Vous pouvez combiner param√®tres de chemin, de requ√™te et de corps dans une m√™me route :

```python
class ModificationUtilisateur(BaseModel):
    nom: Optional[str] = None
    age: Optional[int] = None

@app.put("/utilisateurs/{utilisateur_id}")
def modifier_utilisateur(
    utilisateur_id: int,                    # Param√®tre de chemin
    notifier: bool = False,                 # Param√®tre de requ√™te
    utilisateur: ModificationUtilisateur    # Corps de requ√™te
):
    return {
        "utilisateur_id": utilisateur_id,
        "modifications": utilisateur,
        "notification_envoyee": notifier
    }
```

**Exemple d'utilisation :**
- URL : `http://127.0.0.1:8000/utilisateurs/42?notifier=true`
- Corps :
```json
{
  "nom": "Alice Dupont",
  "age": 26
}
```

## Mod√®les imbriqu√©s

Vos mod√®les Pydantic peuvent contenir d'autres mod√®les :

```python
class Adresse(BaseModel):
    rue: str
    ville: str
    code_postal: str

class Utilisateur(BaseModel):
    nom: str
    age: int
    email: EmailStr
    adresse: Adresse  # Mod√®le imbriqu√© !
```

**Exemple de donn√©es :**
```json
{
  "nom": "Alice",
  "age": 25,
  "email": "alice@example.com",
  "adresse": {
    "rue": "123 rue de la Paix",
    "ville": "Paris",
    "code_postal": "75001"
  }
}
```

## Listes et mod√®les

Vous pouvez avoir des listes d'objets :

```python
from typing import List

class Tag(BaseModel):
    nom: str

class Article(BaseModel):
    titre: str
    contenu: str
    tags: List[Tag]  # Liste de tags
```

**Exemple de donn√©es :**
```json
{
  "titre": "Mon article",
  "contenu": "Contenu...",
  "tags": [
    {"nom": "python"},
    {"nom": "fastapi"},
    {"nom": "tutorial"}
  ]
}
```

Ou simplement une liste de cha√Ænes :

```python
class Article(BaseModel):
    titre: str
    contenu: str
    tags: List[str]  # Liste de cha√Ænes simples
```

**Exemple de donn√©es :**
```json
{
  "titre": "Mon article",
  "contenu": "Contenu...",
  "tags": ["python", "fastapi", "tutorial"]
}
```

## Validation personnalis√©e avec validators

Pour des validations complexes, vous pouvez cr√©er des validateurs personnalis√©s :

```python
from pydantic import BaseModel, validator

class Utilisateur(BaseModel):
    nom: str
    age: int
    mot_de_passe: str

    @validator('nom')
    def nom_doit_contenir_espace(cls, v):
        if ' ' not in v:
            raise ValueError('Le nom doit contenir un espace (pr√©nom et nom)')
        return v

    @validator('mot_de_passe')
    def mot_de_passe_fort(cls, v):
        if len(v) < 8:
            raise ValueError('Le mot de passe doit contenir au moins 8 caract√®res')
        if not any(char.isdigit() for char in v):
            raise ValueError('Le mot de passe doit contenir au moins un chiffre')
        return v
```

Le d√©corateur `@validator` vous permet de d√©finir des r√®gles personnalis√©es pour chaque champ.

## Mod√®les de r√©ponse

Vous pouvez √©galement d√©finir le format des r√©ponses de votre API :

```python
class UtilisateurEntree(BaseModel):
    nom: str
    age: int
    email: EmailStr
    mot_de_passe: str

class UtilisateurSortie(BaseModel):
    id: int
    nom: str
    age: int
    email: EmailStr
    # Pas de mot_de_passe dans la sortie !

@app.post("/utilisateurs", response_model=UtilisateurSortie)
def creer_utilisateur(utilisateur: UtilisateurEntree):
    # Simuler la cr√©ation avec un ID
    return {
        "id": 1,
        "nom": utilisateur.nom,
        "age": utilisateur.age,
        "email": utilisateur.email,
        "mot_de_passe": utilisateur.mot_de_passe  # Sera exclu de la r√©ponse !
    }
```

Avec `response_model=UtilisateurSortie`, FastAPI :
1. Valide que la r√©ponse correspond au mod√®le
2. Filtre automatiquement les champs non pr√©sents dans le mod√®le (comme le mot de passe)
3. G√©n√®re la documentation correcte

## Gestion des erreurs de validation

Quand Pydantic d√©tecte une erreur de validation, FastAPI renvoie automatiquement une r√©ponse HTTP 422 (Unprocessable Entity) avec des d√©tails sur l'erreur.

### Exemple d'erreur de validation

Si vous envoyez :
```json
{
  "nom": "A",
  "age": -5,
  "email": "pas-un-email"
}
```

Avec ce mod√®le :
```python
class Utilisateur(BaseModel):
    nom: str = Field(..., min_length=2)
    age: int = Field(..., ge=0)
    email: EmailStr
```

FastAPI renverra :
```json
{
  "detail": [
    {
      "loc": ["body", "nom"],
      "msg": "ensure this value has at least 2 characters",
      "type": "value_error.any_str.min_length"
    },
    {
      "loc": ["body", "age"],
      "msg": "ensure this value is greater than or equal to 0",
      "type": "value_error.number.not_ge"
    },
    {
      "loc": ["body", "email"],
      "msg": "value is not a valid email address",
      "type": "value_error.email"
    }
  ]
}
```

Chaque erreur indique :
- `loc` : L'emplacement du champ erron√©
- `msg` : Le message d'erreur
- `type` : Le type d'erreur

## Param√®tres de requ√™te avec validation

Les param√®tres de requ√™te peuvent aussi b√©n√©ficier de la validation Pydantic :

```python
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/recherche")
def rechercher(
    q: str = Query(..., min_length=3, max_length=50),
    limite: int = Query(10, ge=1, le=100),
    page: int = Query(1, ge=1)
):
    return {
        "requete": q,
        "limite": limite,
        "page": page
    }
```

Avec `Query`, vous pouvez :
- D√©finir des valeurs par d√©faut
- Ajouter des contraintes de validation
- Rendre des param√®tres obligatoires avec `...`
- Ajouter des descriptions

### Param√®tres de requ√™te optionnels

```python
from typing import Optional

@app.get("/recherche")
def rechercher(
    q: Optional[str] = None,
    categorie: Optional[str] = None,
    limite: int = 10
):
    resultats = {"limite": limite}
    if q:
        resultats["requete"] = q
    if categorie:
        resultats["categorie"] = categorie
    return resultats
```

## Param√®tres de chemin avec validation

De m√™me pour les param√®tres de chemin :

```python
from fastapi import Path

@app.get("/utilisateurs/{utilisateur_id}")
def lire_utilisateur(
    utilisateur_id: int = Path(..., ge=1, description="L'ID de l'utilisateur")
):
    return {"utilisateur_id": utilisateur_id}
```

## Exemple complet : API de gestion d'articles

Voici un exemple complet qui combine tout ce que nous avons vu :

```python
from fastapi import FastAPI, HTTPException, Query, Path
from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional
from datetime import datetime

app = FastAPI(
    title="API de Blog",
    description="Une API pour g√©rer un blog",
    version="1.0.0"
)

# Mod√®les Pydantic
class Auteur(BaseModel):
    nom: str = Field(..., min_length=2, max_length=100)
    email: EmailStr

class ArticleBase(BaseModel):
    titre: str = Field(..., min_length=5, max_length=200)
    contenu: str = Field(..., min_length=10)
    tags: List[str] = []
    publie: bool = False

class ArticleCreation(ArticleBase):
    auteur: Auteur

class Article(ArticleBase):
    id: int
    auteur: Auteur
    date_creation: datetime
    vues: int = 0

# Simulation d'une base de donn√©es
articles_db = []
prochain_id = 1

# Routes
@app.get("/")
def lire_racine():
    return {"message": "Bienvenue sur l'API de Blog"}

@app.post("/articles", response_model=Article, status_code=201)
def creer_article(article: ArticleCreation):
    """Cr√©er un nouvel article"""
    global prochain_id

    nouvel_article = {
        "id": prochain_id,
        "titre": article.titre,
        "contenu": article.contenu,
        "tags": article.tags,
        "publie": article.publie,
        "auteur": article.auteur.dict(),
        "date_creation": datetime.now(),
        "vues": 0
    }

    articles_db.append(nouvel_article)
    prochain_id += 1

    return nouvel_article

@app.get("/articles", response_model=List[Article])
def lire_articles(
    publies_seulement: bool = Query(False, description="Afficher uniquement les articles publi√©s"),
    limite: int = Query(10, ge=1, le=100, description="Nombre d'articles √† retourner"),
    tag: Optional[str] = Query(None, description="Filtrer par tag")
):
    """R√©cup√©rer la liste des articles"""
    resultats = articles_db.copy()

    # Filtrer par statut de publication
    if publies_seulement:
        resultats = [a for a in resultats if a["publie"]]

    # Filtrer par tag
    if tag:
        resultats = [a for a in resultats if tag in a["tags"]]

    # Limiter les r√©sultats
    return resultats[:limite]

@app.get("/articles/{article_id}", response_model=Article)
def lire_article(
    article_id: int = Path(..., ge=1, description="L'ID de l'article")
):
    """R√©cup√©rer un article sp√©cifique"""
    for article in articles_db:
        if article["id"] == article_id:
            # Incr√©menter le nombre de vues
            article["vues"] += 1
            return article

    # Article non trouv√©
    raise HTTPException(status_code=404, detail="Article non trouv√©")

@app.put("/articles/{article_id}", response_model=Article)
def modifier_article(
    article_id: int,
    article_modifie: ArticleCreation
):
    """Modifier un article existant"""
    for index, article in enumerate(articles_db):
        if article["id"] == article_id:
            # Conserver certaines informations
            articles_db[index] = {
                "id": article_id,
                "titre": article_modifie.titre,
                "contenu": article_modifie.contenu,
                "tags": article_modifie.tags,
                "publie": article_modifie.publie,
                "auteur": article_modifie.auteur.dict(),
                "date_creation": article["date_creation"],  # Conserver la date originale
                "vues": article["vues"]  # Conserver les vues
            }
            return articles_db[index]

    raise HTTPException(status_code=404, detail="Article non trouv√©")

@app.delete("/articles/{article_id}")
def supprimer_article(article_id: int):
    """Supprimer un article"""
    for index, article in enumerate(articles_db):
        if article["id"] == article_id:
            articles_db.pop(index)
            return {"message": f"Article {article_id} supprim√© avec succ√®s"}

    raise HTTPException(status_code=404, detail="Article non trouv√©")

@app.get("/articles/{article_id}/statistiques")
def statistiques_article(article_id: int):
    """Obtenir les statistiques d'un article"""
    for article in articles_db:
        if article["id"] == article_id:
            return {
                "article_id": article_id,
                "titre": article["titre"],
                "vues": article["vues"],
                "nombre_tags": len(article["tags"]),
                "publie": article["publie"]
            }

    raise HTTPException(status_code=404, detail="Article non trouv√©")
```

### Tester l'API compl√®te

Lancez le serveur et allez sur `http://127.0.0.1:8000/docs`. Vous pouvez :

1. **Cr√©er un article** avec POST `/articles` :
```json
{
  "titre": "Introduction √† FastAPI",
  "contenu": "FastAPI est un framework moderne...",
  "tags": ["python", "fastapi", "api"],
  "publie": true,
  "auteur": {
    "nom": "Alice Dupont",
    "email": "alice@example.com"
  }
}
```

2. **Lire tous les articles** avec GET `/articles`

3. **Lire un article sp√©cifique** avec GET `/articles/1`

4. **Modifier un article** avec PUT `/articles/1`

5. **Supprimer un article** avec DELETE `/articles/1`

## Config et comportements avanc√©s

### Exemples de donn√©es dans la documentation

Vous pouvez fournir des exemples qui appara√Ætront dans la documentation :

```python
class Utilisateur(BaseModel):
    nom: str
    age: int
    email: EmailStr

    class Config:
        schema_extra = {
            "example": {
                "nom": "Alice Dupont",
                "age": 25,
                "email": "alice@example.com"
            }
        }
```

### Alias pour les noms de champs

Parfois, les noms de champs doivent diff√©rer entre Python et JSON :

```python
from pydantic import Field

class Article(BaseModel):
    titre: str
    nombre_vues: int = Field(..., alias="nombreVues")
```

Maintenant, le JSON utilisera `nombreVues` mais votre code Python utilisera `nombre_vues`.

## Bonnes pratiques avec Pydantic

### 1. S√©parez les mod√®les d'entr√©e et de sortie

```python
class UtilisateurCreation(BaseModel):
    nom: str
    email: EmailStr
    mot_de_passe: str

class UtilisateurReponse(BaseModel):
    id: int
    nom: str
    email: EmailStr
    # Pas de mot_de_passe !
```

### 2. Utilisez des valeurs par d√©faut judicieuses

```python
class Article(BaseModel):
    titre: str
    contenu: str
    publie: bool = False  # Par d√©faut non publi√©
    vues: int = 0         # Par d√©faut 0 vue
```

### 3. Ajoutez des descriptions pour la documentation

```python
class Article(BaseModel):
    titre: str = Field(..., description="Le titre de l'article")
    contenu: str = Field(..., description="Le contenu complet")
```

### 4. Validez d√®s l'entr√©e

Ne laissez pas passer de donn√©es invalides. Utilisez les contraintes de validation.

### 5. Organisez vos mod√®les

Pour les gros projets, cr√©ez un fichier s√©par√© `models.py` pour vos mod√®les Pydantic.

## R√©capitulatif

Dans cette section, vous avez appris :

‚úÖ Ce qu'est Pydantic et pourquoi il est essentiel
‚úÖ Comment cr√©er des mod√®les avec `BaseModel`
‚úÖ La diff√©rence entre param√®tres de chemin, de requ√™te et de corps
‚úÖ Comment valider automatiquement les donn√©es avec des contraintes
‚úÖ Les types sp√©ciaux comme `EmailStr`, `HttpUrl`
‚úÖ Comment cr√©er des mod√®les imbriqu√©s et des listes
‚úÖ Comment utiliser des validateurs personnalis√©s
‚úÖ Comment d√©finir des mod√®les de r√©ponse
‚úÖ Comment g√©rer les erreurs de validation
‚úÖ Les bonnes pratiques pour structurer vos mod√®les

Avec Pydantic et FastAPI, vous disposez d'un syst√®me de validation de donn√©es extr√™mement puissant qui rend votre API robuste et fiable, tout en g√©n√©rant automatiquement une documentation claire et interactive !

---


‚è≠Ô∏è [Endpoints asynchrones et performances](/11-developpement-web-et-apis/02.3-endpoints-asynchrones.md)
