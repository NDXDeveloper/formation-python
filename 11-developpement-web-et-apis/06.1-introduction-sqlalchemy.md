üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.6.1 Introduction √† SQLAlchemy

## Qu'est-ce que SQLAlchemy ?

SQLAlchemy est une biblioth√®que Python qui facilite l'interaction avec les bases de donn√©es relationnelles. C'est ce qu'on appelle un **ORM** (Object-Relational Mapping), c'est-√†-dire un outil qui permet de manipuler des donn√©es de base de donn√©es comme si c'√©tait des objets Python.

### Pourquoi utiliser SQLAlchemy ?

Sans SQLAlchemy, pour interagir avec une base de donn√©es, vous devriez √©crire du code SQL brut :

```python
# Sans SQLAlchemy (SQL brut)
cursor.execute("SELECT * FROM users WHERE age > 18")
results = cursor.fetchall()
```

Avec SQLAlchemy, vous manipulez des objets Python naturellement :

```python
# Avec SQLAlchemy (ORM)
users = session.query(User).filter(User.age > 18).all()
```

**Avantages principaux :**
- Code Python plus lisible et maintenable
- Protection contre les injections SQL
- Compatibilit√© avec plusieurs bases de donn√©es (SQLite, PostgreSQL, MySQL, etc.)
- Validation automatique des donn√©es
- Gestion simplifi√©e des relations entre tables

## Installation

Pour installer SQLAlchemy, utilisez pip :

```bash
pip install sqlalchemy
```

Pour suivre ce tutoriel avec SQLite (base de donn√©es simple int√©gr√©e √† Python), aucune installation suppl√©mentaire n'est n√©cessaire.

## Les deux fa√ßons d'utiliser SQLAlchemy

SQLAlchemy offre deux approches principales :

1. **SQLAlchemy Core** : Niveau plus bas, proche du SQL mais avec Python
2. **SQLAlchemy ORM** : Niveau plus haut, manipulation d'objets Python

Dans ce tutoriel, nous nous concentrerons sur l'**ORM**, qui est plus intuitif pour les d√©butants.

## Concepts fondamentaux

### Le moteur (Engine)

Le moteur est la connexion √† votre base de donn√©es. C'est le point d'entr√©e de SQLAlchemy.

```python
from sqlalchemy import create_engine

# Cr√©ation d'une connexion √† une base de donn√©es SQLite
# Le fichier 'ma_base.db' sera cr√©√© automatiquement
engine = create_engine('sqlite:///ma_base.db', echo=True)
```

**Param√®tres importants :**
- `echo=True` : Affiche toutes les requ√™tes SQL g√©n√©r√©es (utile pour apprendre)
- `echo=False` : Mode production, n'affiche rien

**Syntaxes de connexion courantes :**
```python
# SQLite (fichier local)
engine = create_engine('sqlite:///ma_base.db')

# SQLite (en m√©moire, pour les tests)
engine = create_engine('sqlite:///:memory:')

# PostgreSQL
engine = create_engine('postgresql://user:password@localhost/ma_base')

# MySQL
engine = create_engine('mysql://user:password@localhost/ma_base')
```

### La session

La session est votre espace de travail pour interagir avec la base de donn√©es. C'est comme un "panier" o√π vous placez vos modifications avant de les enregistrer d√©finitivement.

```python
from sqlalchemy.orm import sessionmaker

# Cr√©ation d'une classe Session li√©e √† notre moteur
Session = sessionmaker(bind=engine)

# Cr√©ation d'une instance de session
session = Session()
```

**Concept important :** La session garde en m√©moire vos changements et les envoie √† la base de donn√©es uniquement quand vous le d√©cidez (avec `commit()`).

### Le mod√®le d√©claratif (Base)

Pour d√©finir nos tables, nous utilisons le syst√®me d√©claratif de SQLAlchemy. Toutes nos classes de mod√®les h√©riteront d'une classe de base commune.

```python
from sqlalchemy.orm import declarative_base

# Cr√©ation de la classe de base
Base = declarative_base()
```

## Premier exemple complet

Cr√©ons un mod√®le simple pour une table `User` :

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base, sessionmaker

# Configuration de base
Base = declarative_base()
engine = create_engine('sqlite:///users.db', echo=True)
Session = sessionmaker(bind=engine)
session = Session()

# D√©finition du mod√®le User
class User(Base):
    __tablename__ = 'users'  # Nom de la table dans la base de donn√©es

    # D√©finition des colonnes
    id = Column(Integer, primary_key=True)  # Cl√© primaire auto-incr√©ment√©e
    nom = Column(String(50), nullable=False)  # Cha√Æne de 50 caract√®res max, obligatoire
    email = Column(String(100), unique=True)  # Email unique
    age = Column(Integer)

    def __repr__(self):
        # M√©thode pour afficher l'objet de mani√®re lisible
        return f"<User(nom='{self.nom}', email='{self.email}', age={self.age})>"

# Cr√©ation des tables dans la base de donn√©es
Base.metadata.create_all(engine)
```

**Explication d√©taill√©e :**

- `__tablename__` : Nom de la table en base de donn√©es
- `Column` : D√©finit une colonne avec son type et ses contraintes
- `primary_key=True` : Identifiant unique de chaque ligne
- `nullable=False` : Le champ est obligatoire
- `unique=True` : Chaque valeur doit √™tre unique dans la table
- `__repr__` : M√©thode sp√©ciale pour afficher l'objet de fa√ßon lisible

## Types de colonnes courants

SQLAlchemy offre de nombreux types de colonnes :

```python
from sqlalchemy import Integer, String, Float, Boolean, DateTime, Text

class Exemple(Base):
    __tablename__ = 'exemples'

    id = Column(Integer, primary_key=True)
    nom = Column(String(100))           # Texte court (limite de caract√®res)
    description = Column(Text)           # Texte long (sans limite)
    prix = Column(Float)                 # Nombre d√©cimal
    en_stock = Column(Boolean)           # True/False
    date_creation = Column(DateTime)     # Date et heure
```

## Cr√©er des enregistrements

Pour ajouter des donn√©es dans la base :

```python
# Cr√©ation d'un nouvel utilisateur
nouveau_user = User(nom="Alice Dupont", email="alice@example.com", age=28)

# Ajout √† la session (pr√©paration)
session.add(nouveau_user)

# Envoi √† la base de donn√©es (sauvegarde d√©finitive)
session.commit()

print(f"Utilisateur cr√©√© avec l'ID : {nouveau_user.id}")
```

**√âtapes importantes :**
1. Cr√©er un objet Python
2. L'ajouter √† la session avec `add()`
3. Confirmer avec `commit()`

Pour ajouter plusieurs enregistrements en une fois :

```python
users = [
    User(nom="Bob Martin", email="bob@example.com", age=35),
    User(nom="Claire Petit", email="claire@example.com", age=42),
    User(nom="David Leroux", email="david@example.com", age=29)
]

session.add_all(users)
session.commit()
```

## Lire des donn√©es (Requ√™tes simples)

### R√©cup√©rer tous les enregistrements

```python
# R√©cup√©rer tous les utilisateurs
tous_les_users = session.query(User).all()

for user in tous_les_users:
    print(user)
```

### R√©cup√©rer un enregistrement par ID

```python
# R√©cup√©rer l'utilisateur avec l'ID 1
user = session.query(User).get(1)
print(user)
```

### Filtrer les r√©sultats

```python
# Utilisateurs de plus de 30 ans
users_30_plus = session.query(User).filter(User.age > 30).all()

# Utilisateur avec un email sp√©cifique
user = session.query(User).filter(User.email == "alice@example.com").first()
# .first() retourne le premier r√©sultat (ou None si aucun)
```

### Compter les enregistrements

```python
# Nombre total d'utilisateurs
nombre_users = session.query(User).count()
print(f"Nombre d'utilisateurs : {nombre_users}")
```

## Mettre √† jour des donn√©es

```python
# R√©cup√©rer un utilisateur
user = session.query(User).filter(User.nom == "Alice Dupont").first()

# Modifier ses attributs
user.age = 29
user.email = "alice.dupont@example.com"

# Sauvegarder les changements
session.commit()
```

SQLAlchemy d√©tecte automatiquement les modifications et g√©n√®re la requ√™te SQL UPDATE appropri√©e.

## Supprimer des donn√©es

```python
# R√©cup√©rer un utilisateur
user = session.query(User).filter(User.nom == "Bob Martin").first()

# Supprimer de la session
session.delete(user)

# Confirmer la suppression
session.commit()
```

## Gestion des transactions

Les transactions permettent de regrouper plusieurs op√©rations et de les annuler en cas d'erreur :

```python
try:
    # Plusieurs op√©rations
    user1 = User(nom="Test1", email="test1@example.com", age=25)
    user2 = User(nom="Test2", email="test2@example.com", age=30)

    session.add(user1)
    session.add(user2)

    # Si tout se passe bien, on enregistre
    session.commit()

except Exception as e:
    # En cas d'erreur, on annule tout
    session.rollback()
    print(f"Erreur : {e}")

finally:
    # Fermeture de la session
    session.close()
```

**Concepts cl√©s :**
- `commit()` : Valide toutes les modifications
- `rollback()` : Annule toutes les modifications depuis le dernier commit
- `close()` : Ferme la session

## Bonnes pratiques

### 1. Utiliser un context manager

Au lieu de g√©rer manuellement l'ouverture/fermeture des sessions :

```python
from contextlib import contextmanager

@contextmanager
def get_session():
    session = Session()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()

# Utilisation
with get_session() as session:
    user = User(nom="Exemple", email="exemple@example.com", age=25)
    session.add(user)
# La session est automatiquement ferm√©e et committ√©e
```

### 2. Valider les donn√©es avant insertion

```python
def creer_utilisateur(nom, email, age):
    # Validations
    if not nom or len(nom) < 2:
        raise ValueError("Le nom doit contenir au moins 2 caract√®res")

    if age < 0 or age > 150:
        raise ValueError("L'√¢ge doit √™tre entre 0 et 150")

    # Cr√©ation
    user = User(nom=nom, email=email, age=age)
    session.add(user)
    session.commit()
    return user
```

### 3. √âviter les requ√™tes N+1

Quand vous travaillez avec des relations entre tables (que nous verrons dans le prochain chapitre), faites attention aux requ√™tes r√©p√©t√©es. SQLAlchemy offre des m√©canismes d'optimisation comme le "eager loading".

## Exemple complet d'application

Voici un exemple complet qui met tout ensemble :

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base, sessionmaker

# Configuration
Base = declarative_base()
engine = create_engine('sqlite:///gestion_users.db', echo=False)
Session = sessionmaker(bind=engine)

# Mod√®le
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    nom = Column(String(50), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    age = Column(Integer)

    def __repr__(self):
        return f"<User(id={self.id}, nom='{self.nom}', email='{self.email}')>"

# Cr√©ation des tables
Base.metadata.create_all(engine)

# Fonction pour ajouter un utilisateur
def ajouter_utilisateur(nom, email, age):
    session = Session()
    try:
        user = User(nom=nom, email=email, age=age)
        session.add(user)
        session.commit()
        print(f"‚úì Utilisateur {nom} ajout√© avec succ√®s!")
        return user
    except Exception as e:
        session.rollback()
        print(f"‚úó Erreur : {e}")
    finally:
        session.close()

# Fonction pour lister tous les utilisateurs
def lister_utilisateurs():
    session = Session()
    try:
        users = session.query(User).all()
        if users:
            print("\n=== Liste des utilisateurs ===")
            for user in users:
                print(f"- {user.nom} ({user.email}) - {user.age} ans")
        else:
            print("Aucun utilisateur trouv√©.")
    finally:
        session.close()

# Fonction pour rechercher un utilisateur par email
def rechercher_par_email(email):
    session = Session()
    try:
        user = session.query(User).filter(User.email == email).first()
        if user:
            print(f"Utilisateur trouv√© : {user}")
        else:
            print(f"Aucun utilisateur avec l'email {email}")
        return user
    finally:
        session.close()

# Utilisation
if __name__ == "__main__":
    # Ajout d'utilisateurs
    ajouter_utilisateur("Marie Curie", "marie@science.com", 45)
    ajouter_utilisateur("Albert Einstein", "albert@physics.com", 76)
    ajouter_utilisateur("Ada Lovelace", "ada@coding.com", 36)

    # Liste
    lister_utilisateurs()

    # Recherche
    rechercher_par_email("marie@science.com")
```

## R√©sum√© des points cl√©s

**Configuration de base :**
1. Cr√©er un `engine` (connexion √† la base)
2. Cr√©er une `Session` (espace de travail)
3. D√©finir une `Base` (classe parente des mod√®les)

**D√©finition d'un mod√®le :**
- H√©riter de `Base`
- D√©finir `__tablename__`
- Cr√©er des colonnes avec `Column()`
- Sp√©cifier les types et contraintes

**Op√©rations CRUD :**
- **Create** : `session.add()` puis `session.commit()`
- **Read** : `session.query().filter().all()` ou `.first()`
- **Update** : Modifier l'objet puis `session.commit()`
- **Delete** : `session.delete()` puis `session.commit()`

**S√©curit√© :**
- Toujours utiliser `try/except` avec `rollback()`
- Fermer les sessions avec `close()`
- SQLAlchemy prot√®ge automatiquement contre les injections SQL

## Prochaines √©tapes

Maintenant que vous ma√Ætrisez les bases de SQLAlchemy, vous √™tes pr√™t √† explorer :
- Les relations entre tables (One-to-Many, Many-to-Many)
- Les requ√™tes plus complexes (jointures, agr√©gations)
- Les migrations de base de donn√©es
- L'int√©gration avec des frameworks web (FastAPI, Flask)

SQLAlchemy est un outil puissant qui simplifie grandement le travail avec les bases de donn√©es. Avec ces fondamentaux, vous pouvez d√©j√† cr√©er des applications qui persistent des donn√©es de mani√®re fiable et maintenable.

‚è≠Ô∏è [Mod√®les et relations](/11-developpement-web-et-apis/06.2-modeles-et-relations.md)
