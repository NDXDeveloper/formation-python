# Exercice 1.4.3 : Gestionnaire de mots de passe

## Objectif

Cr√©er un syst√®me de g√©n√©ration et validation de mots de passe pour comprendre les fonctions bool√©ennes, la manipulation de cha√Ænes et la logique conditionnelle.

## Cahier des charges

1. **generer_mot_de_passe(longueur)** ‚Üí g√©n√®re un mot de passe al√©atoire
2. **verifier_force(mot_de_passe)** ‚Üí √©value la force du mot de passe
3. **contient_majuscule(texte)** ‚Üí v√©rifie la pr√©sence de majuscules
4. **contient_chiffre(texte)** ‚Üí v√©rifie la pr√©sence de chiffres
5. **contient_caractere_special(texte)** ‚Üí v√©rifie les caract√®res sp√©ciaux
6. **Programme principal** qui utilise toutes ces fonctions

## Code de base √† compl√©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 1.4.3 : Gestionnaire de mots de passe
Module 1.4 - Fonctions et port√©e des variables
"""

import random

# Ensembles de caract√®res globaux
MINUSCULES = "abcdefghijklmnopqrstuvwxyz"
MAJUSCULES = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
CHIFFRES = "0123456789"
CARACTERES_SPECIAUX = "!@#$%^&*()_+-=[]{}|;:,.<>?"

def generer_mot_de_passe(longueur):
    """
    G√©n√®re un mot de passe al√©atoire.

    Args:
        longueur (int): Longueur souhait√©e du mot de passe

    Returns:
        str: Mot de passe g√©n√©r√©
    """
    # TODO: Impl√©menter la fonction
    pass

def contient_majuscule(texte):
    """
    V√©rifie si le texte contient au moins une majuscule.

    Args:
        texte (str): Texte √† v√©rifier

    Returns:
        bool: True si contient une majuscule, False sinon
    """
    # TODO: Impl√©menter la fonction
    pass

def contient_chiffre(texte):
    """
    V√©rifie si le texte contient au moins un chiffre.

    Args:
        texte (str): Texte √† v√©rifier

    Returns:
        bool: True si contient un chiffre, False sinon
    """
    # TODO: Impl√©menter la fonction
    pass

def contient_caractere_special(texte):
    """
    V√©rifie si le texte contient au moins un caract√®re sp√©cial.

    Args:
        texte (str): Texte √† v√©rifier

    Returns:
        bool: True si contient un caract√®re sp√©cial, False sinon
    """
    # TODO: Impl√©menter la fonction
    pass

def verifier_force(mot_de_passe):
    """
    √âvalue la force d'un mot de passe.

    Args:
        mot_de_passe (str): Mot de passe √† √©valuer

    Returns:
        str: Niveau de force ("Faible", "Moyen", "Fort", "Tr√®s fort")
    """
    # TODO: Impl√©menter la fonction
    pass

def main():
    """Programme principal du gestionnaire de mots de passe."""
    print("üîê === GESTIONNAIRE DE MOTS DE PASSE ===")

    while True:
        # TODO: Cr√©er le menu interactif
        pass

if __name__ == "__main__":
    main()
```

## Solution compl√®te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 1.4.3 : Gestionnaire de mots de passe - SOLUTION
Module 1.4 - Fonctions et port√©e des variables
"""

import random

# Ensembles de caract√®res globaux
MINUSCULES = "abcdefghijklmnopqrstuvwxyz"
MAJUSCULES = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
CHIFFRES = "0123456789"
CARACTERES_SPECIAUX = "!@#$%^&*()_+-=[]{}|;:,.<>?"

def generer_mot_de_passe(longueur):
    """
    G√©n√®re un mot de passe al√©atoire.

    Args:
        longueur (int): Longueur souhait√©e du mot de passe

    Returns:
        str: Mot de passe g√©n√©r√©

    Example:
        >>> len(generer_mot_de_passe(12))
        12
    """
    if longueur < 1:
        return ""

    # Combiner tous les caract√®res possibles
    tous_caracteres = MINUSCULES + MAJUSCULES + CHIFFRES + CARACTERES_SPECIAUX

    # G√©n√©rer le mot de passe
    mot_de_passe = ""
    for _ in range(longueur):
        mot_de_passe += random.choice(tous_caracteres)

    return mot_de_passe

def generer_mot_de_passe_equilibre(longueur):
    """
    G√©n√®re un mot de passe √©quilibr√© avec au moins un caract√®re de chaque type.

    Args:
        longueur (int): Longueur souhait√©e du mot de passe (minimum 4)

    Returns:
        str: Mot de passe g√©n√©r√© √©quilibr√©
    """
    if longueur < 4:
        return generer_mot_de_passe(longueur)

    mot_de_passe = []

    # Garantir au moins un caract√®re de chaque type
    mot_de_passe.append(random.choice(MINUSCULES))
    mot_de_passe.append(random.choice(MAJUSCULES))
    mot_de_passe.append(random.choice(CHIFFRES))
    mot_de_passe.append(random.choice(CARACTERES_SPECIAUX))

    # Compl√©ter avec des caract√®res al√©atoires
    tous_caracteres = MINUSCULES + MAJUSCULES + CHIFFRES + CARACTERES_SPECIAUX
    for _ in range(longueur - 4):
        mot_de_passe.append(random.choice(tous_caracteres))

    # M√©langer pour √©viter un pattern pr√©visible
    random.shuffle(mot_de_passe)

    return "".join(mot_de_passe)

def contient_majuscule(texte):
    """
    V√©rifie si le texte contient au moins une majuscule.

    Args:
        texte (str): Texte √† v√©rifier

    Returns:
        bool: True si contient une majuscule, False sinon

    Example:
        >>> contient_majuscule("Hello")
        True
        >>> contient_majuscule("hello")
        False
    """
    for caractere in texte:
        if caractere in MAJUSCULES:
            return True
    return False

def contient_chiffre(texte):
    """
    V√©rifie si le texte contient au moins un chiffre.

    Args:
        texte (str): Texte √† v√©rifier

    Returns:
        bool: True si contient un chiffre, False sinon

    Example:
        >>> contient_chiffre("abc123")
        True
        >>> contient_chiffre("abcdef")
        False
    """
    for caractere in texte:
        if caractere in CHIFFRES:
            return True
    return False

def contient_caractere_special(texte):
    """
    V√©rifie si le texte contient au moins un caract√®re sp√©cial.

    Args:
        texte (str): Texte √† v√©rifier

    Returns:
        bool: True si contient un caract√®re sp√©cial, False sinon

    Example:
        >>> contient_caractere_special("abc@123")
        True
        >>> contient_caractere_special("abc123")
        False
    """
    for caractere in texte:
        if caractere in CARACTERES_SPECIAUX:
            return True
    return False

def contient_minuscule(texte):
    """
    V√©rifie si le texte contient au moins une minuscule.

    Args:
        texte (str): Texte √† v√©rifier

    Returns:
        bool: True si contient une minuscule, False sinon
    """
    for caractere in texte:
        if caractere in MINUSCULES:
            return True
    return False

def calculer_score_complexite(mot_de_passe):
    """
    Calcule un score de complexit√© pour le mot de passe.

    Args:
        mot_de_passe (str): Mot de passe √† √©valuer

    Returns:
        int: Score de complexit√© (0-100)
    """
    score = 0
    longueur = len(mot_de_passe)

    # Points pour la longueur
    if longueur >= 8:
        score += 25
    elif longueur >= 6:
        score += 15
    elif longueur >= 4:
        score += 5

    # Points pour les types de caract√®res
    if contient_minuscule(mot_de_passe):
        score += 15

    if contient_majuscule(mot_de_passe):
        score += 15

    if contient_chiffre(mot_de_passe):
        score += 15

    if contient_caractere_special(mot_de_passe):
        score += 20

    # Bonus pour la longueur sup√©rieure
    if longueur >= 12:
        score += 10
    elif longueur >= 10:
        score += 5

    return min(score, 100)  # Maximum 100

def verifier_force(mot_de_passe):
    """
    √âvalue la force d'un mot de passe.

    Args:
        mot_de_passe (str): Mot de passe √† √©valuer

    Returns:
        str: Niveau de force ("Faible", "Moyen", "Fort", "Tr√®s fort")

    Example:
        >>> verifier_force("123")
        'Faible'
        >>> verifier_force("MonMotDePasse123!")
        'Tr√®s fort'
    """
    if len(mot_de_passe) < 4:
        return "Tr√®s faible"

    score = calculer_score_complexite(mot_de_passe)

    if score >= 80:
        return "Tr√®s fort"
    elif score >= 60:
        return "Fort"
    elif score >= 40:
        return "Moyen"
    elif score >= 20:
        return "Faible"
    else:
        return "Tr√®s faible"

def analyser_mot_de_passe(mot_de_passe):
    """
    Analyse compl√®te d'un mot de passe.

    Args:
        mot_de_passe (str): Mot de passe √† analyser

    Returns:
        dict: Dictionnaire avec les r√©sultats de l'analyse
    """
    analyse = {
        'longueur': len(mot_de_passe),
        'force': verifier_force(mot_de_passe),
        'score': calculer_score_complexite(mot_de_passe),
        'contient_minuscule': contient_minuscule(mot_de_passe),
        'contient_majuscule': contient_majuscule(mot_de_passe),
        'contient_chiffre': contient_chiffre(mot_de_passe),
        'contient_caractere_special': contient_caractere_special(mot_de_passe),
        'recommendations': []
    }

    # G√©n√©rer des recommandations
    if analyse['longueur'] < 8:
        analyse['recommendations'].append("Utilisez au moins 8 caract√®res")

    if not analyse['contient_minuscule']:
        analyse['recommendations'].append("Ajoutez des lettres minuscules")

    if not analyse['contient_majuscule']:
        analyse['recommendations'].append("Ajoutez des lettres majuscules")

    if not analyse['contient_chiffre']:
        analyse['recommendations'].append("Ajoutez des chiffres")

    if not analyse['contient_caractere_special']:
        analyse['recommendations'].append("Ajoutez des caract√®res sp√©ciaux (!@#$...)")

    if analyse['longueur'] < 12:
        analyse['recommendations'].append("Pr√©f√©rez 12 caract√®res ou plus pour plus de s√©curit√©")

    return analyse

def afficher_analyse(analyse, mot_de_passe):
    """
    Affiche l'analyse d'un mot de passe de fa√ßon format√©e.

    Args:
        analyse (dict): R√©sultats de l'analyse
        mot_de_passe (str): Mot de passe analys√©
    """
    print(f"\nüîç === ANALYSE DU MOT DE PASSE ===")
    print(f"Mot de passe : {'*' * len(mot_de_passe)} ({len(mot_de_passe)} caract√®res)")

    # Affichage de la force avec emoji
    force_emojis = {
        "Tr√®s faible": "üî¥",
        "Faible": "üü†",
        "Moyen": "üü°",
        "Fort": "üü¢",
        "Tr√®s fort": "üíö"
    }

    emoji = force_emojis.get(analyse['force'], "‚ö™")
    print(f"Force : {emoji} {analyse['force']} (Score: {analyse['score']}/100)")

    # Crit√®res de s√©curit√©
    print(f"\nüìã Crit√®res de s√©curit√© :")
    criteres = [
        ("Longueur ‚â• 8 caract√®res", analyse['longueur'] >= 8),
        ("Contient des minuscules", analyse['contient_minuscule']),
        ("Contient des majuscules", analyse['contient_majuscule']),
        ("Contient des chiffres", analyse['contient_chiffre']),
        ("Contient des caract√®res sp√©ciaux", analyse['contient_caractere_special'])
    ]

    for critere, valide in criteres:
        status = "‚úÖ" if valide else "‚ùå"
        print(f"   {status} {critere}")

    # Recommandations
    if analyse['recommendations']:
        print(f"\nüí° Recommandations :")
        for rec in analyse['recommendations']:
            print(f"   ‚Ä¢ {rec}")
    else:
        print(f"\nüéâ Excellent ! Votre mot de passe respecte tous les crit√®res de s√©curit√©.")

def tester_mots_de_passe():
    """Teste plusieurs mots de passe avec diff√©rents niveaux de s√©curit√©."""
    print(f"\nüß™ === TESTS DE MOTS DE PASSE ===")

    tests = [
        "123",
        "password",
        "Password",
        "Password1",
        "Password1!",
        "MonMotDePasseSecurise123!",
        "P@ssw0rd",
        "x",
        "AbCdEfGh123!@#$"
    ]

    for mdp in tests:
        analyse = analyser_mot_de_passe(mdp)
        force_emoji = {
            "Tr√®s faible": "üî¥", "Faible": "üü†", "Moyen": "üü°",
            "Fort": "üü¢", "Tr√®s fort": "üíö"
        }.get(analyse['force'], "‚ö™")

        print(f"   {force_emoji} '{mdp}' ‚Üí {analyse['force']} ({analyse['score']}/100)")

def generer_plusieurs_mots_de_passe():
    """G√©n√®re plusieurs mots de passe et affiche leurs caract√©ristiques."""
    print(f"\nüé≤ === G√âN√âRATION DE MOTS DE PASSE ===")

    try:
        nombre = int(input("Combien de mots de passe g√©n√©rer ? (1-10) : "))
        if nombre < 1 or nombre > 10:
            print("‚ùå Veuillez entrer un nombre entre 1 et 10")
            return
    except ValueError:
        print("‚ùå Veuillez entrer un nombre valide")
        return

    try:
        longueur = int(input("Longueur souhait√©e (4-50) : "))
        if longueur < 4 or longueur > 50:
            print("‚ùå Veuillez entrer une longueur entre 4 et 50")
            return
    except ValueError:
        print("‚ùå Veuillez entrer un nombre valide")
        return

    type_generation = input("Type de g√©n√©ration (1: Standard, 2: √âquilibr√©) : ").strip()

    print(f"\nüîê G√©n√©ration de {nombre} mot(s) de passe de {longueur} caract√®res :")
    print("‚ïê" * 70)

    for i in range(nombre):
        if type_generation == "2":
            mdp = generer_mot_de_passe_equilibre(longueur)
        else:
            mdp = generer_mot_de_passe(longueur)

        analyse = analyser_mot_de_passe(mdp)
        force_emoji = {
            "Tr√®s faible": "üî¥", "Faible": "üü†", "Moyen": "üü°",
            "Fort": "üü¢", "Tr√®s fort": "üíö"
        }.get(analyse['force'], "‚ö™")

        print(f"{i+1:2d}. {mdp} {force_emoji} {analyse['force']} ({analyse['score']}/100)")

    print("‚ïê" * 70)

def verifier_mot_de_passe_utilisateur():
    """Permet √† l'utilisateur de v√©rifier son propre mot de passe."""
    print(f"\nüîç === V√âRIFICATION DE MOT DE PASSE ===")

    mot_de_passe = input("Entrez votre mot de passe √† analyser : ")

    if not mot_de_passe:
        print("‚ùå Mot de passe vide")
        return

    analyse = analyser_mot_de_passe(mot_de_passe)
    afficher_analyse(analyse, mot_de_passe)

    # Proposition d'am√©lioration
    if analyse['score'] < 80:
        print(f"\nüöÄ Voulez-vous g√©n√©rer un mot de passe plus s√©curis√© ?")
        choix = input("(o/n) : ").lower()
        if choix in ['o', 'oui', 'y', 'yes']:
            longueur = max(12, len(mot_de_passe) + 2)  # Au moins 12, ou plus long que l'actuel
            nouveau_mdp = generer_mot_de_passe_equilibre(longueur)
            nouvelle_analyse = analyser_mot_de_passe(nouveau_mdp)

            print(f"\nüí° Suggestion de mot de passe am√©lior√© :")
            print(f"Nouveau : {nouveau_mdp}")
            afficher_analyse(nouvelle_analyse, nouveau_mdp)

def simuler_attaque_par_force_brute():
    """Simule une estimation du temps d'attaque par force brute."""
    print(f"\n‚ö° === SIMULATION D'ATTAQUE PAR FORCE BRUTE ===")

    mot_de_passe = input("Entrez un mot de passe pour estimer sa r√©sistance : ")

    if not mot_de_passe:
        print("‚ùå Mot de passe vide")
        return

    # Calcul de l'espace des possibilit√©s
    alphabet_size = 0

    if contient_minuscule(mot_de_passe):
        alphabet_size += 26
    if contient_majuscule(mot_de_passe):
        alphabet_size += 26
    if contient_chiffre(mot_de_passe):
        alphabet_size += 10
    if contient_caractere_special(mot_de_passe):
        alphabet_size += len(CARACTERES_SPECIAUX)

    longueur = len(mot_de_passe)
    combinaisons_possibles = alphabet_size ** longueur

    # Estimation du temps (hypoth√®ses simplifi√©es)
    tentatives_par_seconde = 1_000_000_000  # 1 milliard de tentatives/sec (tr√®s optimiste pour l'attaquant)
    temps_max_secondes = combinaisons_possibles / tentatives_par_seconde / 2  # En moyenne, 50% des combinaisons

    print(f"\nüìä Analyse de r√©sistance :")
    print(f"   ‚Ä¢ Longueur : {longueur} caract√®res")
    print(f"   ‚Ä¢ Alphabet utilis√© : {alphabet_size} caract√®res")
    print(f"   ‚Ä¢ Combinaisons possibles : {combinaisons_possibles:,}")
    print(f"   ‚Ä¢ Tentatives par seconde (estim√©) : {tentatives_par_seconde:,}")

    # Conversion en unit√©s de temps lisibles
    if temps_max_secondes < 1:
        print(f"   ‚Ä¢ Temps estim√© pour craquer : Moins d'une seconde ‚ö†Ô∏è")
    elif temps_max_secondes < 60:
        print(f"   ‚Ä¢ Temps estim√© pour craquer : {temps_max_secondes:.1f} secondes ‚ö†Ô∏è")
    elif temps_max_secondes < 3600:
        print(f"   ‚Ä¢ Temps estim√© pour craquer : {temps_max_secondes/60:.1f} minutes ‚ö†Ô∏è")
    elif temps_max_secondes < 86400:
        print(f"   ‚Ä¢ Temps estim√© pour craquer : {temps_max_secondes/3600:.1f} heures ‚ö†Ô∏è")
    elif temps_max_secondes < 31536000:
        print(f"   ‚Ä¢ Temps estim√© pour craquer : {temps_max_secondes/86400:.1f} jours üü°")
    elif temps_max_secondes < 31536000 * 1000:
        print(f"   ‚Ä¢ Temps estim√© pour craquer : {temps_max_secondes/31536000:.1f} ann√©es üü¢")
    else:
        print(f"   ‚Ä¢ Temps estim√© pour craquer : {temps_max_secondes/31536000:.2e} ann√©es üíö")

    print(f"\nüí° Note : Cette estimation est simplifi√©e et ne prend pas en compte :")
    print(f"   ‚Ä¢ Les attaques par dictionnaire")
    print(f"   ‚Ä¢ Les patterns courants")
    print(f"   ‚Ä¢ Les techniques d'optimisation")
    print(f"   ‚Ä¢ Les ressources r√©elles des attaquants")

def conseils_securite():
    """Affiche des conseils de s√©curit√© pour les mots de passe."""
    print(f"\nüí° === CONSEILS DE S√âCURIT√â ===")

    conseils = [
        "üîí Utilisez un mot de passe unique pour chaque compte important",
        "üìè Pr√©f√©rez des mots de passe longs (12+ caract√®res)",
        "üî§ M√©langez majuscules, minuscules, chiffres et symboles",
        "üö´ √âvitez les informations personnelles (nom, date de naissance...)",
        "üö´ √âvitez les mots du dictionnaire et les suites logiques (123, abc...)",
        "üíæ Utilisez un gestionnaire de mots de passe s√©curis√©",
        "üîÑ Changez vos mots de passe importants r√©guli√®rement",
        "üì± Activez l'authentification √† deux facteurs quand possible",
        "ü§ê Ne partagez jamais vos mots de passe",
        "üëÄ V√©rifiez que personne ne vous observe quand vous tapez votre mot de passe"
    ]

    for conseil in conseils:
        print(f"   {conseil}")

    print(f"\nüéØ Techniques pour cr√©er des mots de passe m√©morables :")
    print(f"   ‚Ä¢ Phrase de passe : 'J'aime manger 3 pommes le matin!' ‚Üí JaM3pLm!")
    print(f"   ‚Ä¢ Substitution : 'MonChien' ‚Üí M0nCh1en!")
    print(f"   ‚Ä¢ Acronyme : 'Je me l√®ve √† 7h30 tous les matins' ‚Üí JmlA7h30tlm")

def statistiques_caracteres():
    """Affiche des statistiques sur les ensembles de caract√®res."""
    print(f"\nüìà === STATISTIQUES DES CARACT√àRES ===")

    print(f"Ensembles de caract√®res disponibles :")
    print(f"   ‚Ä¢ Minuscules : {len(MINUSCULES)} caract√®res ({MINUSCULES})")
    print(f"   ‚Ä¢ Majuscules : {len(MAJUSCULES)} caract√®res ({MAJUSCULES})")
    print(f"   ‚Ä¢ Chiffres : {len(CHIFFRES)} caract√®res ({CHIFFRES})")
    print(f"   ‚Ä¢ Sp√©ciaux : {len(CARACTERES_SPECIAUX)} caract√®res ({CARACTERES_SPECIAUX})")
    print(f"   ‚Ä¢ Total : {len(MINUSCULES + MAJUSCULES + CHIFFRES + CARACTERES_SPECIAUX)} caract√®res")

    print(f"\nCombinaisons possibles selon la longueur :")
    alphabet_total = len(MINUSCULES + MAJUSCULES + CHIFFRES + CARACTERES_SPECIAUX)

    for longueur in [4, 6, 8, 10, 12, 16]:
        combinaisons = alphabet_total ** longueur
        print(f"   ‚Ä¢ {longueur} caract√®res : {combinaisons:,} combinaisons")

def main():
    """Programme principal du gestionnaire de mots de passe."""
    print("üîê === GESTIONNAIRE DE MOTS DE PASSE ===")
    print("Outil complet pour g√©n√©rer et analyser des mots de passe s√©curis√©s")

    while True:
        print("\n" + "‚ïê" * 60)
        print("üîê MENU PRINCIPAL".center(60))
        print("‚ïê" * 60)
        print("1. üé≤ G√©n√©rer des mots de passe")
        print("2. üîç Analyser un mot de passe")
        print("3. üß™ Tester des exemples de mots de passe")
        print("4. ‚ö° Simuler une attaque par force brute")
        print("5. üí° Conseils de s√©curit√©")
        print("6. üìà Statistiques des caract√®res")
        print("7. üîß Tester les fonctions individuelles")
        print("8. ‚ùå Quitter")

        choix = input("\nVotre choix (1-8) : ").strip()

        try:
            if choix == "1":
                generer_plusieurs_mots_de_passe()

            elif choix == "2":
                verifier_mot_de_passe_utilisateur()

            elif choix == "3":
                tester_mots_de_passe()

            elif choix == "4":
                simuler_attaque_par_force_brute()

            elif choix == "5":
                conseils_securite()

            elif choix == "6":
                statistiques_caracteres()

            elif choix == "7":
                tester_fonctions_individuelles()

            elif choix == "8":
                print("\nüîí Merci d'avoir utilis√© le gestionnaire de mots de passe !")
                print("Restez vigilant et s√©curis√© ! üõ°Ô∏è")
                break

            else:
                print("‚ùå Choix invalide. Veuillez entrer un nombre entre 1 et 8.")

        except KeyboardInterrupt:
            print(f"\n\n‚èπÔ∏è Programme interrompu par l'utilisateur")
            print("üîí Au revoir et restez s√©curis√© !")
            break

        except Exception as e:
            print(f"‚ùå Erreur inattendue : {e}")
            print("üîÑ Retour au menu principal...")

def tester_fonctions_individuelles():
    """Teste chaque fonction individuellement pour d√©monstration p√©dagogique."""
    print(f"\nüîß === TEST DES FONCTIONS INDIVIDUELLES ===")

    # Test des fonctions de v√©rification
    texte_test = "MonMotDePasse123!"
    print(f"Texte de test : '{texte_test}'")
    print(f"   ‚Ä¢ contient_majuscule() ‚Üí {contient_majuscule(texte_test)}")
    print(f"   ‚Ä¢ contient_minuscule() ‚Üí {contient_minuscule(texte_test)}")
    print(f"   ‚Ä¢ contient_chiffre() ‚Üí {contient_chiffre(texte_test)}")
    print(f"   ‚Ä¢ contient_caractere_special() ‚Üí {contient_caractere_special(texte_test)}")
    print(f"   ‚Ä¢ verifier_force() ‚Üí {verifier_force(texte_test)}")
    print(f"   ‚Ä¢ calculer_score_complexite() ‚Üí {calculer_score_complexite(texte_test)}/100")

    # Test de g√©n√©ration
    print(f"\nTest de g√©n√©ration :")
    mdp_genere = generer_mot_de_passe(8)
    print(f"   ‚Ä¢ generer_mot_de_passe(8) ‚Üí '{mdp_genere}'")

    mdp_equilibre = generer_mot_de_passe_equilibre(12)
    print(f"   ‚Ä¢ generer_mot_de_passe_equilibre(12) ‚Üí '{mdp_equilibre}'")

    # D√©monstration de la port√©e des variables
    print(f"\nD√©monstration des variables globales :")
    print(f"   ‚Ä¢ MINUSCULES (global) : {len(MINUSCULES)} caract√®res")
    print(f"   ‚Ä¢ MAJUSCULES (global) : {len(MAJUSCULES)} caract√®res")
    print(f"   ‚Ä¢ CHIFFRES (global) : {len(CHIFFRES)} caract√®res")
    print(f"   ‚Ä¢ CARACTERES_SPECIAUX (global) : {len(CARACTERES_SPECIAUX)} caract√®res")

if __name__ == "__main__":
    main()
```

## Tests √† effectuer

### Tests des fonctions de base
1. **Fonctions de v√©rification** :
   - `contient_majuscule("Hello")` ‚Üí True
   - `contient_chiffre("abc123")` ‚Üí True
   - `contient_caractere_special("test@")` ‚Üí True

2. **G√©n√©ration de mots de passe** :
   - Longueurs diff√©rentes (4, 8, 12, 16)
   - V√©rifier la pr√©sence des diff√©rents types de caract√®res
   - Mode √©quilibr√© vs standard

3. **√âvaluation de force** :
   - Mots de passe faibles : "123", "password"
   - Mots de passe forts : "MonMotDePasse123!"

### Tests du menu interactif
- Navigation entre toutes les options
- Gestion des entr√©es invalides
- Interruption clavier (Ctrl+C)

## Concepts abord√©s

### 1. Variables globales
```python
MINUSCULES = "abcdefghijklmnopqrstuvwxyz"
MAJUSCULES = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
```

### 2. Fonctions bool√©ennes
```python
def contient_majuscule(texte):
    for caractere in texte:
        if caractere in MAJUSCULES:
            return True
    return False
```

### 3. Module random
```python
import random
mot_de_passe += random.choice(tous_caracteres)
```

### 4. Manipulation de cha√Ænes
- Parcours de caract√®res
- Concat√©nation
- V√©rification d'appartenance

### 5. Logique conditionnelle complexe
- Calcul de scores
- √âvaluation de crit√®res multiples

## Crit√®res d'√©valuation

- ‚úÖ **Fonctions de v√©rification correctes** : D√©tection pr√©cise des types de caract√®res
- ‚úÖ **G√©n√©ration al√©atoire fonctionnelle** : Mots de passe vari√©s et √©quilibr√©s
- ‚úÖ **√âvaluation de force pr√©cise** : Crit√®res de s√©curit√© appropri√©s
- ‚úÖ **Interface utilisateur compl√®te** : Menu riche et informatif
- ‚úÖ **Code modulaire** : S√©paration claire des responsabilit√©s
- ‚úÖ **Gestion d'erreurs** : Validation des entr√©es utilisateur
- ‚úÖ **Fonctionnalit√©s avanc√©es** : Simulation d'attaque, conseils de s√©curit√©

## Extensions possibles

- Support de diff√©rentes langues/alphabets
- G√©n√©ration bas√©e sur des phrases de passe
- Int√©gration avec des APIs de v√©rification de fuites
- Sauvegarde s√©curis√©e de mots de passe
- Interface graphique pour une utilisation plus conviviale
