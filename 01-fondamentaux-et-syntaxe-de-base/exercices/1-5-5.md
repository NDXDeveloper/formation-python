# Exercice 5 : Gestionnaire d'op√©rations math√©matiques

## Objectif

Cr√©er un programme qui propose diff√©rentes op√©rations math√©matiques avec gestion sp√©cifique des erreurs pour chaque op√©ration et un historique des calculs.

## Cahier des charges

1. **Proposer diff√©rentes op√©rations** : +, -, *, /, **, sqrt, log
2. **G√©rer les erreurs sp√©cifiques** √† chaque op√©ration
3. **D√©tecter les calculs impossibles** : log de nombre n√©gatif, sqrt de n√©gatif, etc.
4. **Maintenir un historique** des calculs avec gestion d'erreurs d'√©criture
5. **Menu interactif** avec gestion d'interruption clavier

## Code de base √† compl√©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 5 : Gestionnaire d'op√©rations math√©matiques
Module 1.5 - Gestion des erreurs avec try/except
"""

import math

def demander_nombre(message):
    """
    Demande un nombre avec gestion d'erreurs.

    Args:
        message (str): Message √† afficher

    Returns:
        float: Le nombre saisi ou None si annul√©
    """
    # TODO: Impl√©menter la fonction
    pass

def addition(a, b):
    """
    Effectue une addition.

    Args:
        a (float): Premier nombre
        b (float): Second nombre

    Returns:
        float: R√©sultat de l'addition
    """
    # TODO: Impl√©menter la fonction
    pass

def racine_carree(x):
    """
    Calcule la racine carr√©e avec gestion d'erreurs.

    Args:
        x (float): Nombre dont calculer la racine

    Returns:
        float: Racine carr√©e

    Raises:
        ValueError: Si x est n√©gatif
    """
    # TODO: Impl√©menter la fonction
    pass

def logarithme(x):
    """
    Calcule le logarithme naturel avec gestion d'erreurs.

    Args:
        x (float): Nombre dont calculer le logarithme

    Returns:
        float: Logarithme naturel

    Raises:
        ValueError: Si x <= 0
    """
    # TODO: Impl√©menter la fonction
    pass

def main():
    """Fonction principale du gestionnaire."""
    print("üßÆ === GESTIONNAIRE D'OP√âRATIONS MATH√âMATIQUES ===")

    while True:
        try:
            # TODO: Impl√©menter la logique principale
            pass

        except KeyboardInterrupt:
            # TODO: G√©rer l'interruption clavier
            pass

if __name__ == "__main__":
    main()
```

## Solution compl√®te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 5 : Gestionnaire d'op√©rations math√©matiques - SOLUTION
Module 1.5 - Gestion des erreurs avec try/except
"""

import math
import os
from datetime import datetime

def demander_nombre(message):
    """
    Demande un nombre avec gestion d'erreurs.

    Args:
        message (str): Message √† afficher

    Returns:
        float: Le nombre saisi ou None si annul√©
    """
    while True:
        try:
            entree = input(message)
            return float(entree)

        except ValueError:
            print("‚ùå Veuillez entrer un nombre valide (ex: 3.14, -5, 10)")

        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Saisie annul√©e")
            return None

def addition(a, b):
    """
    Effectue une addition.

    Args:
        a (float): Premier nombre
        b (float): Second nombre

    Returns:
        float: R√©sultat de l'addition

    Raises:
        OverflowError: Si le r√©sultat est trop grand
    """
    try:
        resultat = a + b
        # V√©rifier si le r√©sultat est dans les limites
        if abs(resultat) > 1e308:
            raise OverflowError("R√©sultat trop grand pour √™tre repr√©sent√©")
        return resultat
    except OverflowError:
        raise

def soustraction(a, b):
    """
    Effectue une soustraction.

    Args:
        a (float): Premier nombre
        b (float): Second nombre

    Returns:
        float: R√©sultat de la soustraction

    Raises:
        OverflowError: Si le r√©sultat est trop grand
    """
    try:
        resultat = a - b
        if abs(resultat) > 1e308:
            raise OverflowError("R√©sultat trop grand pour √™tre repr√©sent√©")
        return resultat
    except OverflowError:
        raise

def multiplication(a, b):
    """
    Effectue une multiplication.

    Args:
        a (float): Premier nombre
        b (float): Second nombre

    Returns:
        float: R√©sultat de la multiplication

    Raises:
        OverflowError: Si le r√©sultat est trop grand
    """
    try:
        resultat = a * b
        if abs(resultat) > 1e308:
            raise OverflowError("R√©sultat trop grand pour √™tre repr√©sent√©")
        return resultat
    except OverflowError:
        raise

def division(a, b):
    """
    Effectue une division avec gestion d'erreurs.

    Args:
        a (float): Dividende
        b (float): Diviseur

    Returns:
        float: R√©sultat de la division

    Raises:
        ZeroDivisionError: Si b = 0
        OverflowError: Si le r√©sultat est trop grand
    """
    if b == 0:
        raise ZeroDivisionError("Division par z√©ro impossible")

    try:
        resultat = a / b
        if abs(resultat) > 1e308:
            raise OverflowError("R√©sultat trop grand pour √™tre repr√©sent√©")
        return resultat
    except OverflowError:
        raise

def puissance(a, b):
    """
    Calcule a^b avec gestion d'erreurs.

    Args:
        a (float): Base
        b (float): Exposant

    Returns:
        float: R√©sultat de a^b

    Raises:
        ValueError: Pour des cas impossibles (ex: 0^exposant_n√©gatif)
        OverflowError: Si le r√©sultat est trop grand
    """
    try:
        # Cas sp√©ciaux
        if a == 0 and b < 0:
            raise ValueError("0 ne peut pas √™tre √©lev√© √† une puissance n√©gative")

        if a < 0 and not b.is_integer():
            raise ValueError("Nombre n√©gatif ne peut pas √™tre √©lev√© √† une puissance non enti√®re")

        resultat = a ** b

        # V√©rifier l'overflow
        if abs(resultat) > 1e308:
            raise OverflowError("R√©sultat trop grand pour √™tre repr√©sent√©")

        return resultat

    except OverflowError:
        raise
    except ValueError:
        raise

def racine_carree(x):
    """
    Calcule la racine carr√©e avec gestion d'erreurs.

    Args:
        x (float): Nombre dont calculer la racine

    Returns:
        float: Racine carr√©e

    Raises:
        ValueError: Si x est n√©gatif
    """
    if x < 0:
        raise ValueError("Impossible de calculer la racine carr√©e d'un nombre n√©gatif")

    return math.sqrt(x)

def logarithme(x):
    """
    Calcule le logarithme naturel avec gestion d'erreurs.

    Args:
        x (float): Nombre dont calculer le logarithme

    Returns:
        float: Logarithme naturel

    Raises:
        ValueError: Si x <= 0
    """
    if x <= 0:
        raise ValueError("Impossible de calculer le logarithme d'un nombre n√©gatif ou nul")

    return math.log(x)

def logarithme_base10(x):
    """
    Calcule le logarithme base 10 avec gestion d'erreurs.

    Args:
        x (float): Nombre dont calculer le logarithme

    Returns:
        float: Logarithme base 10

    Raises:
        ValueError: Si x <= 0
    """
    if x <= 0:
        raise ValueError("Impossible de calculer le logarithme d'un nombre n√©gatif ou nul")

    return math.log10(x)

def sauvegarder_historique(historique, nom_fichier="calculs.txt"):
    """
    Sauvegarde l'historique dans un fichier.

    Args:
        historique (list): Liste des calculs
        nom_fichier (str): Nom du fichier

    Returns:
        bool: True si sauvegard√© avec succ√®s
    """
    try:
        with open(nom_fichier, 'w', encoding='utf-8') as f:
            f.write(f"# Historique des calculs - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("# Format: OPERATION|RESULTAT|TIMESTAMP\n")
            f.write("# " + "‚îÄ" * 50 + "\n\n")

            for calcul in historique:
                ligne = f"{calcul['operation']}|{calcul['resultat']}|{calcul['timestamp']}\n"
                f.write(ligne)

        print(f"üíæ Historique sauvegard√© dans '{nom_fichier}' ({len(historique)} calcul(s))")
        return True

    except PermissionError:
        print(f"‚ùå Erreur : Pas de permission d'√©criture pour '{nom_fichier}'")
        return False

    except Exception as e:
        print(f"‚ùå Erreur lors de la sauvegarde : {e}")
        return False

def charger_historique(nom_fichier="calculs.txt"):
    """
    Charge l'historique depuis un fichier.

    Args:
        nom_fichier (str): Nom du fichier

    Returns:
        list: Liste des calculs charg√©s
    """
    historique = []

    try:
        if not os.path.exists(nom_fichier):
            return historique

        with open(nom_fichier, 'r', encoding='utf-8') as f:
            lignes = f.readlines()

        for ligne in lignes:
            ligne = ligne.strip()
            if ligne and not ligne.startswith('#'):
                try:
                    parties = ligne.split('|')
                    if len(parties) >= 3:
                        calcul = {
                            'operation': parties[0],
                            'resultat': parties[1],
                            'timestamp': parties[2]
                        }
                        historique.append(calcul)
                except Exception:
                    continue  # Ignorer les lignes malform√©es

        if historique:
            print(f"üìÅ Historique charg√© : {len(historique)} calcul(s)")

        return historique

    except Exception as e:
        print(f"‚ö†Ô∏è Erreur lors du chargement de l'historique : {e}")
        return []

def afficher_historique(historique):
    """
    Affiche l'historique des calculs.

    Args:
        historique (list): Liste des calculs
    """
    if not historique:
        print("üì≠ Aucun calcul dans l'historique")
        return

    print(f"\nüìö Historique des calculs ({len(historique)} calcul(s)) :")
    print("‚ïê" * 80)

    for i, calcul in enumerate(historique, 1):
        print(f"{i:2d}. {calcul['operation']} = {calcul['resultat']}")
        print(f"     ‚îî‚îÄ {calcul['timestamp']}")

    print("‚ïê" * 80)

    # Statistiques
    if len(historique) >= 2:
        print(f"\nüìä Statistiques :")
        print(f"   ‚Ä¢ Premier calcul : {historique[0]['timestamp']}")
        print(f"   ‚Ä¢ Dernier calcul : {historique[-1]['timestamp']}")

def effectuer_operation_binaire(nom_operation, fonction_operation):
    """
    Effectue une op√©ration binaire (deux op√©randes).

    Args:
        nom_operation (str): Nom de l'op√©ration
        fonction_operation: Fonction √† ex√©cuter

    Returns:
        dict: Informations sur le calcul ou None si annul√©
    """
    print(f"\n{nom_operation.upper()}")

    a = demander_nombre("Premier nombre : ")
    if a is None:
        return None

    b = demander_nombre("Second nombre : ")
    if b is None:
        return None

    try:
        resultat = fonction_operation(a, b)
        operation_str = f"{a} {'+' if nom_operation == 'addition' else '-' if nom_operation == 'soustraction' else '*' if nom_operation == 'multiplication' else '/' if nom_operation == 'division' else '**'} {b}"

        print(f"‚úÖ R√©sultat : {operation_str} = {resultat}")

        return {
            'operation': operation_str,
            'resultat': str(resultat),
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    except ZeroDivisionError as e:
        print(f"‚ùå Erreur de division : {e}")
        print("   üí° Conseil : Le diviseur ne peut pas √™tre z√©ro")

    except ValueError as e:
        print(f"‚ùå Erreur de valeur : {e}")
        print("   üí° Conseil : V√©rifiez les valeurs saisies")

    except OverflowError as e:
        print(f"‚ùå Erreur de d√©bordement : {e}")
        print("   üí° Conseil : Essayez avec des nombres plus petits")

    except Exception as e:
        print(f"‚ùå Erreur inattendue : {e}")

    return None

def effectuer_operation_unaire(nom_operation, fonction_operation):
    """
    Effectue une op√©ration unaire (un op√©rande).

    Args:
        nom_operation (str): Nom de l'op√©ration
        fonction_operation: Fonction √† ex√©cuter

    Returns:
        dict: Informations sur le calcul ou None si annul√©
    """
    print(f"\n{nom_operation.upper()}")

    x = demander_nombre("Nombre : ")
    if x is None:
        return None

    try:
        resultat = fonction_operation(x)

        if nom_operation == "racine carr√©e":
            operation_str = f"‚àö{x}"
        elif nom_operation == "logarithme naturel":
            operation_str = f"ln({x})"
        elif nom_operation == "logarithme base 10":
            operation_str = f"log‚ÇÅ‚ÇÄ({x})"
        else:
            operation_str = f"{nom_operation}({x})"

        print(f"‚úÖ R√©sultat : {operation_str} = {resultat}")

        # Informations suppl√©mentaires
        if nom_operation == "racine carr√©e":
            print(f"   ‚ÑπÔ∏è  V√©rification : {resultat}¬≤ = {resultat**2}")
        elif "logarithme" in nom_operation:
            if nom_operation == "logarithme naturel":
                print(f"   ‚ÑπÔ∏è  V√©rification : e^{resultat} ‚âà {math.exp(resultat):.6f}")
            else:
                print(f"   ‚ÑπÔ∏è  V√©rification : 10^{resultat} ‚âà {10**resultat:.6f}")

        return {
            'operation': operation_str,
            'resultat': str(resultat),
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    except ValueError as e:
        print(f"‚ùå Erreur de valeur : {e}")
        if "racine carr√©e" in nom_operation:
            print("   üí° Conseil : La racine carr√©e n'est d√©finie que pour les nombres positifs")
        elif "logarithme" in nom_operation:
            print("   üí° Conseil : Le logarithme n'est d√©fini que pour les nombres strictement positifs")

    except Exception as e:
        print(f"‚ùå Erreur inattendue : {e}")

    return None

def calculatrice_scientifique():
    """
    Mode calculatrice scientifique avec constantes.
    """
    print(f"\nüî¨ === MODE SCIENTIFIQUE ===")
    print("Constantes disponibles :")
    print(f"   œÄ (pi) = {math.pi}")
    print(f"   e = {math.e}")
    print(f"   œÑ (tau) = {math.tau}")

    constantes = {
        'pi': math.pi,
        'œÄ': math.pi,
        'e': math.e,
        'tau': math.tau,
        'œÑ': math.tau
    }

    while True:
        try:
            print(f"\nOp√©rations scientifiques :")
            print("1. Sinus")
            print("2. Cosinus")
            print("3. Tangente")
            print("4. Factorielle")
            print("5. Utiliser une constante")
            print("6. Retour au menu principal")

            choix = input("\nVotre choix (1-6) : ").strip()

            if choix == "1":
                x = demander_nombre("Angle en radians : ")
                if x is not None:
                    resultat = math.sin(x)
                    print(f"‚úÖ sin({x}) = {resultat}")
                    return {
                        'operation': f"sin({x})",
                        'resultat': str(resultat),
                        'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }

            elif choix == "2":
                x = demander_nombre("Angle en radians : ")
                if x is not None:
                    resultat = math.cos(x)
                    print(f"‚úÖ cos({x}) = {resultat}")
                    return {
                        'operation': f"cos({x})",
                        'resultat': str(resultat),
                        'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }

            elif choix == "3":
                x = demander_nombre("Angle en radians : ")
                if x is not None:
                    try:
                        resultat = math.tan(x)
                        print(f"‚úÖ tan({x}) = {resultat}")
                        return {
                            'operation': f"tan({x})",
                            'resultat': str(resultat),
                            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        }
                    except Exception as e:
                        print(f"‚ùå Erreur : {e}")

            elif choix == "4":
                x = demander_nombre("Nombre entier : ")
                if x is not None:
                    try:
                        if not x.is_integer() or x < 0:
                            print("‚ùå La factorielle n'est d√©finie que pour les entiers positifs")
                        else:
                            x_int = int(x)
                            if x_int > 170:
                                print("‚ùå Nombre trop grand pour calculer la factorielle")
                            else:
                                resultat = math.factorial(x_int)
                                print(f"‚úÖ {x_int}! = {resultat}")
                                return {
                                    'operation': f"{x_int}!",
                                    'resultat': str(resultat),
                                    'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                                }
                    except Exception as e:
                        print(f"‚ùå Erreur : {e}")

            elif choix == "5":
                print("Constantes disponibles :", ", ".join(constantes.keys()))
                nom_constante = input("Nom de la constante : ").strip().lower()
                if nom_constante in constantes:
                    valeur = constantes[nom_constante]
                    print(f"‚úÖ {nom_constante} = {valeur}")
                    return {
                        'operation': nom_constante,
                        'resultat': str(valeur),
                        'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                else:
                    print("‚ùå Constante inconnue")

            elif choix == "6":
                return None

            else:
                print("‚ùå Choix invalide")

        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Retour au menu principal")
            return None

def main():
    """Fonction principale du gestionnaire."""
    print("üßÆ === GESTIONNAIRE D'OP√âRATIONS MATH√âMATIQUES ===")
    print("Calculatrice avanc√©e avec gestion d'erreurs et historique")

    # Charger l'historique existant
    historique = charger_historique()

    operations = {
        '1': ('Addition', lambda: effectuer_operation_binaire('addition', addition)),
        '2': ('Soustraction', lambda: effectuer_operation_binaire('soustraction', soustraction)),
        '3': ('Multiplication', lambda: effectuer_operation_binaire('multiplication', multiplication)),
        '4': ('Division', lambda: effectuer_operation_binaire('division', division)),
        '5': ('Puissance', lambda: effectuer_operation_binaire('puissance', puissance)),
        '6': ('Racine carr√©e', lambda: effectuer_operation_unaire('racine carr√©e', racine_carree)),
        '7': ('Logarithme naturel', lambda: effectuer_operation_unaire('logarithme naturel', logarithme)),
        '8': ('Logarithme base 10', lambda: effectuer_operation_unaire('logarithme base 10', logarithme_base10)),
        '9': ('Mode scientifique', calculatrice_scientifique)
    }

    while True:
        try:
            print("\n" + "‚ïê" * 70)
            print("üßÆ OP√âRATIONS DISPONIBLES".center(70))
            print("‚ïê" * 70)

            # Op√©rations de base
            print("üìê Op√©rations de base :")
            print("1. ‚ûï Addition")
            print("2. ‚ûñ Soustraction")
            print("3. ‚úñÔ∏è  Multiplication")
            print("4. ‚ûó Division")
            print("5. üî∫ Puissance")

            # Op√©rations avanc√©es
            print("\nüî¨ Op√©rations avanc√©es :")
            print("6. ‚àö  Racine carr√©e")
            print("7. ln Logarithme naturel")
            print("8. log Logarithme base 10")
            print("9. üß™ Mode scientifique")

            # Gestion
            print("\nüìä Gestion :")
            print("10. üìö Afficher l'historique")
            print("11. üíæ Sauvegarder l'historique")
            print("12. üóëÔ∏è  Effacer l'historique")
            print("13. ‚ùå Quitter")

            choix = input(f"\nVotre choix (1-13) : ").strip()

            if choix in operations:
                resultat = operations[choix][1]()
                if resultat:
                    historique.append(resultat)

            elif choix == "10":
                afficher_historique(historique)

            elif choix == "11":
                sauvegarder_historique(historique)

            elif choix == "12":
                if historique:
                    confirmation = input(f"‚ö†Ô∏è Effacer {len(historique)} calcul(s) ? (oui/non) : ").lower()
                    if confirmation in ['oui', 'o', 'yes', 'y']:
                        historique.clear()
                        print("üóëÔ∏è Historique effac√©")
                    else:
                        print("‚èπÔ∏è Effacement annul√©")
                else:
                    print("üì≠ L'historique est d√©j√† vide")

            elif choix == "13":
                if historique:
                    print(f"\nüìã R√©sum√© de la session :")
                    print(f"   ‚Ä¢ {len(historique)} calcul(s) effectu√©(s)")

                    # Proposition de sauvegarde
                    if len(historique) > 0:
                        sauvegarder = input("üíæ Sauvegarder l'historique avant de quitter ? (o/n) : ").lower()
                        if sauvegarder in ['o', 'oui', 'y', 'yes']:
                            sauvegarder_historique(historique)

                print("\nüëã Merci d'avoir utilis√© le gestionnaire math√©matique !")
                print("√Ä bient√¥t ! üßÆ")
                break

            else:
                print("‚ùå Choix invalide. Veuillez entrer un nombre entre 1 et 13.")

        except KeyboardInterrupt:
            print(f"\n\n‚èπÔ∏è Programme interrompu par l'utilisateur")
            if historique:
                print(f"üìö Calculs effectu√©s dans cette session : {len(historique)}")
                try:
                    sauvegarder = input("üíæ Sauvegarder l'historique ? (o/n) : ").lower()
                    if sauvegarder in ['o', 'oui', 'y', 'yes']:
                        sauvegarder_historique(historique)
                except KeyboardInterrupt:
                    print("\nüîÑ Sauvegarde automatique...")
                    sauvegarder_historique(historique)
            print("üëã Au revoir !")
            break

        except Exception as e:
            print(f"‚ùå Erreur inattendue dans le menu : {e}")
            print("üîÑ Retour au menu principal...")

if __name__ == "__main__":
    main()
```

## Tests √† effectuer

### Tests pour chaque op√©ration

#### Op√©rations de base
- **Addition** : 5 + 3 = 8
- **Soustraction** : 10 - 4 = 6
- **Multiplication** : 7 * 8 = 56
- **Division** : 15 / 3 = 5, 10 / 0 ‚Üí erreur
- **Puissance** : 2^3 = 8, 0^(-1) ‚Üí erreur

#### Op√©rations avanc√©es
- **Racine carr√©e** : ‚àö16 = 4, ‚àö(-4) ‚Üí erreur
- **Logarithme naturel** : ln(e) ‚âà 1, ln(-1) ‚Üí erreur
- **Logarithme base 10** : log‚ÇÅ‚ÇÄ(100) = 2, log‚ÇÅ‚ÇÄ(0) ‚Üí erreur

#### Mode scientifique
- **Trigonom√©trie** : sin(œÄ/2) = 1, cos(0) = 1
- **Factorielle** : 5! = 120, (-3)! ‚Üí erreur
- **Constantes** : œÄ ‚âà 3.14159, e ‚âà 2.71828

### Tests de gestion d'erreurs
- **Interruption clavier** : Ctrl+C pendant la saisie
- **Valeurs limites** : Tr√®s grands nombres, overflow
- **Types invalides** : Texte au lieu de nombres
- **Fichier prot√©g√©** : Erreur de sauvegarde

### Tests d'historique
- **Sauvegarde/chargement** : Persistance des donn√©es
- **Affichage** : Format correct des calculs
- **Statistiques** : Nombre de calculs, dates

## Crit√®res d'√©valuation

- ‚úÖ **Gestion d'erreurs sp√©cifiques** : Chaque op√©ration a ses erreurs propres
- ‚úÖ **D√©tection des cas impossibles** : Domaines de d√©finition respect√©s
- ‚úÖ **Historique complet** : Sauvegarde, chargement, affichage
- ‚úÖ **Interface riche** : Menu clair, mode scientifique
- ‚úÖ **Interruption clavier** : Gestion propre de Ctrl+C
- ‚úÖ **Robustesse** : Gestion de tous les cas d'erreur
- ‚úÖ **Fonctionnalit√©s avanc√©es** : Constantes, trigonom√©trie, factorielle

## Extensions possibles

- **Graphiques** : Tracer des fonctions math√©matiques
- **Conversions d'unit√©s** : Degr√©s/radians, temp√©ratures
- **Calcul matriciel** : Op√©rations sur les matrices
- **√âquations** : R√©solution d'√©quations du second degr√©
- **Statistiques** : Moyenne, m√©diane, √©cart-type
- **Mode programmeur** : Op√©rations binaires, hexad√©cimales

## R√©capitulatif des 5 exercices

Vous avez maintenant 5 exercices complets qui couvrent tous les aspects de la gestion d'erreurs en Python :

1. **Division s√©curis√©e** : Gestion basique avec historique
2. **Lecteur de fichier** : Erreurs de fichiers et encodages
3. **Convertisseur de types** : Validation et conversion de donn√©es
4. **Validateur de formulaire** : Validation complexe avec correction
5. **Gestionnaire math√©matique** : Erreurs sp√©cifiques aux domaines math√©matiques

Chaque exercice illustre des concepts diff√©rents et progressifs de la gestion d'erreurs, permettant aux √©tudiants de ma√Ætriser compl√®tement le Module 1.5 !
