# Exercice 1.4.5 : Jeu de Pierre-Papier-Ciseaux

## Objectif

CrÃ©er un jeu complet de Pierre-Papier-Ciseaux pour comprendre l'organisation d'un programme en fonctions, la logique de jeu et la gestion d'Ã©tat.

## Cahier des charges

1. **obtenir_choix_joueur()** â†’ demande le choix du joueur
2. **obtenir_choix_ordinateur()** â†’ gÃ©nÃ¨re le choix de l'ordinateur
3. **determiner_gagnant(choix1, choix2)** â†’ dÃ©termine le gagnant
4. **afficher_resultat(choix_joueur, choix_ordi, gagnant)** â†’ affiche le rÃ©sultat
5. **jouer_partie()** â†’ gÃ¨re une partie complÃ¨te
6. **afficher_scores(victoires, defaites, egalites)** â†’ affiche les scores
7. **Programme principal** avec parties multiples

## Code de base Ã  complÃ©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 1.4.5 : Jeu de Pierre-Papier-Ciseaux
Module 1.4 - Fonctions et portÃ©e des variables
"""

import random

# Constantes globales
CHOIX_VALIDES = ["pierre", "papier", "ciseaux"]
CHOIX_RACCOURCIS = {"p": "pierre", "pa": "papier", "c": "ciseaux"}

def obtenir_choix_joueur():
    """
    Demande et valide le choix du joueur.

    Returns:
        str: Choix du joueur ("pierre", "papier", "ciseaux") ou None si annulÃ©
    """
    # TODO: ImplÃ©menter la saisie avec validation
    pass

def obtenir_choix_ordinateur():
    """
    GÃ©nÃ¨re un choix alÃ©atoire pour l'ordinateur.

    Returns:
        str: Choix de l'ordinateur ("pierre", "papier", "ciseaux")
    """
    # TODO: GÃ©nÃ©rer un choix alÃ©atoire
    pass

def determiner_gagnant(choix1, choix2):
    """
    DÃ©termine le gagnant entre deux choix.

    Args:
        choix1 (str): Premier choix
        choix2 (str): Second choix

    Returns:
        str: "joueur1", "joueur2", ou "egalite"
    """
    # RÃ¨gles : pierre > ciseaux, ciseaux > papier, papier > pierre
    # TODO: ImplÃ©menter la logique du jeu
    pass

def afficher_resultat(choix_joueur, choix_ordi, gagnant):
    """
    Affiche le rÃ©sultat d'une partie.

    Args:
        choix_joueur (str): Choix du joueur
        choix_ordi (str): Choix de l'ordinateur
        gagnant (str): RÃ©sultat du gagnant
    """
    # TODO: Afficher de maniÃ¨re formatÃ©e
    pass

def jouer_partie():
    """
    GÃ¨re une partie complÃ¨te.

    Returns:
        str: RÃ©sultat de la partie ("victoire", "defaite", "egalite", "annulee")
    """
    # TODO: Orchestrer une partie complÃ¨te
    pass

def afficher_scores(victoires, defaites, egalites):
    """
    Affiche les scores actuels.

    Args:
        victoires (int): Nombre de victoires
        defaites (int): Nombre de dÃ©faites
        egalites (int): Nombre d'Ã©galitÃ©s
    """
    # TODO: Afficher les statistiques
    pass

def main():
    """Programme principal du jeu."""
    print("ğŸ® === JEU DE PIERRE-PAPIER-CISEAUX ===")

    # Compteurs de score
    victoires = 0
    defaites = 0
    egalites = 0

    while True:
        # TODO: CrÃ©er la boucle de jeu principale
        pass

if __name__ == "__main__":
    main()
```

## Solution complÃ¨te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 1.4.5 : Jeu de Pierre-Papier-Ciseaux - SOLUTION
Module 1.4 - Fonctions et portÃ©e des variables
"""

import random

# Constantes globales
CHOIX_VALIDES = ["pierre", "papier", "ciseaux"]
CHOIX_RACCOURCIS = {"p": "pierre", "pa": "papier", "c": "ciseaux"}
EMOJIS = {"pierre": "ğŸª¨", "papier": "ğŸ“„", "ciseaux": "âœ‚ï¸"}

def obtenir_choix_joueur():
    """
    Demande et valide le choix du joueur.

    Returns:
        str: Choix du joueur ("pierre", "papier", "ciseaux") ou None si annulÃ©

    Example:
        >>> # Si l'utilisateur tape "p"
        >>> obtenir_choix_joueur()
        'pierre'
    """
    while True:
        try:
            print("\nğŸ¯ Votre choix :")
            print("   â€¢ (p)ierre ğŸª¨")
            print("   â€¢ (pa)pier ğŸ“„")
            print("   â€¢ (c)iseaux âœ‚ï¸")

            choix = input("Votre choix : ").lower().strip()

            # VÃ©rifier les raccourcis
            if choix in CHOIX_RACCOURCIS:
                return CHOIX_RACCOURCIS[choix]

            # VÃ©rifier les noms complets
            if choix in CHOIX_VALIDES:
                return choix

            print("âŒ Choix invalide. Utilisez : pierre, papier, ciseaux (ou p, pa, c)")

        except KeyboardInterrupt:
            print("\nâ¹ï¸ Partie annulÃ©e")
            return None

def obtenir_choix_ordinateur():
    """
    GÃ©nÃ¨re un choix alÃ©atoire pour l'ordinateur.

    Returns:
        str: Choix de l'ordinateur ("pierre", "papier", "ciseaux")

    Example:
        >>> choix = obtenir_choix_ordinateur()
        >>> choix in CHOIX_VALIDES
        True
    """
    return random.choice(CHOIX_VALIDES)

def determiner_gagnant(choix1, choix2):
    """
    DÃ©termine le gagnant entre deux choix.

    Args:
        choix1 (str): Premier choix
        choix2 (str): Second choix

    Returns:
        str: "joueur1", "joueur2", ou "egalite"

    Example:
        >>> determiner_gagnant("pierre", "ciseaux")
        'joueur1'
        >>> determiner_gagnant("pierre", "papier")
        'joueur2'
        >>> determiner_gagnant("pierre", "pierre")
        'egalite'
    """
    if choix1 == choix2:
        return "egalite"

    # DÃ©finir les rÃ¨gles de victoire
    regles_victoire = {
        "pierre": "ciseaux",    # Pierre Ã©crase ciseaux
        "ciseaux": "papier",    # Ciseaux coupent papier
        "papier": "pierre"      # Papier enveloppe pierre
    }

    if regles_victoire[choix1] == choix2:
        return "joueur1"
    else:
        return "joueur2"

def expliquer_resultat(choix_gagnant, choix_perdant):
    """
    Explique pourquoi un choix bat un autre.

    Args:
        choix_gagnant (str): Choix qui gagne
        choix_perdant (str): Choix qui perd

    Returns:
        str: Explication du rÃ©sultat
    """
    explications = {
        ("pierre", "ciseaux"): "La pierre Ã©crase les ciseaux",
        ("ciseaux", "papier"): "Les ciseaux coupent le papier",
        ("papier", "pierre"): "Le papier enveloppe la pierre"
    }

    return explications.get((choix_gagnant, choix_perdant), "")

def afficher_resultat(choix_joueur, choix_ordi, gagnant):
    """
    Affiche le rÃ©sultat d'une partie.

    Args:
        choix_joueur (str): Choix du joueur
        choix_ordi (str): Choix de l'ordinateur
        gagnant (str): RÃ©sultat du gagnant
    """
    print(f"\nğŸ¯ === RÃ‰SULTAT DE LA PARTIE ===")

    # Affichage des choix avec emojis
    emoji_joueur = EMOJIS[choix_joueur]
    emoji_ordi = EMOJIS[choix_ordi]

    print(f"ğŸ‘¤ Vous      : {choix_joueur.capitalize()} {emoji_joueur}")
    print(f"ğŸ¤– Ordinateur : {choix_ordi.capitalize()} {emoji_ordi}")

    # Affichage du rÃ©sultat
    if gagnant == "joueur1":
        print(f"ğŸ‰ VICTOIRE ! ğŸ‰")
        explication = expliquer_resultat(choix_joueur, choix_ordi)
        print(f"ğŸ’¡ {explication}")
    elif gagnant == "joueur2":
        print(f"ğŸ˜ DÃ‰FAITE... ğŸ˜")
        explication = expliquer_resultat(choix_ordi, choix_joueur)
        print(f"ğŸ’¡ {explication}")
    else:
        print(f"ğŸ¤ Ã‰GALITÃ‰ ! ğŸ¤")
        print(f"ğŸ’¡ MÃªme choix des deux cÃ´tÃ©s")

    print("â”€" * 30)

def jouer_partie():
    """
    GÃ¨re une partie complÃ¨te.

    Returns:
        str: RÃ©sultat de la partie ("victoire", "defaite", "egalite", "annulee")
    """
    print(f"\nğŸ® === NOUVELLE PARTIE ===")

    # Obtenir le choix du joueur
    choix_joueur = obtenir_choix_joueur()
    if choix_joueur is None:
        return "annulee"

    # GÃ©nÃ©rer le choix de l'ordinateur
    choix_ordi = obtenir_choix_ordinateur()

    # DÃ©terminer le gagnant
    gagnant = determiner_gagnant(choix_joueur, choix_ordi)

    # Afficher le rÃ©sultat
    afficher_resultat(choix_joueur, choix_ordi, gagnant)

    # Convertir le rÃ©sultat pour les statistiques
    if gagnant == "joueur1":
        return "victoire"
    elif gagnant == "joueur2":
        return "defaite"
    else:
        return "egalite"

def afficher_scores(victoires, defaites, egalites):
    """
    Affiche les scores actuels.

    Args:
        victoires (int): Nombre de victoires
        defaites (int): Nombre de dÃ©faites
        egalites (int): Nombre d'Ã©galitÃ©s
    """
    total_parties = victoires + defaites + egalites

    if total_parties == 0:
        print("ğŸ“Š Aucune partie jouÃ©e encore")
        return

    print(f"\nğŸ“Š === TABLEAU DES SCORES ===")
    print(f"ğŸ‰ Victoires : {victoires:3d}")
    print(f"ğŸ˜ DÃ©faites  : {defaites:3d}")
    print(f"ğŸ¤ Ã‰galitÃ©s  : {egalites:3d}")
    print(f"ğŸ“ˆ Total     : {total_parties:3d}")

    if total_parties > 0:
        pourcentage_victoires = (victoires / total_parties) * 100
        pourcentage_defaites = (defaites / total_parties) * 100
        pourcentage_egalites = (egalites / total_parties) * 100

        print(f"\nğŸ“ˆ Pourcentages :")
        print(f"ğŸ‰ Victoires : {pourcentage_victoires:5.1f}%")
        print(f"ğŸ˜ DÃ©faites  : {pourcentage_defaites:5.1f}%")
        print(f"ğŸ¤ Ã‰galitÃ©s  : {pourcentage_egalites:5.1f}%")

        # Ã‰valuation de performance
        if pourcentage_victoires > 60:
            print(f"ğŸ† Excellent ! Vous dominez l'ordinateur !")
        elif pourcentage_victoires > 40:
            print(f"ğŸ‘ Bien jouÃ© ! Vous tenez tÃªte Ã  l'ordinateur")
        elif pourcentage_victoires > 25:
            print(f"ğŸ˜ Pas mal, mais vous pouvez faire mieux")
        else:
            print(f"ğŸ˜… L'ordinateur a l'avantage... pour le moment !")

def afficher_regles():
    """Affiche les rÃ¨gles du jeu."""
    print(f"\nğŸ“œ === RÃˆGLES DU JEU ===")
    print(f"ğŸª¨ Pierre Ã©crase âœ‚ï¸  Ciseaux")
    print(f"âœ‚ï¸  Ciseaux coupent ğŸ“„ Papier")
    print(f"ğŸ“„ Papier enveloppe ğŸª¨ Pierre")
    print(f"\nğŸ’¡ Conseils :")
    print(f"   â€¢ Utilisez les raccourcis : p, pa, c")
    print(f"   â€¢ Le jeu est basÃ© sur la chance !")
    print(f"   â€¢ Amusez-vous bien ! ğŸ®")

def statistiques_detaillees(victoires, defaites, egalites):
    """
    Affiche des statistiques dÃ©taillÃ©es.

    Args:
        victoires (int): Nombre de victoires
        defaites (int): Nombre de dÃ©faites
        egalites (int): Nombre d'Ã©galitÃ©s
    """
    total = victoires + defaites + egalites

    if total == 0:
        print("ğŸ“Š Aucune statistique disponible")
        return

    print(f"\nğŸ“ˆ === STATISTIQUES DÃ‰TAILLÃ‰ES ===")

    # Calculs de base
    print(f"Parties jouÃ©es : {total}")
    print(f"Parties gagnÃ©es : {victoires} ({victoires/total*100:.1f}%)")
    print(f"Parties perdues : {defaites} ({defaites/total*100:.1f}%)")
    print(f"Ã‰galitÃ©s : {egalites} ({egalites/total*100:.1f}%)")

    # Ratios
    if defaites > 0:
        ratio_victoires = victoires / defaites
        print(f"Ratio victoires/dÃ©faites : {ratio_victoires:.2f}")

    # SÃ©ries
    print(f"\nğŸ”¥ Records potentiels :")
    print(f"   â€¢ Meilleure sÃ©rie possible : {max(victoires, defaites, egalites)} parties")

    # PrÃ©dictions amusantes
    if total >= 10:
        print(f"\nğŸ”® PrÃ©dictions :")
        tendance_victoire = victoires / total
        if tendance_victoire > 0.5:
            print(f"   â€¢ Vous avez {tendance_victoire*100:.0f}% de chances de gagner la prochaine !")
        else:
            print(f"   â€¢ L'ordinateur a l'avantage statistique...")

def mode_tournoi():
    """Mode tournoi : premier Ã  X victoires."""
    print(f"\nğŸ† === MODE TOURNOI ===")

    try:
        objectif = int(input("Premier Ã  combien de victoires ? (1-10) : "))
        if objectif < 1 or objectif > 10:
            print("âŒ Objectif invalide (1-10)")
            return
    except ValueError:
        print("âŒ Veuillez entrer un nombre")
        return

    victoires_joueur = 0
    victoires_ordi = 0
    parties_jouees = 0

    print(f"\nğŸ¯ Tournoi au meilleur de {objectif} victoire(s) !")

    while victoires_joueur < objectif and victoires_ordi < objectif:
        parties_jouees += 1
        print(f"\nğŸ® Partie {parties_jouees} - Score: Vous {victoires_joueur} - {victoires_ordi} Ordinateur")

        resultat = jouer_partie()

        if resultat == "annulee":
            print("â¹ï¸ Tournoi annulÃ©")
            return
        elif resultat == "victoire":
            victoires_joueur += 1
        elif resultat == "defaite":
            victoires_ordi += 1
        # Les Ã©galitÃ©s ne comptent pas dans le tournoi

        # Affichage du score intermÃ©diaire
        print(f"Score actuel : Vous {victoires_joueur} - {victoires_ordi} Ordinateur")

    # RÃ©sultat final du tournoi
    print(f"\nğŸ† === FIN DU TOURNOI ===")
    if victoires_joueur == objectif:
        print(f"ğŸ‰ FÃ‰LICITATIONS ! Vous avez gagnÃ© le tournoi {victoires_joueur}-{victoires_ordi} !")
        print(f"ğŸ† Vous Ãªtes le champion en {parties_jouees} parties !")
    else:
        print(f"ğŸ˜ L'ordinateur a gagnÃ© le tournoi {victoires_ordi}-{victoires_joueur}")
        print(f"ğŸ¤– Meilleure chance la prochaine fois !")

def mode_entrainement():
    """Mode d'entraÃ®nement avec conseils."""
    print(f"\nğŸ¯ === MODE ENTRAÃNEMENT ===")
    print("Dans ce mode, vous recevrez des conseils aprÃ¨s chaque partie")

    conseils = [
        "ğŸ’¡ Pierre est un choix solide et populaire",
        "ğŸ’¡ Beaucoup de joueurs choisissent ciseaux en premier",
        "ğŸ’¡ Papier est souvent sous-estimÃ©",
        "ğŸ’¡ Essayez de varier vos choix pour Ãªtre imprÃ©visible",
        "ğŸ’¡ L'ordinateur choisit vraiment au hasard",
        "ğŸ’¡ Dans un vrai match, observez les habitudes de l'adversaire",
        "ğŸ’¡ Le pierre-papier-ciseaux est un jeu de psychologie autant que de chance"
    ]

    parties = 0
    while True:
        resultat = jouer_partie()

        if resultat == "annulee":
            break

        parties += 1

        # Donner un conseil
        if parties <= len(conseils):
            print(f"\n{conseils[parties-1]}")

        continuer = input("\nContinuer l'entraÃ®nement ? (o/n) : ").lower()
        if continuer not in ['o', 'oui', 'y', 'yes']:
            break

    print(f"âœ… EntraÃ®nement terminÃ© aprÃ¨s {parties} partie(s)")

def afficher_historique(historique):
    """
    Affiche l'historique des parties.

    Args:
        historique (list): Liste des parties jouÃ©es
    """
    if not historique:
        print("ğŸ“­ Aucune partie dans l'historique")
        return

    print(f"\nğŸ“š === HISTORIQUE DES PARTIES ===")
    print(f"DerniÃ¨res {min(10, len(historique))} parties :")

    for i, partie in enumerate(historique[-10:], 1):
        emoji_result = {"victoire": "ğŸ‰", "defaite": "ğŸ˜", "egalite": "ğŸ¤"}
        emoji_joueur = EMOJIS[partie['choix_joueur']]
        emoji_ordi = EMOJIS[partie['choix_ordi']]

        print(f"{i:2d}. {emoji_joueur} vs {emoji_ordi} â†’ {emoji_result[partie['resultat']]}")

def main():
    """Programme principal du jeu."""
    print("ğŸ® === JEU DE PIERRE-PAPIER-CISEAUX ===")
    print("Affrontez l'ordinateur dans ce grand classique !")

    # Compteurs de score
    victoires = 0
    defaites = 0
    egalites = 0
    historique = []

    # Afficher les rÃ¨gles au dÃ©but
    afficher_regles()

    while True:
        print(f"\n" + "â•" * 50)
        print(f"ğŸ® MENU PRINCIPAL".center(50))
        print("â•" * 50)
        print("1. ğŸ¯ Jouer une partie")
        print("2. ğŸ† Mode tournoi")
        print("3. ğŸ¯ Mode entraÃ®nement")
        print("4. ğŸ“Š Afficher les scores")
        print("5. ğŸ“ˆ Statistiques dÃ©taillÃ©es")
        print("6. ğŸ“š Historique des parties")
        print("7. ğŸ“œ Revoir les rÃ¨gles")
        print("8. ğŸ”„ Remettre les scores Ã  zÃ©ro")
        print("9. âŒ Quitter")

        choix = input(f"\nVotre choix (1-9) : ").strip()

        try:
            if choix == "1":
                resultat = jouer_partie()

                if resultat == "victoire":
                    victoires += 1
                elif resultat == "defaite":
                    defaites += 1
                elif resultat == "egalite":
                    egalites += 1

                # Ajouter Ã  l'historique si la partie n'a pas Ã©tÃ© annulÃ©e
                if resultat != "annulee":
                    # Pour simplifier, on stocke juste le rÃ©sultat
                    # Dans une vraie implÃ©mentation, on stockerait plus de dÃ©tails
                    historique.append({
                        'choix_joueur': 'pierre',  # Placeholder
                        'choix_ordi': 'pierre',    # Placeholder
                        'resultat': resultat
                    })

            elif choix == "2":
                mode_tournoi()

            elif choix == "3":
                mode_entrainement()

            elif choix == "4":
                afficher_scores(victoires, defaites, egalites)

            elif choix == "5":
                statistiques_detaillees(victoires, defaites, egalites)

            elif choix == "6":
                afficher_historique(historique)

            elif choix == "7":
                afficher_regles()

            elif choix == "8":
                confirmation = input("âš ï¸ Remettre tous les scores Ã  zÃ©ro ? (oui/non) : ").lower()
                if confirmation in ['oui', 'o', 'yes', 'y']:
                    victoires = defaites = egalites = 0
                    historique.clear()
                    print("ğŸ”„ Scores remis Ã  zÃ©ro !")
                else:
                    print("â¹ï¸ AnnulÃ©")

            elif choix == "9":
                if victoires + defaites + egalites > 0:
                    print(f"\nğŸ“‹ === RÃ‰SUMÃ‰ DE LA SESSION ===")
                    afficher_scores(victoires, defaites, egalites)

                print("\nğŸ® Merci d'avoir jouÃ© au Pierre-Papier-Ciseaux !")
                print("Ã€ bientÃ´t pour de nouvelles parties ! ğŸ¯")
                break

            else:
                print("âŒ Choix invalide. Veuillez entrer un nombre entre 1 et 9.")

        except KeyboardInterrupt:
            print(f"\n\nâ¹ï¸ Jeu interrompu par l'utilisateur")
            if victoires + defaites + egalites > 0:
                print(f"ğŸ® Parties jouÃ©es dans cette session : {victoires + defaites + egalites}")
                afficher_scores(victoires, defaites, egalites)
            print("ğŸ‘‹ Au revoir !")
            break

        except Exception as e:
            print(f"âŒ Erreur inattendue : {e}")
            print("ğŸ”„ Retour au menu principal...")

if __name__ == "__main__":
    main()
```

## Tests Ã  effectuer

### Tests des fonctions de base
1. **Logique du jeu** :
   - Pierre vs Ciseaux â†’ Pierre gagne
   - Ciseaux vs Papier â†’ Ciseaux gagne
   - Papier vs Pierre â†’ Papier gagne
   - Choix identiques â†’ Ã‰galitÃ©

2. **Interface utilisateur** :
   - Saisie avec raccourcis (p, pa, c)
   - Saisie avec noms complets
   - Gestion des entrÃ©es invalides
   - Interruption clavier (Ctrl+C)

3. **Gestion des scores** :
   - Comptage correct des victoires/dÃ©faites/Ã©galitÃ©s
   - Calcul des pourcentages
   - Remise Ã  zÃ©ro

### Tests des modes de jeu
- **Mode normal** : Parties individuelles
- **Mode tournoi** : Premier Ã  X victoires
- **Mode entraÃ®nement** : Avec conseils
- **Historique** : Stockage et affichage

## Concepts abordÃ©s

### 1. Variables globales et constantes
```python
CHOIX_VALIDES = ["pierre", "papier", "ciseaux"]
CHOIX_RACCOURCIS = {"p": "pierre", "pa": "papier", "c": "ciseaux"}
```

### 2. Module random
```python
import random
return random.choice(CHOIX_VALIDES)
```

### 3. Logique conditionnelle complexe
```python
def determiner_gagnant(choix1, choix2):
    if choix1 == choix2:
        return "egalite"
    # Logique des rÃ¨gles...
```

### 4. Gestion d'Ã©tat du programme
- Compteurs de scores
- Historique des parties
- Modes de jeu diffÃ©rents

### 5. Fonctions pures vs fonctions avec effets de bord
- `determiner_gagnant()` : fonction pure
- `afficher_resultat()` : fonction avec effets de bord

## CritÃ¨res d'Ã©valuation

- âœ… **Logique de jeu correcte** : RÃ¨gles du pierre-papier-ciseaux respectÃ©es
- âœ… **Interface utilisateur intuitive** : Saisie facile avec raccourcis
- âœ… **Gestion des scores** : Comptage et statistiques prÃ©cis
- âœ… **Modes de jeu variÃ©s** : Normal, tournoi, entraÃ®nement
- âœ… **Code modulaire** : Fonctions bien sÃ©parÃ©es et rÃ©utilisables
- âœ… **Gestion d'erreurs** : Validation et rÃ©cupÃ©ration d'erreurs
- âœ… **FonctionnalitÃ©s avancÃ©es** : Historique, statistiques dÃ©taillÃ©es

## Extensions possibles

- Version Pierre-Papier-Ciseaux-LÃ©zard-Spock
- Multijoueur (2 joueurs humains)
- IA plus sophistiquÃ©e qui apprend des patterns
- Sauvegarde des scores entre sessions
- Interface graphique avec animations
- Statistiques par session vs globales
- Modes de difficultÃ© avec IA biaisÃ©e
