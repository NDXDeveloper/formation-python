# Exercice 1.4.4 : Syst√®me de notes

## Objectif

Cr√©er un syst√®me de gestion de notes pour comprendre les fonctions qui manipulent des listes, calculent des statistiques et g√®rent des donn√©es structur√©es.

## Cahier des charges

1. **ajouter_note(liste_notes, note)** ‚Üí ajoute une note √† la liste
2. **calculer_moyenne(liste_notes)** ‚Üí calcule la moyenne
3. **obtenir_mention(moyenne)** ‚Üí retourne la mention selon la moyenne
4. **nombre_notes_superieures(liste_notes, seuil)** ‚Üí compte les notes > seuil
5. **afficher_statistiques(liste_notes)** ‚Üí affiche toutes les statistiques
6. **Programme principal** avec menu interactif

## Code de base √† compl√©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 1.4.4 : Syst√®me de notes
Module 1.4 - Fonctions et port√©e des variables
"""

def ajouter_note(liste_notes, note):
    """
    Ajoute une note √† la liste si elle est valide.

    Args:
        liste_notes (list): Liste des notes existantes
        note (float): Note √† ajouter (0-20)

    Returns:
        bool: True si la note a √©t√© ajout√©e, False sinon
    """
    # TODO: Valider la note (0-20) et l'ajouter √† la liste
    pass

def calculer_moyenne(liste_notes):
    """
    Calcule la moyenne des notes.

    Args:
        liste_notes (list): Liste des notes

    Returns:
        float: Moyenne des notes ou 0 si liste vide
    """
    # TODO: Calculer la moyenne
    pass

def obtenir_mention(moyenne):
    """
    D√©termine la mention selon la moyenne.

    Args:
        moyenne (float): Moyenne des notes

    Returns:
        str: Mention correspondante
    """
    # Bar√®me fran√ßais :
    # 16-20: Tr√®s bien, 14-16: Bien, 12-14: Assez bien,
    # 10-12: Passable, 0-10: Insuffisant
    # TODO: Impl√©menter la logique
    pass

def nombre_notes_superieures(liste_notes, seuil):
    """
    Compte les notes sup√©rieures √† un seuil.

    Args:
        liste_notes (list): Liste des notes
        seuil (float): Seuil de comparaison

    Returns:
        int: Nombre de notes sup√©rieures au seuil
    """
    # TODO: Compter les notes > seuil
    pass

def afficher_statistiques(liste_notes):
    """
    Affiche toutes les statistiques des notes.

    Args:
        liste_notes (list): Liste des notes
    """
    # TODO: Afficher moyenne, mention, min, max, etc.
    pass

def main():
    """Programme principal du syst√®me de notes."""
    print("üìö === SYST√àME DE GESTION DE NOTES ===")

    notes = []  # Liste pour stocker les notes

    while True:
        # TODO: Cr√©er le menu interactif
        pass

if __name__ == "__main__":
    main()
```

## Solution compl√®te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 1.4.4 : Syst√®me de notes - SOLUTION
Module 1.4 - Fonctions et port√©e des variables
"""

def ajouter_note(liste_notes, note):
    """
    Ajoute une note √† la liste si elle est valide.

    Args:
        liste_notes (list): Liste des notes existantes
        note (float): Note √† ajouter (0-20)

    Returns:
        bool: True si la note a √©t√© ajout√©e, False sinon

    Example:
        >>> notes = []
        >>> ajouter_note(notes, 15.5)
        True
        >>> len(notes)
        1
    """
    # Validation de la note
    if not isinstance(note, (int, float)):
        return False

    if note < 0 or note > 20:
        return False

    # Ajouter la note √† la liste
    liste_notes.append(note)
    return True

def calculer_moyenne(liste_notes):
    """
    Calcule la moyenne des notes.

    Args:
        liste_notes (list): Liste des notes

    Returns:
        float: Moyenne des notes ou 0 si liste vide

    Example:
        >>> calculer_moyenne([10, 12, 14, 16])
        13.0
    """
    if not liste_notes:
        return 0.0

    return sum(liste_notes) / len(liste_notes)

def obtenir_mention(moyenne):
    """
    D√©termine la mention selon la moyenne.

    Args:
        moyenne (float): Moyenne des notes

    Returns:
        str: Mention correspondante

    Example:
        >>> obtenir_mention(15.5)
        'Bien'
    """
    if moyenne >= 16:
        return "Tr√®s bien"
    elif moyenne >= 14:
        return "Bien"
    elif moyenne >= 12:
        return "Assez bien"
    elif moyenne >= 10:
        return "Passable"
    else:
        return "Insuffisant"

def nombre_notes_superieures(liste_notes, seuil):
    """
    Compte les notes sup√©rieures √† un seuil.

    Args:
        liste_notes (list): Liste des notes
        seuil (float): Seuil de comparaison

    Returns:
        int: Nombre de notes sup√©rieures au seuil

    Example:
        >>> nombre_notes_superieures([8, 12, 15, 18], 10)
        3
    """
    compteur = 0
    for note in liste_notes:
        if note > seuil:
            compteur += 1
    return compteur

def obtenir_note_minimale(liste_notes):
    """
    Trouve la note minimale.

    Args:
        liste_notes (list): Liste des notes

    Returns:
        float: Note minimale ou None si liste vide
    """
    if not liste_notes:
        return None
    return min(liste_notes)

def obtenir_note_maximale(liste_notes):
    """
    Trouve la note maximale.

    Args:
        liste_notes (list): Liste des notes

    Returns:
        float: Note maximale ou None si liste vide
    """
    if not liste_notes:
        return None
    return max(liste_notes)

def calculer_mediane(liste_notes):
    """
    Calcule la m√©diane des notes.

    Args:
        liste_notes (list): Liste des notes

    Returns:
        float: M√©diane ou None si liste vide
    """
    if not liste_notes:
        return None

    notes_triees = sorted(liste_notes)
    n = len(notes_triees)

    if n % 2 == 0:
        # Nombre pair d'√©l√©ments
        milieu1 = notes_triees[n//2 - 1]
        milieu2 = notes_triees[n//2]
        return (milieu1 + milieu2) / 2
    else:
        # Nombre impair d'√©l√©ments
        return notes_triees[n//2]

def calculer_ecart_type(liste_notes):
    """
    Calcule l'√©cart-type des notes.

    Args:
        liste_notes (list): Liste des notes

    Returns:
        float: √âcart-type ou None si liste vide
    """
    if not liste_notes:
        return None

    moyenne = calculer_moyenne(liste_notes)

    # Calcul de la variance
    somme_carres_ecarts = 0
    for note in liste_notes:
        ecart = note - moyenne
        somme_carres_ecarts += ecart ** 2

    variance = somme_carres_ecarts / len(liste_notes)
    ecart_type = variance ** 0.5

    return ecart_type

def repartition_par_mention(liste_notes):
    """
    Calcule la r√©partition des notes par mention.

    Args:
        liste_notes (list): Liste des notes

    Returns:
        dict: Dictionnaire avec le nombre de notes par mention
    """
    repartition = {
        "Tr√®s bien": 0,
        "Bien": 0,
        "Assez bien": 0,
        "Passable": 0,
        "Insuffisant": 0
    }

    for note in liste_notes:
        mention = obtenir_mention(note)
        repartition[mention] += 1

    return repartition

def afficher_statistiques(liste_notes):
    """
    Affiche toutes les statistiques des notes.

    Args:
        liste_notes (list): Liste des notes
    """
    if not liste_notes:
        print("üì≠ Aucune note enregistr√©e")
        return

    print(f"\nüìä === STATISTIQUES DES NOTES ===")
    print(f"Nombre de notes : {len(liste_notes)}")

    # Statistiques de base
    moyenne = calculer_moyenne(liste_notes)
    mention = obtenir_mention(moyenne)
    note_min = obtenir_note_minimale(liste_notes)
    note_max = obtenir_note_maximale(liste_notes)
    mediane = calculer_mediane(liste_notes)
    ecart_type = calculer_ecart_type(liste_notes)

    print(f"\nüìà Mesures centrales :")
    print(f"   ‚Ä¢ Moyenne : {moyenne:.2f}/20")
    print(f"   ‚Ä¢ Mention : {mention}")
    print(f"   ‚Ä¢ M√©diane : {mediane:.2f}/20")

    print(f"\nüìè Mesures de dispersion :")
    print(f"   ‚Ä¢ Note minimale : {note_min}/20")
    print(f"   ‚Ä¢ Note maximale : {note_max}/20")
    print(f"   ‚Ä¢ √âtendue : {note_max - note_min:.2f} points")
    print(f"   ‚Ä¢ √âcart-type : {ecart_type:.2f}")

    # R√©partition par mention
    repartition = repartition_par_mention(liste_notes)
    print(f"\nüéñÔ∏è R√©partition par mention :")
    for mention, nombre in repartition.items():
        pourcentage = (nombre / len(liste_notes)) * 100
        print(f"   ‚Ä¢ {mention:<12} : {nombre:2d} note(s) ({pourcentage:5.1f}%)")

    # Seuils d'analyse
    print(f"\nüéØ Analyse par seuils :")
    seuils = [10, 12, 14, 16, 18]
    for seuil in seuils:
        nb_superieures = nombre_notes_superieures(liste_notes, seuil)
        pourcentage = (nb_superieures / len(liste_notes)) * 100
        print(f"   ‚Ä¢ Notes > {seuil:2d}/20 : {nb_superieures:2d} ({pourcentage:5.1f}%)")

def afficher_notes(liste_notes):
    """
    Affiche toutes les notes avec leur rang.

    Args:
        liste_notes (list): Liste des notes
    """
    if not liste_notes:
        print("üì≠ Aucune note √† afficher")
        return

    print(f"\nüìã === LISTE DES NOTES ===")

    # Affichage simple
    print(f"Notes saisies ({len(liste_notes)} note(s)) :")
    for i, note in enumerate(liste_notes, 1):
        mention = obtenir_mention(note)
        print(f"   {i:2d}. {note:5.2f}/20 - {mention}")

    # Affichage tri√©
    print(f"\nNotes tri√©es (d√©croissant) :")
    notes_triees = sorted(liste_notes, reverse=True)
    for i, note in enumerate(notes_triees, 1):
        mention = obtenir_mention(note)
        print(f"   {i:2d}. {note:5.2f}/20 - {mention}")

def supprimer_note(liste_notes, index):
    """
    Supprime une note √† un index donn√©.

    Args:
        liste_notes (list): Liste des notes
        index (int): Index de la note √† supprimer (base 1)

    Returns:
        bool: True si suppression r√©ussie, False sinon
    """
    if index < 1 or index > len(liste_notes):
        return False

    # Convertir en index base 0
    liste_notes.pop(index - 1)
    return True

def modifier_note(liste_notes, index, nouvelle_note):
    """
    Modifie une note √† un index donn√©.

    Args:
        liste_notes (list): Liste des notes
        index (int): Index de la note √† modifier (base 1)
        nouvelle_note (float): Nouvelle valeur de la note

    Returns:
        bool: True si modification r√©ussie, False sinon
    """
    if index < 1 or index > len(liste_notes):
        return False

    if nouvelle_note < 0 or nouvelle_note > 20:
        return False

    # Convertir en index base 0
    liste_notes[index - 1] = nouvelle_note
    return True

def saisir_note():
    """
    Saisit une note avec validation.

    Returns:
        float: Note saisie ou None si annul√©e
    """
    while True:
        try:
            entree = input("Entrez une note (0-20) : ")
            note = float(entree)

            if note < 0 or note > 20:
                print("‚ùå La note doit √™tre entre 0 et 20")
                continue

            return note

        except ValueError:
            print("‚ùå Veuillez entrer un nombre valide")

        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Saisie annul√©e")
            return None

def saisir_plusieurs_notes(liste_notes):
    """
    Saisit plusieurs notes d'affil√©e.

    Args:
        liste_notes (list): Liste o√π ajouter les notes
    """
    print("\nüìù === SAISIE MULTIPLE DE NOTES ===")
    print("Entrez les notes une par une (tapez 'fin' pour terminer)")

    notes_ajoutees = 0

    while True:
        try:
            entree = input(f"Note {notes_ajoutees + 1} : ").strip()

            if entree.lower() in ['fin', 'stop', 'exit', 'q']:
                break

            note = float(entree)

            if ajouter_note(liste_notes, note):
                notes_ajoutees += 1
                print(f"‚úÖ Note {note} ajout√©e")
            else:
                print(f"‚ùå Note invalide (doit √™tre entre 0 et 20)")

        except ValueError:
            print("‚ùå Veuillez entrer un nombre valide ou 'fin'")

        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Saisie interrompue")
            break

    print(f"\n‚úÖ {notes_ajoutees} note(s) ajout√©e(s)")

def analyser_progression(liste_notes):
    """
    Analyse la progression des notes dans l'ordre de saisie.

    Args:
        liste_notes (list): Liste des notes
    """
    if len(liste_notes) < 2:
        print("‚ùå Il faut au moins 2 notes pour analyser la progression")
        return

    print(f"\nüìà === ANALYSE DE PROGRESSION ===")

    # Calcul des tendances
    ameliorations = 0
    degradations = 0
    stagnations = 0

    for i in range(1, len(liste_notes)):
        if liste_notes[i] > liste_notes[i-1]:
            ameliorations += 1
        elif liste_notes[i] < liste_notes[i-1]:
            degradations += 1
        else:
            stagnations += 1

    print(f"√âvolution des notes :")
    print(f"   ‚Ä¢ Am√©liorations : {ameliorations}")
    print(f"   ‚Ä¢ D√©gradations : {degradations}")
    print(f"   ‚Ä¢ Stagnations : {stagnations}")

    # Comparaison premi√®re moiti√© vs seconde moiti√©
    milieu = len(liste_notes) // 2
    premiere_moitie = liste_notes[:milieu]
    seconde_moitie = liste_notes[milieu:]

    if premiere_moitie and seconde_moitie:
        moy_debut = calculer_moyenne(premiere_moitie)
        moy_fin = calculer_moyenne(seconde_moitie)

        print(f"\nComparaison d√©but/fin :")
        print(f"   ‚Ä¢ Moyenne d√©but : {moy_debut:.2f}/20")
        print(f"   ‚Ä¢ Moyenne fin : {moy_fin:.2f}/20")
        print(f"   ‚Ä¢ √âvolution : {moy_fin - moy_debut:+.2f} points")

    # Plus grande progression/r√©gression
    if len(liste_notes) >= 2:
        max_progression = 0
        max_regression = 0

        for i in range(1, len(liste_notes)):
            diff = liste_notes[i] - liste_notes[i-1]
            if diff > max_progression:
                max_progression = diff
            if diff < max_regression:
                max_regression = diff

        print(f"\nRecords :")
        print(f"   ‚Ä¢ Plus grande progression : +{max_progression:.2f} points")
        print(f"   ‚Ä¢ Plus grande r√©gression : {max_regression:.2f} points")

def simuler_notes_aleatoires(liste_notes, nombre):
    """
    G√©n√®re des notes al√©atoires pour tester le syst√®me.

    Args:
        liste_notes (list): Liste o√π ajouter les notes
        nombre (int): Nombre de notes √† g√©n√©rer
    """
    import random

    print(f"\nüé≤ G√©n√©ration de {nombre} notes al√©atoires...")

    for i in range(nombre):
        # G√©n√©ration avec une distribution plus r√©aliste
        # Favorise les notes moyennes (10-16)
        if random.random() < 0.7:  # 70% de notes moyennes
            note = random.uniform(8, 16)
        else:  # 30% de notes extr√™mes
            if random.random() < 0.5:
                note = random.uniform(0, 8)   # Notes faibles
            else:
                note = random.uniform(16, 20) # Tr√®s bonnes notes

        note = round(note, 1)  # Arrondir √† 1 d√©cimale
        ajouter_note(liste_notes, note)

    print(f"‚úÖ {nombre} notes g√©n√©r√©es et ajout√©es")

def exporter_notes(liste_notes, nom_fichier="notes.txt"):
    """
    Exporte les notes dans un fichier texte.

    Args:
        liste_notes (list): Liste des notes
        nom_fichier (str): Nom du fichier d'export

    Returns:
        bool: True si export r√©ussi, False sinon
    """
    if not liste_notes:
        print("‚ùå Aucune note √† exporter")
        return False

    try:
        with open(nom_fichier, 'w', encoding='utf-8') as f:
            f.write("# EXPORT DES NOTES\n")
            f.write(f"# Date d'export : {__import__('datetime').datetime.now()}\n")
            f.write(f"# Nombre de notes : {len(liste_notes)}\n\n")

            f.write("=== LISTE DES NOTES ===\n")
            for i, note in enumerate(liste_notes, 1):
                mention = obtenir_mention(note)
                f.write(f"{i:2d}. {note:5.2f}/20 - {mention}\n")

            f.write(f"\n=== STATISTIQUES ===\n")
            moyenne = calculer_moyenne(liste_notes)
            mention_moy = obtenir_mention(moyenne)
            f.write(f"Moyenne : {moyenne:.2f}/20 - {mention_moy}\n")
            f.write(f"Note minimale : {obtenir_note_minimale(liste_notes)}/20\n")
            f.write(f"Note maximale : {obtenir_note_maximale(liste_notes)}/20\n")
            f.write(f"M√©diane : {calculer_mediane(liste_notes):.2f}/20\n")
            f.write(f"√âcart-type : {calculer_ecart_type(liste_notes):.2f}\n")

            f.write(f"\n=== R√âPARTITION PAR MENTION ===\n")
            repartition = repartition_par_mention(liste_notes)
            for mention, nombre in repartition.items():
                pourcentage = (nombre / len(liste_notes)) * 100
                f.write(f"{mention:<12} : {nombre:2d} ({pourcentage:5.1f}%)\n")

        print(f"‚úÖ Notes export√©es vers '{nom_fichier}'")
        return True

    except Exception as e:
        print(f"‚ùå Erreur lors de l'export : {e}")
        return False

def menu_gestion_notes(liste_notes):
    """
    Menu pour la gestion des notes individuelles.

    Args:
        liste_notes (list): Liste des notes
    """
    while True:
        print(f"\nüìù === GESTION DES NOTES ===")
        print("1. ‚ûï Ajouter une note")
        print("2. ‚ûï Ajouter plusieurs notes")
        print("3. üìã Afficher les notes")
        print("4. ‚úèÔ∏è  Modifier une note")
        print("5. üóëÔ∏è  Supprimer une note")
        print("6. üé≤ G√©n√©rer notes al√©atoires (test)")
        print("7. üîô Retour au menu principal")

        choix = input("\nVotre choix (1-7) : ").strip()

        if choix == "1":
            note = saisir_note()
            if note is not None:
                if ajouter_note(liste_notes, note):
                    print(f"‚úÖ Note {note} ajout√©e avec succ√®s")
                else:
                    print("‚ùå Erreur lors de l'ajout de la note")

        elif choix == "2":
            saisir_plusieurs_notes(liste_notes)

        elif choix == "3":
            afficher_notes(liste_notes)

        elif choix == "4":
            if not liste_notes:
                print("‚ùå Aucune note √† modifier")
                continue

            afficher_notes(liste_notes)
            try:
                index = int(input("\nNum√©ro de la note √† modifier : "))
                nouvelle_note = saisir_note()
                if nouvelle_note is not None:
                    if modifier_note(liste_notes, index, nouvelle_note):
                        print(f"‚úÖ Note modifi√©e avec succ√®s")
                    else:
                        print("‚ùå Index invalide ou note invalide")
            except ValueError:
                print("‚ùå Veuillez entrer un num√©ro valide")

        elif choix == "5":
            if not liste_notes:
                print("‚ùå Aucune note √† supprimer")
                continue

            afficher_notes(liste_notes)
            try:
                index = int(input("\nNum√©ro de la note √† supprimer : "))
                if supprimer_note(liste_notes, index):
                    print(f"‚úÖ Note supprim√©e avec succ√®s")
                else:
                    print("‚ùå Index invalide")
            except ValueError:
                print("‚ùå Veuillez entrer un num√©ro valide")

        elif choix == "6":
            try:
                nombre = int(input("Nombre de notes √† g√©n√©rer (1-50) : "))
                if 1 <= nombre <= 50:
                    simuler_notes_aleatoires(liste_notes, nombre)
                else:
                    print("‚ùå Nombre invalide (1-50)")
            except ValueError:
                print("‚ùå Veuillez entrer un nombre valide")

        elif choix == "7":
            break

        else:
            print("‚ùå Choix invalide")

def main():
    """Programme principal du syst√®me de notes."""
    print("üìö === SYST√àME DE GESTION DE NOTES ===")
    print("Outil complet pour g√©rer et analyser des notes d'√©tudiants")

    notes = []  # Liste pour stocker les notes

    while True:
        print(f"\n" + "‚ïê" * 60)
        print(f"üìö MENU PRINCIPAL ({len(notes)} note(s))".center(60))
        print("‚ïê" * 60)
        print("1. üìù Gestion des notes")
        print("2. üìä Afficher les statistiques")
        print("3. üìà Analyser la progression")
        print("4. üéØ Analyser par seuil personnalis√©")
        print("5. üíæ Exporter les notes")
        print("6. üß™ Tester les fonctions")
        print("7. ‚ùå Quitter")

        choix = input("\nVotre choix (1-7) : ").strip()

        try:
            if choix == "1":
                menu_gestion_notes(notes)

            elif choix == "2":
                afficher_statistiques(notes)

            elif choix == "3":
                analyser_progression(notes)

            elif choix == "4":
                if not notes:
                    print("‚ùå Aucune note pour l'analyse")
                    continue

                try:
                    seuil = float(input("Entrez un seuil (0-20) : "))
                    if 0 <= seuil <= 20:
                        nb_sup = nombre_notes_superieures(notes, seuil)
                        pourcentage = (nb_sup / len(notes)) * 100
                        print(f"\nüéØ Analyse pour le seuil {seuil}/20 :")
                        print(f"   ‚Ä¢ Notes sup√©rieures : {nb_sup}/{len(notes)} ({pourcentage:.1f}%)")
                        print(f"   ‚Ä¢ Notes inf√©rieures ou √©gales : {len(notes) - nb_sup}/{len(notes)} ({100 - pourcentage:.1f}%)")
                    else:
                        print("‚ùå Seuil invalide (0-20)")
                except ValueError:
                    print("‚ùå Veuillez entrer un nombre valide")

            elif choix == "5":
                if notes:
                    nom_fichier = input("Nom du fichier (d√©faut: notes.txt) : ").strip()
                    if not nom_fichier:
                        nom_fichier = "notes.txt"
                    exporter_notes(notes, nom_fichier)
                else:
                    print("‚ùå Aucune note √† exporter")

            elif choix == "6":
                tester_fonctions_notes()

            elif choix == "7":
                if notes:
                    print(f"\nüìã R√©sum√© de la session :")
                    moyenne = calculer_moyenne(notes)
                    mention = obtenir_mention(moyenne)
                    print(f"   ‚Ä¢ {len(notes)} note(s) g√©r√©e(s)")
                    print(f"   ‚Ä¢ Moyenne g√©n√©rale : {moyenne:.2f}/20 ({mention})")

                print("\nüìö Merci d'avoir utilis√© le syst√®me de notes !")
                print("Bonne continuation dans vos √©tudes ! üéì")
                break

            else:
                print("‚ùå Choix invalide. Veuillez entrer un nombre entre 1 et 7.")

        except KeyboardInterrupt:
            print(f"\n\n‚èπÔ∏è Programme interrompu par l'utilisateur")
            if notes:
                print(f"üìö {len(notes)} note(s) dans la session")
            print("üëã Au revoir !")
            break

        except Exception as e:
            print(f"‚ùå Erreur inattendue : {e}")
            print("üîÑ Retour au menu principal...")

def tester_fonctions_notes():
    """Teste toutes les fonctions du syst√®me avec des exemples."""
    print(f"\nüß™ === TEST DES FONCTIONS ===")

    # Cr√©ation d'un jeu de test
    notes_test = [8.5, 12.0, 15.5, 17.0, 10.5, 14.0, 9.0, 16.5, 11.0, 13.5]

    print(f"Notes de test : {notes_test}")

    # Test des fonctions statistiques
    moyenne = calculer_moyenne(notes_test)
    mention = obtenir_mention(moyenne)
    note_min = obtenir_note_minimale(notes_test)
    note_max = obtenir_note_maximale(notes_test)
    mediane = calculer_mediane(notes_test)
    ecart_type = calculer_ecart_type(notes_test)

    print(f"\nüìä R√©sultats des fonctions :")
    print(f"   ‚Ä¢ calculer_moyenne() ‚Üí {moyenne:.2f}")
    print(f"   ‚Ä¢ obtenir_mention() ‚Üí {mention}")
    print(f"   ‚Ä¢ obtenir_note_minimale() ‚Üí {note_min}")
    print(f"   ‚Ä¢ obtenir_note_maximale() ‚Üí {note_max}")
    print(f"   ‚Ä¢ calculer_mediane() ‚Üí {mediane:.2f}")
    print(f"   ‚Ä¢ calculer_ecart_type() ‚Üí {ecart_type:.2f}")

    # Test de la fonction de comptage
    seuils_test = [10, 12, 15]
    for seuil in seuils_test:
        nb_sup = nombre_notes_superieures(notes_test, seuil)
        print(f"   ‚Ä¢ nombre_notes_superieures({seuil}) ‚Üí {nb_sup}")

    # Test de la r√©partition
    repartition = repartition_par_mention(notes_test)
    print(f"\nüéñÔ∏è R√©partition par mention :")
    for mention, nb in repartition.items():
        print(f"   ‚Ä¢ {mention} : {nb}")

if __name__ == "__main__":
    main()
```

## Tests √† effectuer

### Tests des fonctions de base
1. **Gestion des notes** :
   - Ajout de notes valides et invalides
   - Modification et suppression de notes
   - Calculs de moyenne, m√©diane, √©cart-type

2. **Mentions** :
   - 18/20 ‚Üí "Tr√®s bien"
   - 15/20 ‚Üí "Bien"
   - 13/20 ‚Üí "Assez bien"
   - 11/20 ‚Üí "Passable"
   - 8/20 ‚Üí "Insuffisant"

3. **Statistiques** :
   - Notes vides, une note, plusieurs notes
   - Calculs sur notes identiques
   - Progression temporelle

### Tests du syst√®me complet
- Menu de gestion avec toutes les options
- Export vers fichier
- G√©n√©ration de notes al√©atoires
- Analyse de progression

## Concepts abord√©s

### 1. Manipulation de listes
```python
def ajouter_note(liste_notes, note):
    liste_notes.append(note)
    return True
```

### 2. Calculs statistiques
```python
def calculer_moyenne(liste_notes):
    return sum(liste_notes) / len(liste_notes)
```

### 3. Fonctions de tri et recherche
```python
def obtenir_note_maximale(liste_notes):
    return max(liste_notes)
```

### 4. Structures de donn√©es
- Listes pour stocker les notes
- Dictionnaires pour les r√©partitions

### 5. Validation et gestion d'erreurs
- V√©rification des plages de valeurs
- Gestion des listes vides

## Crit√®res d'√©valuation

- ‚úÖ **Fonctions de gestion correctes** : Ajout, suppression, modification
- ‚úÖ **Calculs statistiques pr√©cis** : Moyenne, m√©diane, √©cart-type
- ‚úÖ **Syst√®me de mentions** : Bar√®me fran√ßais respect√©
- ‚úÖ **Interface compl√®te** : Menu riche et navigation fluide
- ‚úÖ **Gestion des cas limites** : Listes vides, valeurs extr√™mes
- ‚úÖ **Fonctionnalit√©s avanc√©es** : Export, progression, g√©n√©ration
- ‚úÖ **Code modulaire** : S√©paration des responsabilit√©s

## Extensions possibles

- Support de coefficients pour les notes
- Calcul de moyennes pond√©r√©es
- Graphiques de progression
- Import de notes depuis fichier CSV
- Gestion de plusieurs mati√®res
- Interface graphique avec des diagrammes
