# Exercice 4 : Validateur de formulaire

## Objectif

Cr√©er un syst√®me de validation de formulaire qui collecte et valide des donn√©es utilisateur avec gestion compl√®te des erreurs.

## Cahier des charges

1. **Demander** nom, email, √¢ge, code postal
2. **Valider chaque champ** avec des r√®gles sp√©cifiques
3. **Collecter toutes les erreurs** avant de les afficher
4. **Permettre de corriger** champ par champ
5. **Sauvegarder** les donn√©es valides dans un fichier texte

## Code de base √† compl√©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 4 : Validateur de formulaire
Module 1.5 - Gestion des erreurs avec try/except
"""

def valider_nom(nom):
    """
    Valide un nom.

    Args:
        nom (str): Nom √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: Impl√©menter la validation
    pass

def valider_email(email):
    """
    Valide une adresse email.

    Args:
        email (str): Email √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: Impl√©menter la validation
    pass

def valider_age(age):
    """
    Valide un √¢ge.

    Args:
        age (str): √Çge √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: Impl√©menter la validation
    pass

def valider_code_postal(code):
    """
    Valide un code postal fran√ßais.

    Args:
        code (str): Code postal √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: Impl√©menter la validation
    pass

def main():
    """Fonction principale du validateur."""
    print("üìã === VALIDATEUR DE FORMULAIRE ===")

    while True:
        try:
            # TODO: Impl√©menter la logique principale
            pass

        except KeyboardInterrupt:
            # TODO: G√©rer l'interruption clavier
            pass

if __name__ == "__main__":
    main()
```

## Solution compl√®te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 4 : Validateur de formulaire - SOLUTION
Module 1.5 - Gestion des erreurs avec try/except
"""

import re
import os
from datetime import datetime

def valider_nom(nom):
    """
    Valide un nom.

    Args:
        nom (str): Nom √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(nom, str):
            erreurs.append("Le nom doit √™tre une cha√Æne de caract√®res")
            return False, erreurs

        nom_propre = nom.strip()

        # V√©rifications
        if not nom_propre:
            erreurs.append("Le nom ne peut pas √™tre vide")

        if len(nom_propre) < 2:
            erreurs.append("Le nom doit contenir au moins 2 caract√®res")

        if len(nom_propre) > 50:
            erreurs.append("Le nom ne peut pas d√©passer 50 caract√®res")

        # V√©rifier qu'il ne contient que des lettres et espaces
        if not re.match(r'^[a-zA-Z√Ä-√ø\s\'-]+$', nom_propre):
            erreurs.append("Le nom ne peut contenir que des lettres, espaces, apostrophes et tirets")

        # V√©rifier qu'il ne commence/finit pas par un espace
        if nom_propre != nom_propre.strip():
            erreurs.append("Le nom ne peut pas commencer ou finir par un espace")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def valider_email(email):
    """
    Valide une adresse email.

    Args:
        email (str): Email √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(email, str):
            erreurs.append("L'email doit √™tre une cha√Æne de caract√®res")
            return False, erreurs

        email_propre = email.strip().lower()

        # V√©rifications de base
        if not email_propre:
            erreurs.append("L'email ne peut pas √™tre vide")
            return False, erreurs

        if len(email_propre) > 254:
            erreurs.append("L'email ne peut pas d√©passer 254 caract√®res")

        # V√©rifier la pr√©sence d'un @
        if '@' not in email_propre:
            erreurs.append("L'email doit contenir un @")
        elif email_propre.count('@') != 1:
            erreurs.append("L'email ne doit contenir qu'un seul @")
        else:
            # S√©parer partie locale et domaine
            partie_locale, domaine = email_propre.split('@')

            # Validation partie locale
            if not partie_locale:
                erreurs.append("La partie avant @ ne peut pas √™tre vide")
            elif len(partie_locale) > 64:
                erreurs.append("La partie avant @ ne peut pas d√©passer 64 caract√®res")
            elif not re.match(r'^[a-zA-Z0-9._-]+$', partie_locale):
                erreurs.append("La partie avant @ contient des caract√®res invalides")
            elif partie_locale.startswith('.') or partie_locale.endswith('.'):
                erreurs.append("La partie avant @ ne peut pas commencer ou finir par un point")
            elif '..' in partie_locale:
                erreurs.append("La partie avant @ ne peut pas contenir deux points cons√©cutifs")

            # Validation domaine
            if not domaine:
                erreurs.append("Le domaine ne peut pas √™tre vide")
            elif len(domaine) > 253:
                erreurs.append("Le domaine ne peut pas d√©passer 253 caract√®res")
            elif '.' not in domaine:
                erreurs.append("Le domaine doit contenir au moins un point")
            elif not re.match(r'^[a-zA-Z0-9.-]+$', domaine):
                erreurs.append("Le domaine contient des caract√®res invalides")
            elif domaine.startswith('.') or domaine.endswith('.'):
                erreurs.append("Le domaine ne peut pas commencer ou finir par un point")
            elif '..' in domaine:
                erreurs.append("Le domaine ne peut pas contenir deux points cons√©cutifs")
            else:
                # V√©rifier l'extension
                parties_domaine = domaine.split('.')
                if len(parties_domaine[-1]) < 2:
                    erreurs.append("L'extension du domaine doit contenir au moins 2 caract√®res")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def valider_age(age):
    """
    Valide un √¢ge.

    Args:
        age (str): √Çge √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(age, str):
            erreurs.append("L'√¢ge doit √™tre fourni comme une cha√Æne")
            return False, erreurs

        age_propre = age.strip()

        if not age_propre:
            erreurs.append("L'√¢ge ne peut pas √™tre vide")
            return False, erreurs

        # Tentative de conversion
        try:
            age_int = int(age_propre)
        except ValueError:
            erreurs.append("L'√¢ge doit √™tre un nombre entier")
            return False, erreurs

        # V√©rifications de plausibilit√©
        if age_int < 0:
            erreurs.append("L'√¢ge ne peut pas √™tre n√©gatif")

        if age_int > 150:
            erreurs.append("L'√¢ge ne peut pas d√©passer 150 ans")

        if age_int == 0:
            erreurs.append("L'√¢ge ne peut pas √™tre 0 (utilisez l'√¢ge en ann√©es r√©volues)")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def valider_code_postal(code):
    """
    Valide un code postal fran√ßais.

    Args:
        code (str): Code postal √† valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(code, str):
            erreurs.append("Le code postal doit √™tre une cha√Æne de caract√®res")
            return False, erreurs

        code_propre = code.strip()

        if not code_propre:
            erreurs.append("Le code postal ne peut pas √™tre vide")
            return False, erreurs

        # Format fran√ßais : 5 chiffres
        if not re.match(r'^\d{5}$', code_propre):
            erreurs.append("Le code postal doit contenir exactement 5 chiffres")
        else:
            # V√©rifications de plausibilit√© pour la France m√©tropolitaine et DOM-TOM
            premier_chiffre = int(code_propre[0])
            deux_premiers = int(code_propre[:2])

            # France m√©tropolitaine : 01000 √† 95999
            # DOM-TOM : 97000-97999, 98000-98999
            if not (1 <= deux_premiers <= 95 or 970 <= int(code_propre[:3]) <= 989):
                erreurs.append("Code postal fran√ßais invalide")

            # Cas sp√©ciaux
            if code_propre == "00000":
                erreurs.append("Le code postal ne peut pas √™tre 00000")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def saisir_donnees():
    """
    Saisit les donn√©es du formulaire.

    Returns:
        dict: Dictionnaire avec les donn√©es saisies
    """
    print("\nüìù === SAISIE DES DONN√âES ===")

    donnees = {}

    try:
        donnees['nom'] = input("Nom complet : ").strip()
        donnees['email'] = input("Adresse email : ").strip()
        donnees['age'] = input("√Çge : ").strip()
        donnees['code_postal'] = input("Code postal : ").strip()

        return donnees

    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Saisie annul√©e")
        return None

def valider_formulaire(donnees):
    """
    Valide toutes les donn√©es du formulaire.

    Args:
        donnees (dict): Donn√©es √† valider

    Returns:
        tuple: (est_valide, erreurs_par_champ)
    """
    erreurs_par_champ = {}

    # Validation de chaque champ
    nom_valide, erreurs_nom = valider_nom(donnees.get('nom', ''))
    if not nom_valide:
        erreurs_par_champ['nom'] = erreurs_nom

    email_valide, erreurs_email = valider_email(donnees.get('email', ''))
    if not email_valide:
        erreurs_par_champ['email'] = erreurs_email

    age_valide, erreurs_age = valider_age(donnees.get('age', ''))
    if not age_valide:
        erreurs_par_champ['age'] = erreurs_age

    code_valide, erreurs_code = valider_code_postal(donnees.get('code_postal', ''))
    if not code_valide:
        erreurs_par_champ['code_postal'] = erreurs_code

    return len(erreurs_par_champ) == 0, erreurs_par_champ

def afficher_erreurs(erreurs_par_champ):
    """
    Affiche les erreurs de validation de mani√®re organis√©e.

    Args:
        erreurs_par_champ (dict): Erreurs group√©es par champ
    """
    print(f"\n‚ùå Erreurs de validation d√©tect√©es :")
    print("‚ïê" * 60)

    for champ, erreurs in erreurs_par_champ.items():
        nom_champ = {
            'nom': 'Nom',
            'email': 'Email',
            'age': '√Çge',
            'code_postal': 'Code postal'
        }.get(champ, champ)

        print(f"\nüî∏ {nom_champ} :")
        for erreur in erreurs:
            print(f"   ‚Ä¢ {erreur}")

    print("‚ïê" * 60)

def corriger_champ(donnees, nom_champ):
    """
    Permet de corriger un champ sp√©cifique.

    Args:
        donnees (dict): Donn√©es actuelles
        nom_champ (str): Nom du champ √† corriger

    Returns:
        bool: True si correction effectu√©e, False si annul√©e
    """
    try:
        noms_champs = {
            'nom': 'Nom complet',
            'email': 'Adresse email',
            'age': '√Çge',
            'code_postal': 'Code postal'
        }

        nom_affichage = noms_champs.get(nom_champ, nom_champ)
        valeur_actuelle = donnees.get(nom_champ, '')

        print(f"\n‚úèÔ∏è Correction du champ '{nom_affichage}'")
        print(f"   Valeur actuelle : '{valeur_actuelle}'")

        nouvelle_valeur = input(f"   Nouvelle valeur : ").strip()
        donnees[nom_champ] = nouvelle_valeur

        print(f"‚úÖ Champ '{nom_affichage}' mis √† jour")
        return True

    except KeyboardInterrupt:
        print(f"\n‚èπÔ∏è Correction du champ '{nom_champ}' annul√©e")
        return False

def sauvegarder_donnees(donnees, nom_fichier="formulaires.txt"):
    """
    Sauvegarde les donn√©es valid√©es dans un fichier.

    Args:
        donnees (dict): Donn√©es √† sauvegarder
        nom_fichier (str): Nom du fichier de sauvegarde

    Returns:
        bool: True si sauvegarde r√©ussie
    """
    try:
        # Cr√©er l'en-t√™te si le fichier n'existe pas
        if not os.path.exists(nom_fichier):
            with open(nom_fichier, 'w', encoding='utf-8') as f:
                f.write("# FORMULAIRES VALID√âS\n")
                f.write("# Format : NOM|EMAIL|AGE|CODE_POSTAL|DATE\n")
                f.write("# " + "‚îÄ" * 50 + "\n\n")

        # Ajouter les nouvelles donn√©es
        with open(nom_fichier, 'a', encoding='utf-8') as f:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            ligne = f"{donnees['nom']}|{donnees['email']}|{donnees['age']}|{donnees['code_postal']}|{timestamp}\n"
            f.write(ligne)

        print(f"üíæ Donn√©es sauvegard√©es dans '{nom_fichier}'")
        return True

    except PermissionError:
        print(f"‚ùå Erreur : Pas de permission d'√©criture pour '{nom_fichier}'")
        return False

    except Exception as e:
        print(f"‚ùå Erreur lors de la sauvegarde : {e}")
        return False

def afficher_donnees_valides(donnees):
    """
    Affiche les donn√©es valid√©es de mani√®re format√©e.

    Args:
        donnees (dict): Donn√©es valid√©es
    """
    print(f"\n‚úÖ === DONN√âES VALID√âES ===")
    print("‚ïê" * 40)
    print(f"üë§ Nom          : {donnees['nom']}")
    print(f"üìß Email        : {donnees['email']}")
    print(f"üéÇ √Çge          : {donnees['age']} ans")
    print(f"üìÆ Code postal  : {donnees['code_postal']}")
    print("‚ïê" * 40)

    # Informations d√©riv√©es
    age_int = int(donnees['age'])
    if age_int >= 18:
        print(f"‚ÑπÔ∏è  Statut : Majeur")
    else:
        print(f"‚ÑπÔ∏è  Statut : Mineur")

    # R√©gion approximative bas√©e sur le code postal
    code = donnees['code_postal']
    if code.startswith('75'):
        region = "Paris"
    elif code.startswith('13'):
        region = "Bouches-du-Rh√¥ne"
    elif code.startswith('69'):
        region = "Rh√¥ne"
    elif code.startswith('59'):
        region = "Nord"
    elif code.startswith('97'):
        region = "DOM-TOM"
    else:
        region = f"D√©partement {code[:2]}"

    print(f"üìç R√©gion : {region}")

def lire_fichier_donnees(nom_fichier="formulaires.txt"):
    """
    Lit et affiche les donn√©es sauvegard√©es.

    Args:
        nom_fichier (str): Nom du fichier √† lire
    """
    try:
        if not os.path.exists(nom_fichier):
            print(f"üìÑ Le fichier '{nom_fichier}' n'existe pas encore")
            return

        with open(nom_fichier, 'r', encoding='utf-8') as f:
            lignes = f.readlines()

        # Filtrer les lignes de donn√©es (ignorer les commentaires)
        donnees_lignes = [ligne.strip() for ligne in lignes
                         if ligne.strip() and not ligne.startswith('#')]

        if not donnees_lignes:
            print(f"üì≠ Aucune donn√©e dans le fichier '{nom_fichier}'")
            return

        print(f"\nüìö Donn√©es sauvegard√©es ({len(donnees_lignes)} entr√©e(s)) :")
        print("‚ïê" * 80)

        for i, ligne in enumerate(donnees_lignes, 1):
            try:
                parties = ligne.split('|')
                if len(parties) >= 5:
                    nom, email, age, code_postal, date = parties[:5]
                    print(f"{i:2d}. üë§ {nom}")
                    print(f"     üìß {email}")
                    print(f"     üéÇ {age} ans | üìÆ {code_postal}")
                    print(f"     üìÖ Sauvegard√© le {date}")
                    print()
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur lors de la lecture de la ligne {i} : {e}")

        print("‚ïê" * 80)

    except PermissionError:
        print(f"‚ùå Erreur : Pas de permission de lecture pour '{nom_fichier}'")

    except Exception as e:
        print(f"‚ùå Erreur lors de la lecture : {e}")

def main():
    """Fonction principale du validateur."""
    print("üìã === VALIDATEUR DE FORMULAIRE ===")
    print("Syst√®me de validation de donn√©es utilisateur avec gestion d'erreurs")

    while True:
        try:
            print("\n" + "‚îÄ" * 60)
            print("1. üìù Saisir et valider un nouveau formulaire")
            print("2. üìö Afficher les formulaires sauvegard√©s")
            print("3. ‚ùå Quitter")

            choix = input("\nVotre choix (1-3) : ").strip()

            if choix == "1":
                # Saisie des donn√©es
                donnees = saisir_donnees()
                if donnees is None:
                    continue

                # Validation initiale
                print(f"\nüîç Validation des donn√©es en cours...")
                est_valide, erreurs_par_champ = valider_formulaire(donnees)

                if est_valide:
                    # Donn√©es valides d√®s le premier essai
                    afficher_donnees_valides(donnees)

                    # Demander confirmation pour sauvegarder
                    sauvegarder = input("\nüíæ Sauvegarder ces donn√©es ? (o/n) : ").lower()
                    if sauvegarder in ['o', 'oui', 'y', 'yes']:
                        sauvegarder_donnees(donnees)
                    else:
                        print("‚èπÔ∏è Sauvegarde annul√©e")

                else:
                    # Il y a des erreurs, permettre les corrections
                    afficher_erreurs(erreurs_par_champ)

                    while not est_valide:
                        print(f"\nüîß Options de correction :")
                        print("1. Corriger champ par champ")
                        print("2. Recommencer la saisie")
                        print("3. Abandonner ce formulaire")

                        choix_correction = input("\nVotre choix (1-3) : ").strip()

                        if choix_correction == "1":
                            # Correction champ par champ
                            champs_disponibles = list(erreurs_par_champ.keys())

                            print(f"\nChamps √† corriger :")
                            for i, champ in enumerate(champs_disponibles, 1):
                                nom_affichage = {
                                    'nom': 'Nom',
                                    'email': 'Email',
                                    'age': '√Çge',
                                    'code_postal': 'Code postal'
                                }.get(champ, champ)
                                print(f"{i}. {nom_affichage}")

                            try:
                                choix_champ = int(input("Champ √† corriger (num√©ro) : ")) - 1
                                if 0 <= choix_champ < len(champs_disponibles):
                                    champ_a_corriger = champs_disponibles[choix_champ]
                                    corriger_champ(donnees, champ_a_corriger)

                                    # Re-valider
                                    est_valide, erreurs_par_champ = valider_formulaire(donnees)

                                    if est_valide:
                                        print(f"\nüéâ Toutes les donn√©es sont maintenant valides !")
                                        afficher_donnees_valides(donnees)

                                        sauvegarder = input("\nüíæ Sauvegarder ces donn√©es ? (o/n) : ").lower()
                                        if sauvegarder in ['o', 'oui', 'y', 'yes']:
                                            sauvegarder_donnees(donnees)
                                    else:
                                        print(f"\n‚ö†Ô∏è Il reste encore des erreurs :")
                                        afficher_erreurs(erreurs_par_champ)

                                else:
                                    print("‚ùå Num√©ro de champ invalide")

                            except ValueError:
                                print("‚ùå Veuillez entrer un num√©ro valide")
                            except KeyboardInterrupt:
                                print("\n‚èπÔ∏è Correction annul√©e")
                                break

                        elif choix_correction == "2":
                            # Recommencer la saisie
                            donnees = saisir_donnees()
                            if donnees is None:
                                break

                            est_valide, erreurs_par_champ = valider_formulaire(donnees)

                            if est_valide:
                                afficher_donnees_valides(donnees)
                                sauvegarder = input("\nüíæ Sauvegarder ces donn√©es ? (o/n) : ").lower()
                                if sauvegarder in ['o', 'oui', 'y', 'yes']:
                                    sauvegarder_donnees(donnees)
                            else:
                                afficher_erreurs(erreurs_par_champ)

                        elif choix_correction == "3":
                            print("‚èπÔ∏è Formulaire abandonn√©")
                            break

                        else:
                            print("‚ùå Choix invalide")

            elif choix == "2":
                lire_fichier_donnees()

            elif choix == "3":
                print("\nüëã Merci d'avoir utilis√© le validateur de formulaire !")
                print("√Ä bient√¥t ! üìã")
                break

            else:
                print("‚ùå Choix invalide. Veuillez entrer un nombre entre 1 et 3.")

        except KeyboardInterrupt:
            print(f"\n\n‚èπÔ∏è Programme interrompu par l'utilisateur")
            print("üëã Au revoir !")
            break

        except Exception as e:
            print(f"‚ùå Erreur inattendue dans le menu : {e}")
            print("üîÑ Retour au menu principal...")

if __name__ == "__main__":
    main()
```

## Tests √† effectuer

### Tests pour le nom
- `"Jean Dupont"` ‚Üí ‚úÖ Valide
- `"Marie-Claire"` ‚Üí ‚úÖ Valide
- `"O'Connor"` ‚Üí ‚úÖ Valide
- `"A"` ‚Üí ‚ùå Trop court
- `""` ‚Üí ‚ùå Vide
- `"Jean123"` ‚Üí ‚ùå Contient des chiffres

### Tests pour l'email
- `"user@example.com"` ‚Üí ‚úÖ Valide
- `"test.email@domain.fr"` ‚Üí ‚úÖ Valide
- `"invalid@"` ‚Üí ‚ùå Domaine manquant
- `"@domain.com"` ‚Üí ‚ùå Partie locale manquante
- `"user@@domain.com"` ‚Üí ‚ùå Deux @

### Tests pour l'√¢ge
- `"25"` ‚Üí ‚úÖ Valide
- `"0"` ‚Üí ‚ùå √Çge z√©ro
- `"-5"` ‚Üí ‚ùå √Çge n√©gatif
- `"200"` ‚Üí ‚ùå √Çge trop √©lev√©
- `"abc"` ‚Üí ‚ùå Pas un nombre

### Tests pour le code postal
- `"75001"` ‚Üí ‚úÖ Valide (Paris)
- `"13000"` ‚Üí ‚úÖ Valide (Marseille)
- `"97400"` ‚Üí ‚úÖ Valide (DOM-TOM)
- `"1234"` ‚Üí ‚ùå Trop court
- `"00000"` ‚Üí ‚ùå Code invalide
- `"99999"` ‚Üí ‚ùå Hors plage fran√ßaise

## Crit√®res d'√©valuation

- ‚úÖ **Validation compl√®te** : R√®gles strictes pour chaque champ
- ‚úÖ **Gestion d'erreurs** : Collecte et affichage organis√©
- ‚úÖ **Correction interactive** : Champ par champ ou compl√®te
- ‚úÖ **Sauvegarde s√©curis√©e** : Gestion des permissions
- ‚úÖ **Interface utilisateur** : Menus clairs et navigation fluide
- ‚úÖ **Lecture des donn√©es** : Affichage des formulaires sauvegard√©s
- ‚úÖ **Code robuste** : Gestion de toutes les exceptions

## Extensions possibles

- Support d'autres pays pour les codes postaux
- Validation de num√©ros de t√©l√©phone
- Export en format CSV
- Interface graphique
- Base de donn√©es au lieu de fichier texte
