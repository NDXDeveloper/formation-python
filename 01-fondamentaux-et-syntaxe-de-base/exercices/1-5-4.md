# Exercice 4 : Validateur de formulaire

## Objectif

CrÃ©er un systÃ¨me de validation de formulaire qui collecte et valide des donnÃ©es utilisateur avec gestion complÃ¨te des erreurs.

## Cahier des charges

1. **Demander** nom, email, Ã¢ge, code postal
2. **Valider chaque champ** avec des rÃ¨gles spÃ©cifiques
3. **Collecter toutes les erreurs** avant de les afficher
4. **Permettre de corriger** champ par champ
5. **Sauvegarder** les donnÃ©es valides dans un fichier texte

## Code de base Ã  complÃ©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 4 : Validateur de formulaire
Module 1.5 - Gestion des erreurs avec try/except
"""

def valider_nom(nom):
    """
    Valide un nom.

    Args:
        nom (str): Nom Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: ImplÃ©menter la validation
    pass

def valider_email(email):
    """
    Valide une adresse email.

    Args:
        email (str): Email Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: ImplÃ©menter la validation
    pass

def valider_age(age):
    """
    Valide un Ã¢ge.

    Args:
        age (str): Ã‚ge Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: ImplÃ©menter la validation
    pass

def valider_code_postal(code):
    """
    Valide un code postal franÃ§ais.

    Args:
        code (str): Code postal Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    # TODO: ImplÃ©menter la validation
    pass

def main():
    """Fonction principale du validateur."""
    print("ğŸ“‹ === VALIDATEUR DE FORMULAIRE ===")

    while True:
        try:
            # TODO: ImplÃ©menter la logique principale
            pass

        except KeyboardInterrupt:
            # TODO: GÃ©rer l'interruption clavier
            pass

if __name__ == "__main__":
    main()
```

## Solution complÃ¨te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 4 : Validateur de formulaire - SOLUTION
Module 1.5 - Gestion des erreurs avec try/except
"""

import re
import os
from datetime import datetime

def valider_nom(nom):
    """
    Valide un nom.

    Args:
        nom (str): Nom Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(nom, str):
            erreurs.append("Le nom doit Ãªtre une chaÃ®ne de caractÃ¨res")
            return False, erreurs

        nom_propre = nom.strip()

        # VÃ©rifications
        if not nom_propre:
            erreurs.append("Le nom ne peut pas Ãªtre vide")

        if len(nom_propre) < 2:
            erreurs.append("Le nom doit contenir au moins 2 caractÃ¨res")

        if len(nom_propre) > 50:
            erreurs.append("Le nom ne peut pas dÃ©passer 50 caractÃ¨res")

        # VÃ©rifier qu'il ne contient que des lettres et espaces
        if not re.match(r'^[a-zA-ZÃ€-Ã¿\s\'-]+$', nom_propre):
            erreurs.append("Le nom ne peut contenir que des lettres, espaces, apostrophes et tirets")

        # VÃ©rifier qu'il ne commence/finit pas par un espace
        if nom_propre != nom_propre.strip():
            erreurs.append("Le nom ne peut pas commencer ou finir par un espace")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def valider_email(email):
    """
    Valide une adresse email.

    Args:
        email (str): Email Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(email, str):
            erreurs.append("L'email doit Ãªtre une chaÃ®ne de caractÃ¨res")
            return False, erreurs

        email_propre = email.strip().lower()

        # VÃ©rifications de base
        if not email_propre:
            erreurs.append("L'email ne peut pas Ãªtre vide")
            return False, erreurs

        if len(email_propre) > 254:
            erreurs.append("L'email ne peut pas dÃ©passer 254 caractÃ¨res")

        # VÃ©rifier la prÃ©sence d'un @
        if '@' not in email_propre:
            erreurs.append("L'email doit contenir un @")
        elif email_propre.count('@') != 1:
            erreurs.append("L'email ne doit contenir qu'un seul @")
        else:
            # SÃ©parer partie locale et domaine
            partie_locale, domaine = email_propre.split('@')

            # Validation partie locale
            if not partie_locale:
                erreurs.append("La partie avant @ ne peut pas Ãªtre vide")
            elif len(partie_locale) > 64:
                erreurs.append("La partie avant @ ne peut pas dÃ©passer 64 caractÃ¨res")
            elif not re.match(r'^[a-zA-Z0-9._-]+$', partie_locale):
                erreurs.append("La partie avant @ contient des caractÃ¨res invalides")
            elif partie_locale.startswith('.') or partie_locale.endswith('.'):
                erreurs.append("La partie avant @ ne peut pas commencer ou finir par un point")
            elif '..' in partie_locale:
                erreurs.append("La partie avant @ ne peut pas contenir deux points consÃ©cutifs")

            # Validation domaine
            if not domaine:
                erreurs.append("Le domaine ne peut pas Ãªtre vide")
            elif len(domaine) > 253:
                erreurs.append("Le domaine ne peut pas dÃ©passer 253 caractÃ¨res")
            elif '.' not in domaine:
                erreurs.append("Le domaine doit contenir au moins un point")
            elif not re.match(r'^[a-zA-Z0-9.-]+$', domaine):
                erreurs.append("Le domaine contient des caractÃ¨res invalides")
            elif domaine.startswith('.') or domaine.endswith('.'):
                erreurs.append("Le domaine ne peut pas commencer ou finir par un point")
            elif '..' in domaine:
                erreurs.append("Le domaine ne peut pas contenir deux points consÃ©cutifs")
            else:
                # VÃ©rifier l'extension
                parties_domaine = domaine.split('.')
                if len(parties_domaine[-1]) < 2:
                    erreurs.append("L'extension du domaine doit contenir au moins 2 caractÃ¨res")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def valider_age(age):
    """
    Valide un Ã¢ge.

    Args:
        age (str): Ã‚ge Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(age, str):
            erreurs.append("L'Ã¢ge doit Ãªtre fourni comme une chaÃ®ne")
            return False, erreurs

        age_propre = age.strip()

        if not age_propre:
            erreurs.append("L'Ã¢ge ne peut pas Ãªtre vide")
            return False, erreurs

        # Tentative de conversion
        try:
            age_int = int(age_propre)
        except ValueError:
            erreurs.append("L'Ã¢ge doit Ãªtre un nombre entier")
            return False, erreurs

        # VÃ©rifications de plausibilitÃ©
        if age_int < 0:
            erreurs.append("L'Ã¢ge ne peut pas Ãªtre nÃ©gatif")

        if age_int > 150:
            erreurs.append("L'Ã¢ge ne peut pas dÃ©passer 150 ans")

        if age_int == 0:
            erreurs.append("L'Ã¢ge ne peut pas Ãªtre 0 (utilisez l'Ã¢ge en annÃ©es rÃ©volues)")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def valider_code_postal(code):
    """
    Valide un code postal franÃ§ais.

    Args:
        code (str): Code postal Ã  valider

    Returns:
        tuple: (est_valide, erreurs)
    """
    erreurs = []

    try:
        if not isinstance(code, str):
            erreurs.append("Le code postal doit Ãªtre une chaÃ®ne de caractÃ¨res")
            return False, erreurs

        code_propre = code.strip()

        if not code_propre:
            erreurs.append("Le code postal ne peut pas Ãªtre vide")
            return False, erreurs

        # Format franÃ§ais : 5 chiffres
        if not re.match(r'^\d{5}$', code_propre):
            erreurs.append("Le code postal doit contenir exactement 5 chiffres")
        else:
            # VÃ©rifications de plausibilitÃ© pour la France mÃ©tropolitaine et DOM-TOM
            premier_chiffre = int(code_propre[0])
            deux_premiers = int(code_propre[:2])

            # France mÃ©tropolitaine : 01000 Ã  95999
            # DOM-TOM : 97000-97999, 98000-98999
            if not (1 <= deux_premiers <= 95 or 970 <= int(code_propre[:3]) <= 989):
                erreurs.append("Code postal franÃ§ais invalide")

            # Cas spÃ©ciaux
            if code_propre == "00000":
                erreurs.append("Le code postal ne peut pas Ãªtre 00000")

        return len(erreurs) == 0, erreurs

    except Exception as e:
        erreurs.append(f"Erreur lors de la validation : {e}")
        return False, erreurs

def saisir_donnees():
    """
    Saisit les donnÃ©es du formulaire.

    Returns:
        dict: Dictionnaire avec les donnÃ©es saisies
    """
    print("\nğŸ“ === SAISIE DES DONNÃ‰ES ===")

    donnees = {}

    try:
        donnees['nom'] = input("Nom complet : ").strip()
        donnees['email'] = input("Adresse email : ").strip()
        donnees['age'] = input("Ã‚ge : ").strip()
        donnees['code_postal'] = input("Code postal : ").strip()

        return donnees

    except KeyboardInterrupt:
        print("\nâ¹ï¸ Saisie annulÃ©e")
        return None

def valider_formulaire(donnees):
    """
    Valide toutes les donnÃ©es du formulaire.

    Args:
        donnees (dict): DonnÃ©es Ã  valider

    Returns:
        tuple: (est_valide, erreurs_par_champ)
    """
    erreurs_par_champ = {}

    # Validation de chaque champ
    nom_valide, erreurs_nom = valider_nom(donnees.get('nom', ''))
    if not nom_valide:
        erreurs_par_champ['nom'] = erreurs_nom

    email_valide, erreurs_email = valider_email(donnees.get('email', ''))
    if not email_valide:
        erreurs_par_champ['email'] = erreurs_email

    age_valide, erreurs_age = valider_age(donnees.get('age', ''))
    if not age_valide:
        erreurs_par_champ['age'] = erreurs_age

    code_valide, erreurs_code = valider_code_postal(donnees.get('code_postal', ''))
    if not code_valide:
        erreurs_par_champ['code_postal'] = erreurs_code

    return len(erreurs_par_champ) == 0, erreurs_par_champ

def afficher_erreurs(erreurs_par_champ):
    """
    Affiche les erreurs de validation de maniÃ¨re organisÃ©e.

    Args:
        erreurs_par_champ (dict): Erreurs groupÃ©es par champ
    """
    print(f"\nâŒ Erreurs de validation dÃ©tectÃ©es :")
    print("â•" * 60)

    for champ, erreurs in erreurs_par_champ.items():
        nom_champ = {
            'nom': 'Nom',
            'email': 'Email',
            'age': 'Ã‚ge',
            'code_postal': 'Code postal'
        }.get(champ, champ)

        print(f"\nğŸ”¸ {nom_champ} :")
        for erreur in erreurs:
            print(f"   â€¢ {erreur}")

    print("â•" * 60)

def corriger_champ(donnees, nom_champ):
    """
    Permet de corriger un champ spÃ©cifique.

    Args:
        donnees (dict): DonnÃ©es actuelles
        nom_champ (str): Nom du champ Ã  corriger

    Returns:
        bool: True si correction effectuÃ©e, False si annulÃ©e
    """
    try:
        noms_champs = {
            'nom': 'Nom complet',
            'email': 'Adresse email',
            'age': 'Ã‚ge',
            'code_postal': 'Code postal'
        }

        nom_affichage = noms_champs.get(nom_champ, nom_champ)
        valeur_actuelle = donnees.get(nom_champ, '')

        print(f"\nâœï¸ Correction du champ '{nom_affichage}'")
        print(f"   Valeur actuelle : '{valeur_actuelle}'")

        nouvelle_valeur = input(f"   Nouvelle valeur : ").strip()
        donnees[nom_champ] = nouvelle_valeur

        print(f"âœ… Champ '{nom_affichage}' mis Ã  jour")
        return True

    except KeyboardInterrupt:
        print(f"\nâ¹ï¸ Correction du champ '{nom_champ}' annulÃ©e")
        return False

def sauvegarder_donnees(donnees, nom_fichier="formulaires.txt"):
    """
    Sauvegarde les donnÃ©es validÃ©es dans un fichier.

    Args:
        donnees (dict): DonnÃ©es Ã  sauvegarder
        nom_fichier (str): Nom du fichier de sauvegarde

    Returns:
        bool: True si sauvegarde rÃ©ussie
    """
    try:
        # CrÃ©er l'en-tÃªte si le fichier n'existe pas
        if not os.path.exists(nom_fichier):
            with open(nom_fichier, 'w', encoding='utf-8') as f:
                f.write("# FORMULAIRES VALIDÃ‰S\n")
                f.write("# Format : NOM|EMAIL|AGE|CODE_POSTAL|DATE\n")
                f.write("# " + "â”€" * 50 + "\n\n")

        # Ajouter les nouvelles donnÃ©es
        with open(nom_fichier, 'a', encoding='utf-8') as f:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            ligne = f"{donnees['nom']}|{donnees['email']}|{donnees['age']}|{donnees['code_postal']}|{timestamp}\n"
            f.write(ligne)

        print(f"ğŸ’¾ DonnÃ©es sauvegardÃ©es dans '{nom_fichier}'")
        return True

    except PermissionError:
        print(f"âŒ Erreur : Pas de permission d'Ã©criture pour '{nom_fichier}'")
        return False

    except Exception as e:
        print(f"âŒ Erreur lors de la sauvegarde : {e}")
        return False

def afficher_donnees_valides(donnees):
    """
    Affiche les donnÃ©es validÃ©es de maniÃ¨re formatÃ©e.

    Args:
        donnees (dict): DonnÃ©es validÃ©es
    """
    print(f"\nâœ… === DONNÃ‰ES VALIDÃ‰ES ===")
    print("â•" * 40)
    print(f"ğŸ‘¤ Nom          : {donnees['nom']}")
    print(f"ğŸ“§ Email        : {donnees['email']}")
    print(f"ğŸ‚ Ã‚ge          : {donnees['age']} ans")
    print(f"ğŸ“® Code postal  : {donnees['code_postal']}")
    print("â•" * 40)

    # Informations dÃ©rivÃ©es
    age_int = int(donnees['age'])
    if age_int >= 18:
        print(f"â„¹ï¸  Statut : Majeur")
    else:
        print(f"â„¹ï¸  Statut : Mineur")

    # RÃ©gion approximative basÃ©e sur le code postal
    code = donnees['code_postal']
    if code.startswith('75'):
        region = "Paris"
    elif code.startswith('13'):
        region = "Bouches-du-RhÃ´ne"
    elif code.startswith('69'):
        region = "RhÃ´ne"
    elif code.startswith('59'):
        region = "Nord"
    elif code.startswith('97'):
        region = "DOM-TOM"
    else:
        region = f"DÃ©partement {code[:2]}"

    print(f"ğŸ“ RÃ©gion : {region}")

def lire_fichier_donnees(nom_fichier="formulaires.txt"):
    """
    Lit et affiche les donnÃ©es sauvegardÃ©es.

    Args:
        nom_fichier (str): Nom du fichier Ã  lire
    """
    try:
        if not os.path.exists(nom_fichier):
            print(f"ğŸ“„ Le fichier '{nom_fichier}' n'existe pas encore")
            return

        with open(nom_fichier, 'r', encoding='utf-8') as f:
            lignes = f.readlines()

        # Filtrer les lignes de donnÃ©es (ignorer les commentaires)
        donnees_lignes = [ligne.strip() for ligne in lignes
                         if ligne.strip() and not ligne.startswith('#')]

        if not donnees_lignes:
            print(f"ğŸ“­ Aucune donnÃ©e dans le fichier '{nom_fichier}'")
            return

        print(f"\nğŸ“š DonnÃ©es sauvegardÃ©es ({len(donnees_lignes)} entrÃ©e(s)) :")
        print("â•" * 80)

        for i, ligne in enumerate(donnees_lignes, 1):
            try:
                parties = ligne.split('|')
                if len(parties) >= 5:
                    nom, email, age, code_postal, date = parties[:5]
                    print(f"{i:2d}. ğŸ‘¤ {nom}")
                    print(f"     ğŸ“§ {email}")
                    print(f"     ğŸ‚ {age} ans | ğŸ“® {code_postal}")
                    print(f"     ğŸ“… SauvegardÃ© le {date}")
                    print()
            except Exception as e:
                print(f"âš ï¸ Erreur lors de la lecture de la ligne {i} : {e}")

        print("â•" * 80)

    except PermissionError:
        print(f"âŒ Erreur : Pas de permission de lecture pour '{nom_fichier}'")

    except Exception as e:
        print(f"âŒ Erreur lors de la lecture : {e}")

def main():
    """Fonction principale du validateur."""
    print("ğŸ“‹ === VALIDATEUR DE FORMULAIRE ===")
    print("SystÃ¨me de validation de donnÃ©es utilisateur avec gestion d'erreurs")

    while True:
        try:
            print("\n" + "â”€" * 60)
            print("1. ğŸ“ Saisir et valider un nouveau formulaire")
            print("2. ğŸ“š Afficher les formulaires sauvegardÃ©s")
            print("3. âŒ Quitter")

            choix = input("\nVotre choix (1-3) : ").strip()

            if choix == "1":
                # Saisie des donnÃ©es
                donnees = saisir_donnees()
                if donnees is None:
                    continue

                # Validation initiale
                print(f"\nğŸ” Validation des donnÃ©es en cours...")
                est_valide, erreurs_par_champ = valider_formulaire(donnees)

                if est_valide:
                    # DonnÃ©es valides dÃ¨s le premier essai
                    afficher_donnees_valides(donnees)

                    # Demander confirmation pour sauvegarder
                    sauvegarder = input("\nğŸ’¾ Sauvegarder ces donnÃ©es ? (o/n) : ").lower()
                    if sauvegarder in ['o', 'oui', 'y', 'yes']:
                        sauvegarder_donnees(donnees)
                    else:
                        print("â¹ï¸ Sauvegarde annulÃ©e")

                else:
                    # Il y a des erreurs, permettre les corrections
                    afficher_erreurs(erreurs_par_champ)

                    while not est_valide:
                        print(f"\nğŸ”§ Options de correction :")
                        print("1. Corriger champ par champ")
                        print("2. Recommencer la saisie")
                        print("3. Abandonner ce formulaire")

                        choix_correction = input("\nVotre choix (1-3) : ").strip()

                        if choix_correction == "1":
                            # Correction champ par champ
                            champs_disponibles = list(erreurs_par_champ.keys())

                            print(f"\nChamps Ã  corriger :")
                            for i, champ in enumerate(champs_disponibles, 1):
                                nom_affichage = {
                                    'nom': 'Nom',
                                    'email': 'Email',
                                    'age': 'Ã‚ge',
                                    'code_postal': 'Code postal'
                                }.get(champ, champ)
                                print(f"{i}. {nom_affichage}")

                            try:
                                choix_champ = int(input("Champ Ã  corriger (numÃ©ro) : ")) - 1
                                if 0 <= choix_champ < len(champs_disponibles):
                                    champ_a_corriger = champs_disponibles[choix_champ]
                                    corriger_champ(donnees, champ_a_corriger)

                                    # Re-valider
                                    est_valide, erreurs_par_champ = valider_formulaire(donnees)

                                    if est_valide:
                                        print(f"\nğŸ‰ Toutes les donnÃ©es sont maintenant valides !")
                                        afficher_donnees_valides(donnees)

                                        sauvegarder = input("\nğŸ’¾ Sauvegarder ces donnÃ©es ? (o/n) : ").lower()
                                        if sauvegarder in ['o', 'oui', 'y', 'yes']:
                                            sauvegarder_donnees(donnees)
                                    else:
                                        print(f"\nâš ï¸ Il reste encore des erreurs :")
                                        afficher_erreurs(erreurs_par_champ)

                                else:
                                    print("âŒ NumÃ©ro de champ invalide")

                            except ValueError:
                                print("âŒ Veuillez entrer un numÃ©ro valide")
                            except KeyboardInterrupt:
                                print("\nâ¹ï¸ Correction annulÃ©e")
                                break

                        elif choix_correction == "2":
                            # Recommencer la saisie
                            donnees = saisir_donnees()
                            if donnees is None:
                                break

                            est_valide, erreurs_par_champ = valider_formulaire(donnees)

                            if est_valide:
                                afficher_donnees_valides(donnees)
                                sauvegarder = input("\nğŸ’¾ Sauvegarder ces donnÃ©es ? (o/n) : ").lower()
                                if sauvegarder in ['o', 'oui', 'y', 'yes']:
                                    sauvegarder_donnees(donnees)
                            else:
                                afficher_erreurs(erreurs_par_champ)

                        elif choix_correction == "3":
                            print("â¹ï¸ Formulaire abandonnÃ©")
                            break

                        else:
                            print("âŒ Choix invalide")

            elif choix == "2":
                lire_fichier_donnees()

            elif choix == "3":
                print("\nğŸ‘‹ Merci d'avoir utilisÃ© le validateur de formulaire !")
                print("Ã€ bientÃ´t ! ğŸ“‹")
                break

            else:
                print("âŒ Choix invalide. Veuillez entrer un nombre entre 1 et 3.")

        except KeyboardInterrupt:
            print(f"\n\nâ¹ï¸ Programme interrompu par l'utilisateur")
            print("ğŸ‘‹ Au revoir !")
            break

        except Exception as e:
            print(f"âŒ Erreur inattendue dans le menu : {e}")
            print("ğŸ”„ Retour au menu principal...")

if __name__ == "__main__":
    main()
```

## Tests Ã  effectuer

### Tests pour le nom
- `"Jean Dupont"` â†’ âœ… Valide
- `"Marie-Claire"` â†’ âœ… Valide
- `"O'Connor"` â†’ âœ… Valide
- `"A"` â†’ âŒ Trop court
- `""` â†’ âŒ Vide
- `"Jean123"` â†’ âŒ Contient des chiffres

### Tests pour l'email
- `"user@example.com"` â†’ âœ… Valide
- `"test.email@domain.fr"` â†’ âœ… Valide
- `"invalid@"` â†’ âŒ Domaine manquant
- `"@domain.com"` â†’ âŒ Partie locale manquante
- `"user@@domain.com"` â†’ âŒ Deux @

### Tests pour l'Ã¢ge
- `"25"` â†’ âœ… Valide
- `"0"` â†’ âŒ Ã‚ge zÃ©ro
- `"-5"` â†’ âŒ Ã‚ge nÃ©gatif
- `"200"` â†’ âŒ Ã‚ge trop Ã©levÃ©
- `"abc"` â†’ âŒ Pas un nombre

### Tests pour le code postal
- `"75001"` â†’ âœ… Valide (Paris)
- `"13000"` â†’ âœ… Valide (Marseille)
- `"97400"` â†’ âœ… Valide (DOM-TOM)
- `"1234"` â†’ âŒ Trop court
- `"00000"` â†’ âŒ Code invalide
- `"99999"` â†’ âŒ Hors plage franÃ§aise

## CritÃ¨res d'Ã©valuation

- âœ… **Validation complÃ¨te** : RÃ¨gles strictes pour chaque champ
- âœ… **Gestion d'erreurs** : Collecte et affichage organisÃ©
- âœ… **Correction interactive** : Champ par champ ou complÃ¨te
- âœ… **Sauvegarde sÃ©curisÃ©e** : Gestion des permissions
- âœ… **Interface utilisateur** : Menus clairs et navigation fluide
- âœ… **Lecture des donnÃ©es** : Affichage des formulaires sauvegardÃ©s
- âœ… **Code robuste** : Gestion de toutes les exceptions

## Extensions possibles

- Support d'autres pays pour les codes postaux
- Validation de numÃ©ros de tÃ©lÃ©phone
- Export en format CSV
- Interface graphique
- Base de donnÃ©es au lieu de fichier texte
