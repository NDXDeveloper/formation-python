# Exercice 3 : Convertisseur de types sÃ©curisÃ©

## Objectif

CrÃ©er un programme qui convertit des chaÃ®nes de caractÃ¨res vers diffÃ©rents types Python avec une gestion complÃ¨te des erreurs.

## Cahier des charges

1. **Proposer de convertir** une chaÃ®ne vers diffÃ©rents types
2. **Types supportÃ©s** : int, float, bool, list (avec conversion sÃ©curisÃ©e)
3. **GÃ©rer toutes les erreurs** de conversion possibles
4. **Afficher le rÃ©sultat** et le type de la conversion
5. **Permettre plusieurs conversions** successives

## Code de base Ã  complÃ©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 3 : Convertisseur de types sÃ©curisÃ©
Module 1.5 - Gestion des erreurs avec try/except
"""

def convertir_vers_int(chaine):
    """
    Convertit une chaÃ®ne vers un entier.

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    # TODO: ImplÃ©menter la fonction
    pass

def convertir_vers_float(chaine):
    """
    Convertit une chaÃ®ne vers un float.

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    # TODO: ImplÃ©menter la fonction
    pass

def convertir_vers_bool(chaine):
    """
    Convertit une chaÃ®ne vers un boolÃ©en.

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    # TODO: ImplÃ©menter la fonction
    pass

def convertir_vers_list(chaine):
    """
    Convertit une chaÃ®ne vers une liste (sÃ©curisÃ©).

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    # TODO: ImplÃ©menter la fonction
    pass

def main():
    """Fonction principale du convertisseur."""
    print("ğŸ”„ === CONVERTISSEUR DE TYPES SÃ‰CURISÃ‰ ===")

    while True:
        try:
            # TODO: ImplÃ©menter la logique principale
            pass

        except KeyboardInterrupt:
            # TODO: GÃ©rer l'interruption clavier
            pass

if __name__ == "__main__":
    main()
```

## Solution complÃ¨te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 3 : Convertisseur de types sÃ©curisÃ© - SOLUTION
Module 1.5 - Gestion des erreurs avec try/except
"""

import re

def convertir_vers_int(chaine):
    """
    Convertit une chaÃ®ne vers un entier.

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    try:
        # Nettoyer la chaÃ®ne
        chaine_propre = chaine.strip()

        # Cas spÃ©ciaux
        if not chaine_propre:
            return False, "ChaÃ®ne vide"

        # VÃ©rifier les prÃ©fixes pour diffÃ©rentes bases
        if chaine_propre.startswith('0b'):
            # Binaire
            valeur = int(chaine_propre, 2)
            return True, valeur
        elif chaine_propre.startswith('0o'):
            # Octal
            valeur = int(chaine_propre, 8)
            return True, valeur
        elif chaine_propre.startswith('0x'):
            # HexadÃ©cimal
            valeur = int(chaine_propre, 16)
            return True, valeur
        else:
            # DÃ©cimal standard
            valeur = int(chaine_propre)
            return True, valeur

    except ValueError as e:
        return False, f"Conversion impossible : {e}"
    except Exception as e:
        return False, f"Erreur inattendue : {e}"

def convertir_vers_float(chaine):
    """
    Convertit une chaÃ®ne vers un float.

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    try:
        chaine_propre = chaine.strip()

        if not chaine_propre:
            return False, "ChaÃ®ne vide"

        # Cas spÃ©ciaux
        if chaine_propre.lower() in ['inf', 'infinity', '+inf', '+infinity']:
            return True, float('inf')
        elif chaine_propre.lower() in ['-inf', '-infinity']:
            return True, float('-inf')
        elif chaine_propre.lower() in ['nan', 'not a number']:
            return True, float('nan')

        # Conversion standard
        valeur = float(chaine_propre)
        return True, valeur

    except ValueError as e:
        return False, f"Conversion impossible : {e}"
    except Exception as e:
        return False, f"Erreur inattendue : {e}"

def convertir_vers_bool(chaine):
    """
    Convertit une chaÃ®ne vers un boolÃ©en de maniÃ¨re intelligente.

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    try:
        chaine_propre = chaine.strip().lower()

        if not chaine_propre:
            return True, False  # ChaÃ®ne vide = False

        # Valeurs explicitement vraies
        valeurs_vraies = [
            'true', 'vrai', 'yes', 'oui', 'y', 'o', '1',
            'on', 'actif', 'activÃ©', 'enabled', 'active'
        ]

        # Valeurs explicitement fausses
        valeurs_fausses = [
            'false', 'faux', 'no', 'non', 'n', '0',
            'off', 'inactif', 'dÃ©sactivÃ©', 'disabled', 'inactive'
        ]

        if chaine_propre in valeurs_vraies:
            return True, True
        elif chaine_propre in valeurs_fausses:
            return True, False
        else:
            # Essayer la conversion Python standard
            # En Python, toute chaÃ®ne non vide est True
            valeur = bool(chaine)
            return True, valeur

    except Exception as e:
        return False, f"Erreur inattendue : {e}"

def convertir_vers_list(chaine):
    """
    Convertit une chaÃ®ne vers une liste de maniÃ¨re sÃ©curisÃ©e.

    Args:
        chaine (str): ChaÃ®ne Ã  convertir

    Returns:
        tuple: (succÃ¨s, valeur_ou_erreur)
    """
    try:
        chaine_propre = chaine.strip()

        if not chaine_propre:
            return True, []

        # MÃ©thode 1: Format [item1, item2, item3]
        if chaine_propre.startswith('[') and chaine_propre.endswith(']'):
            contenu = chaine_propre[1:-1].strip()
            if not contenu:
                return True, []

            # SÃ©parer par virgules et nettoyer
            elements = []
            for element in contenu.split(','):
                element = element.strip()

                # Essayer de dÃ©tecter le type de chaque Ã©lÃ©ment
                if element.startswith('"') and element.endswith('"'):
                    # ChaÃ®ne entre guillemets
                    elements.append(element[1:-1])
                elif element.startswith("'") and element.endswith("'"):
                    # ChaÃ®ne entre apostrophes
                    elements.append(element[1:-1])
                elif element.lower() in ['true', 'false']:
                    # BoolÃ©en
                    elements.append(element.lower() == 'true')
                elif element.isdigit() or (element.startswith('-') and element[1:].isdigit()):
                    # Entier
                    elements.append(int(element))
                elif '.' in element:
                    try:
                        # Float
                        elements.append(float(element))
                    except ValueError:
                        # Garder comme chaÃ®ne
                        elements.append(element)
                else:
                    # Garder comme chaÃ®ne
                    elements.append(element)

            return True, elements

        # MÃ©thode 2: SÃ©paration par virgules simple
        elif ',' in chaine_propre:
            elements = [elem.strip() for elem in chaine_propre.split(',')]
            return True, elements

        # MÃ©thode 3: SÃ©paration par espaces
        elif ' ' in chaine_propre:
            elements = chaine_propre.split()
            return True, elements

        # MÃ©thode 4: Un seul Ã©lÃ©ment
        else:
            return True, [chaine_propre]

    except Exception as e:
        return False, f"Erreur lors de la conversion : {e}"

def afficher_resultat(succes, valeur, type_cible):
    """
    Affiche le rÃ©sultat d'une conversion.

    Args:
        succes (bool): Si la conversion a rÃ©ussi
        valeur: La valeur convertie ou le message d'erreur
        type_cible (str): Le type vers lequel on a tentÃ© de convertir
    """
    if succes:
        print(f"âœ… Conversion vers {type_cible} rÃ©ussie :")
        print(f"   ğŸ“„ Valeur : {repr(valeur)}")
        print(f"   ğŸ”§ Type Python : {type(valeur).__name__}")

        # Informations additionnelles selon le type
        if isinstance(valeur, int):
            print(f"   ğŸ“Š Valeur en binaire : {bin(valeur)}")
            print(f"   ğŸ“Š Valeur en hexadÃ©cimal : {hex(valeur)}")
        elif isinstance(valeur, float):
            if valeur.is_integer():
                print(f"   â„¹ï¸  Nombre dÃ©cimal sans partie fractionnaire")
            print(f"   ğŸ“Š Notation scientifique : {valeur:.2e}")
        elif isinstance(valeur, list):
            print(f"   ğŸ“Š Nombre d'Ã©lÃ©ments : {len(valeur)}")
            if valeur:
                types_elements = [type(elem).__name__ for elem in valeur]
                print(f"   ğŸ“Š Types des Ã©lÃ©ments : {', '.join(set(types_elements))}")
    else:
        print(f"âŒ Conversion vers {type_cible} Ã©chouÃ©e :")
        print(f"   ğŸ“„ Erreur : {valeur}")

def main():
    """Fonction principale du convertisseur."""
    print("ğŸ”„ === CONVERTISSEUR DE TYPES SÃ‰CURISÃ‰ ===")
    print("Convertit des chaÃ®nes de caractÃ¨res vers diffÃ©rents types Python")

    conversions = {
        '1': ('int', convertir_vers_int),
        '2': ('float', convertir_vers_float),
        '3': ('bool', convertir_vers_bool),
        '4': ('list', convertir_vers_list)
    }

    historique = []

    while True:
        try:
            print("\n" + "â”€" * 60)
            print("ğŸ”„ Types de conversion disponibles :")
            print("1. ğŸ”¢ Entier (int)")
            print("2. ğŸ”¢ Nombre dÃ©cimal (float)")
            print("3. âœ… BoolÃ©en (bool)")
            print("4. ğŸ“‹ Liste (list)")
            print("5. ğŸ“š Afficher l'historique")
            print("6. âŒ Quitter")

            choix = input("\nVotre choix (1-6) : ").strip()

            if choix in conversions:
                type_nom, fonction_conversion = conversions[choix]

                print(f"\nğŸ”„ Conversion vers {type_nom}")
                chaine = input("ChaÃ®ne Ã  convertir : ")

                print(f"ğŸ” Tentative de conversion de '{chaine}' vers {type_nom}...")
                succes, resultat = fonction_conversion(chaine)

                afficher_resultat(succes, resultat, type_nom)

                # Ajouter Ã  l'historique
                historique.append({
                    'chaine': chaine,
                    'type_cible': type_nom,
                    'succes': succes,
                    'resultat': resultat
                })

            elif choix == "5":
                if not historique:
                    print("ğŸ“­ Aucune conversion dans l'historique")
                else:
                    print(f"\nğŸ“š Historique des conversions ({len(historique)} tentative(s)) :")
                    print("â•" * 80)

                    for i, conv in enumerate(historique, 1):
                        statut = "âœ…" if conv['succes'] else "âŒ"
                        print(f"{i:2d}. {statut} '{conv['chaine']}' â†’ {conv['type_cible']}")

                        if conv['succes']:
                            print(f"      â””â”€ RÃ©sultat : {repr(conv['resultat'])}")
                        else:
                            print(f"      â””â”€ Erreur : {conv['resultat']}")

                    # Statistiques
                    reussites = sum(1 for conv in historique if conv['succes'])
                    echecs = len(historique) - reussites

                    print("â•" * 80)
                    print(f"ğŸ“Š Statistiques :")
                    print(f"   â€¢ Conversions rÃ©ussies : {reussites}")
                    print(f"   â€¢ Conversions Ã©chouÃ©es : {echecs}")
                    if historique:
                        taux_reussite = (reussites / len(historique)) * 100
                        print(f"   â€¢ Taux de rÃ©ussite : {taux_reussite:.1f}%")

            elif choix == "6":
                if historique:
                    reussites = sum(1 for conv in historique if conv['succes'])
                    print(f"\nğŸ“‹ RÃ©sumÃ© de la session :")
                    print(f"   â€¢ {len(historique)} conversion(s) tentÃ©e(s)")
                    print(f"   â€¢ {reussites} conversion(s) rÃ©ussie(s)")

                print("\nğŸ‘‹ Merci d'avoir utilisÃ© le convertisseur de types !")
                print("Ã€ bientÃ´t ! ğŸ”„")
                break

            else:
                print("âŒ Choix invalide. Veuillez entrer un nombre entre 1 et 6.")

        except KeyboardInterrupt:
            print(f"\n\nâ¹ï¸ Programme interrompu par l'utilisateur")
            if historique:
                print(f"ğŸ“š Conversions tentÃ©es : {len(historique)}")
            print("ğŸ‘‹ Au revoir !")
            break

        except Exception as e:
            print(f"âŒ Erreur inattendue dans le menu : {e}")
            print("ğŸ”„ Retour au menu principal...")

if __name__ == "__main__":
    main()
```

## Tests Ã  effectuer

### Tests pour int
- `"42"` â†’ 42
- `"-17"` â†’ -17
- `"0b1010"` â†’ 10 (binaire)
- `"0x1A"` â†’ 26 (hexadÃ©cimal)
- `"abc"` â†’ erreur
- `"3.14"` â†’ erreur

### Tests pour float
- `"3.14"` â†’ 3.14
- `"-2.5e3"` â†’ -2500.0
- `"inf"` â†’ inf
- `"nan"` â†’ nan
- `"hello"` â†’ erreur

### Tests pour bool
- `"true"` â†’ True
- `"false"` â†’ False
- `"oui"` â†’ True
- `"non"` â†’ False
- `"1"` â†’ True
- `"0"` â†’ False

### Tests pour list
- `"[1, 2, 3]"` â†’ [1, 2, 3]
- `"a, b, c"` â†’ ['a', 'b', 'c']
- `"un deux trois"` â†’ ['un', 'deux', 'trois']
- `"[]"` â†’ []

## CritÃ¨res d'Ã©valuation

- âœ… **Gestion d'erreurs complÃ¨te** : ValueError, cas spÃ©ciaux
- âœ… **Conversions intelligentes** : DÃ©tection automatique des formats
- âœ… **Interface utilisateur claire** : Menus et messages explicites
- âœ… **Historique fonctionnel** : Stockage et statistiques
- âœ… **Support de formats avancÃ©s** : Binaire, hexadÃ©cimal, boolÃ©ens intelligents
- âœ… **Code sÃ©curisÃ©** : Pas d'utilisation d'eval()
- âœ… **Informations dÃ©taillÃ©es** : Type, valeur, reprÃ©sentation

## Extensions possibles

- Support de types complexes (complex)
- Conversion vers tuple et set
- DÃ©tection automatique du meilleur type
- Export de l'historique
- Mode batch pour convertir plusieurs valeurs
