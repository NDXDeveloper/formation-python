# Exercice 3 : Convertisseur de types s√©curis√©

## Objectif

Cr√©er un programme qui convertit des cha√Ænes de caract√®res vers diff√©rents types Python avec une gestion compl√®te des erreurs.

## Cahier des charges

1. **Proposer de convertir** une cha√Æne vers diff√©rents types
2. **Types support√©s** : int, float, bool, list (avec conversion s√©curis√©e)
3. **G√©rer toutes les erreurs** de conversion possibles
4. **Afficher le r√©sultat** et le type de la conversion
5. **Permettre plusieurs conversions** successives

## Code de base √† compl√©ter

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 3 : Convertisseur de types s√©curis√©
Module 1.5 - Gestion des erreurs avec try/except
"""

def convertir_vers_int(chaine):
    """
    Convertit une cha√Æne vers un entier.

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    # TODO: Impl√©menter la fonction
    pass

def convertir_vers_float(chaine):
    """
    Convertit une cha√Æne vers un float.

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    # TODO: Impl√©menter la fonction
    pass

def convertir_vers_bool(chaine):
    """
    Convertit une cha√Æne vers un bool√©en.

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    # TODO: Impl√©menter la fonction
    pass

def convertir_vers_list(chaine):
    """
    Convertit une cha√Æne vers une liste (s√©curis√©).

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    # TODO: Impl√©menter la fonction
    pass

def main():
    """Fonction principale du convertisseur."""
    print("üîÑ === CONVERTISSEUR DE TYPES S√âCURIS√â ===")

    while True:
        try:
            # TODO: Impl√©menter la logique principale
            pass

        except KeyboardInterrupt:
            # TODO: G√©rer l'interruption clavier
            pass

if __name__ == "__main__":
    main()
```

## Solution compl√®te

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exercice 3 : Convertisseur de types s√©curis√© - SOLUTION
Module 1.5 - Gestion des erreurs avec try/except
"""

import re

def convertir_vers_int(chaine):
    """
    Convertit une cha√Æne vers un entier.

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    try:
        # Nettoyer la cha√Æne
        chaine_propre = chaine.strip()

        # Cas sp√©ciaux
        if not chaine_propre:
            return False, "Cha√Æne vide"

        # V√©rifier les pr√©fixes pour diff√©rentes bases
        if chaine_propre.startswith('0b'):
            # Binaire
            valeur = int(chaine_propre, 2)
            return True, valeur
        elif chaine_propre.startswith('0o'):
            # Octal
            valeur = int(chaine_propre, 8)
            return True, valeur
        elif chaine_propre.startswith('0x'):
            # Hexad√©cimal
            valeur = int(chaine_propre, 16)
            return True, valeur
        else:
            # D√©cimal standard
            valeur = int(chaine_propre)
            return True, valeur

    except ValueError as e:
        return False, f"Conversion impossible : {e}"
    except Exception as e:
        return False, f"Erreur inattendue : {e}"

def convertir_vers_float(chaine):
    """
    Convertit une cha√Æne vers un float.

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    try:
        chaine_propre = chaine.strip()

        if not chaine_propre:
            return False, "Cha√Æne vide"

        # Cas sp√©ciaux
        if chaine_propre.lower() in ['inf', 'infinity', '+inf', '+infinity']:
            return True, float('inf')
        elif chaine_propre.lower() in ['-inf', '-infinity']:
            return True, float('-inf')
        elif chaine_propre.lower() in ['nan', 'not a number']:
            return True, float('nan')

        # Conversion standard
        valeur = float(chaine_propre)
        return True, valeur

    except ValueError as e:
        return False, f"Conversion impossible : {e}"
    except Exception as e:
        return False, f"Erreur inattendue : {e}"

def convertir_vers_bool(chaine):
    """
    Convertit une cha√Æne vers un bool√©en de mani√®re intelligente.

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    try:
        chaine_propre = chaine.strip().lower()

        if not chaine_propre:
            return True, False  # Cha√Æne vide = False

        # Valeurs explicitement vraies
        valeurs_vraies = [
            'true', 'vrai', 'yes', 'oui', 'y', 'o', '1',
            'on', 'actif', 'activ√©', 'enabled', 'active'
        ]

        # Valeurs explicitement fausses
        valeurs_fausses = [
            'false', 'faux', 'no', 'non', 'n', '0',
            'off', 'inactif', 'd√©sactiv√©', 'disabled', 'inactive'
        ]

        if chaine_propre in valeurs_vraies:
            return True, True
        elif chaine_propre in valeurs_fausses:
            return True, False
        else:
            # Essayer la conversion Python standard
            # En Python, toute cha√Æne non vide est True
            valeur = bool(chaine)
            return True, valeur

    except Exception as e:
        return False, f"Erreur inattendue : {e}"

def convertir_vers_list(chaine):
    """
    Convertit une cha√Æne vers une liste de mani√®re s√©curis√©e.

    Args:
        chaine (str): Cha√Æne √† convertir

    Returns:
        tuple: (succ√®s, valeur_ou_erreur)
    """
    try:
        chaine_propre = chaine.strip()

        if not chaine_propre:
            return True, []

        # M√©thode 1: Format [item1, item2, item3]
        if chaine_propre.startswith('[') and chaine_propre.endswith(']'):
            contenu = chaine_propre[1:-1].strip()
            if not contenu:
                return True, []

            # S√©parer par virgules et nettoyer
            elements = []
            for element in contenu.split(','):
                element = element.strip()

                # Essayer de d√©tecter le type de chaque √©l√©ment
                if element.startswith('"') and element.endswith('"'):
                    # Cha√Æne entre guillemets
                    elements.append(element[1:-1])
                elif element.startswith("'") and element.endswith("'"):
                    # Cha√Æne entre apostrophes
                    elements.append(element[1:-1])
                elif element.lower() in ['true', 'false']:
                    # Bool√©en
                    elements.append(element.lower() == 'true')
                elif element.isdigit() or (element.startswith('-') and element[1:].isdigit()):
                    # Entier
                    elements.append(int(element))
                elif '.' in element:
                    try:
                        # Float
                        elements.append(float(element))
                    except ValueError:
                        # Garder comme cha√Æne
                        elements.append(element)
                else:
                    # Garder comme cha√Æne
                    elements.append(element)

            return True, elements

        # M√©thode 2: S√©paration par virgules simple
        elif ',' in chaine_propre:
            elements = [elem.strip() for elem in chaine_propre.split(',')]
            return True, elements

        # M√©thode 3: S√©paration par espaces
        elif ' ' in chaine_propre:
            elements = chaine_propre.split()
            return True, elements

        # M√©thode 4: Un seul √©l√©ment
        else:
            return True, [chaine_propre]

    except Exception as e:
        return False, f"Erreur lors de la conversion : {e}"

def afficher_resultat(succes, valeur, type_cible):
    """
    Affiche le r√©sultat d'une conversion.

    Args:
        succes (bool): Si la conversion a r√©ussi
        valeur: La valeur convertie ou le message d'erreur
        type_cible (str): Le type vers lequel on a tent√© de convertir
    """
    if succes:
        print(f"‚úÖ Conversion vers {type_cible} r√©ussie :")
        print(f"   üìÑ Valeur : {repr(valeur)}")
        print(f"   üîß Type Python : {type(valeur).__name__}")

        # Informations additionnelles selon le type
        if isinstance(valeur, int):
            print(f"   üìä Valeur en binaire : {bin(valeur)}")
            print(f"   üìä Valeur en hexad√©cimal : {hex(valeur)}")
        elif isinstance(valeur, float):
            if valeur.is_integer():
                print(f"   ‚ÑπÔ∏è  Nombre d√©cimal sans partie fractionnaire")
            print(f"   üìä Notation scientifique : {valeur:.2e}")
        elif isinstance(valeur, list):
            print(f"   üìä Nombre d'√©l√©ments : {len(valeur)}")
            if valeur:
                types_elements = [type(elem).__name__ for elem in valeur]
                print(f"   üìä Types des √©l√©ments : {', '.join(set(types_elements))}")
    else:
        print(f"‚ùå Conversion vers {type_cible} √©chou√©e :")
        print(f"   üìÑ Erreur : {valeur}")

def main():
    """Fonction principale du convertisseur."""
    print("üîÑ === CONVERTISSEUR DE TYPES S√âCURIS√â ===")
    print("Convertit des cha√Ænes de caract√®res vers diff√©rents types Python")

    conversions = {
        '1': ('int', convertir_vers_int),
        '2': ('float', convertir_vers_float),
        '3': ('bool', convertir_vers_bool),
        '4': ('list', convertir_vers_list)
    }

    historique = []

    while True:
        try:
            print("\n" + "‚îÄ" * 60)
            print("üîÑ Types de conversion disponibles :")
            print("1. üî¢ Entier (int)")
            print("2. üî¢ Nombre d√©cimal (float)")
            print("3. ‚úÖ Bool√©en (bool)")
            print("4. üìã Liste (list)")
            print("5. üìö Afficher l'historique")
            print("6. ‚ùå Quitter")

            choix = input("\nVotre choix (1-6) : ").strip()

            if choix in conversions:
                type_nom, fonction_conversion = conversions[choix]

                print(f"\nüîÑ Conversion vers {type_nom}")
                chaine = input("Cha√Æne √† convertir : ")

                print(f"üîç Tentative de conversion de '{chaine}' vers {type_nom}...")
                succes, resultat = fonction_conversion(chaine)

                afficher_resultat(succes, resultat, type_nom)

                # Ajouter √† l'historique
                historique.append({
                    'chaine': chaine,
                    'type_cible': type_nom,
                    'succes': succes,
                    'resultat': resultat
                })

            elif choix == "5":
                if not historique:
                    print("üì≠ Aucune conversion dans l'historique")
                else:
                    print(f"\nüìö Historique des conversions ({len(historique)} tentative(s)) :")
                    print("‚ïê" * 80)

                    for i, conv in enumerate(historique, 1):
                        statut = "‚úÖ" if conv['succes'] else "‚ùå"
                        print(f"{i:2d}. {statut} '{conv['chaine']}' ‚Üí {conv['type_cible']}")

                        if conv['succes']:
                            print(f"      ‚îî‚îÄ R√©sultat : {repr(conv['resultat'])}")
                        else:
                            print(f"      ‚îî‚îÄ Erreur : {conv['resultat']}")

                    # Statistiques
                    reussites = sum(1 for conv in historique if conv['succes'])
                    echecs = len(historique) - reussites

                    print("‚ïê" * 80)
                    print(f"üìä Statistiques :")
                    print(f"   ‚Ä¢ Conversions r√©ussies : {reussites}")
                    print(f"   ‚Ä¢ Conversions √©chou√©es : {echecs}")
                    if historique:
                        taux_reussite = (reussites / len(historique)) * 100
                        print(f"   ‚Ä¢ Taux de r√©ussite : {taux_reussite:.1f}%")

            elif choix == "6":
                if historique:
                    reussites = sum(1 for conv in historique if conv['succes'])
                    print(f"\nüìã R√©sum√© de la session :")
                    print(f"   ‚Ä¢ {len(historique)} conversion(s) tent√©e(s)")
                    print(f"   ‚Ä¢ {reussites} conversion(s) r√©ussie(s)")

                print("\nüëã Merci d'avoir utilis√© le convertisseur de types !")
                print("√Ä bient√¥t ! üîÑ")
                break

            else:
                print("‚ùå Choix invalide. Veuillez entrer un nombre entre 1 et 6.")

        except KeyboardInterrupt:
            print(f"\n\n‚èπÔ∏è Programme interrompu par l'utilisateur")
            if historique:
                print(f"üìö Conversions tent√©es : {len(historique)}")
            print("üëã Au revoir !")
            break

        except Exception as e:
            print(f"‚ùå Erreur inattendue dans le menu : {e}")
            print("üîÑ Retour au menu principal...")

if __name__ == "__main__":
    main()
```

## Tests √† effectuer

### Tests pour int
- `"42"` ‚Üí 42
- `"-17"` ‚Üí -17
- `"0b1010"` ‚Üí 10 (binaire)
- `"0x1A"` ‚Üí 26 (hexad√©cimal)
- `"abc"` ‚Üí erreur
- `"3.14"` ‚Üí erreur

### Tests pour float
- `"3.14"` ‚Üí 3.14
- `"-2.5e3"` ‚Üí -2500.0
- `"inf"` ‚Üí inf
- `"nan"` ‚Üí nan
- `"hello"` ‚Üí erreur

### Tests pour bool
- `"true"` ‚Üí True
- `"false"` ‚Üí False
- `"oui"` ‚Üí True
- `"non"` ‚Üí False
- `"1"` ‚Üí True
- `"0"` ‚Üí False

### Tests pour list
- `"[1, 2, 3]"` ‚Üí [1, 2, 3]
- `"a, b, c"` ‚Üí ['a', 'b', 'c']
- `"un deux trois"` ‚Üí ['un', 'deux', 'trois']
- `"[]"` ‚Üí []

## Crit√®res d'√©valuation

- ‚úÖ **Gestion d'erreurs compl√®te** : ValueError, cas sp√©ciaux
- ‚úÖ **Conversions intelligentes** : D√©tection automatique des formats
- ‚úÖ **Interface utilisateur claire** : Menus et messages explicites
- ‚úÖ **Historique fonctionnel** : Stockage et statistiques
- ‚úÖ **Support de formats avanc√©s** : Binaire, hexad√©cimal, bool√©ens intelligents
- ‚úÖ **Code s√©curis√©** : Pas d'utilisation d'eval()
- ‚úÖ **Informations d√©taill√©es** : Type, valeur, repr√©sentation

## Extensions possibles

- Support de types complexes (complex)
- Conversion vers tuple et set
- D√©tection automatique du meilleur type
- Export de l'historique
- Mode batch pour convertir plusieurs valeurs
