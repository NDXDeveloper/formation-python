üîù Retour au [Sommaire](/SOMMAIRE.md)

# 10.4 : Documentation avec docstrings

## Introduction

Imaginez que vous trouvez une bo√Æte myst√©rieuse dans votre grenier. Sans √©tiquette, sans notice, impossible de savoir ce qu'elle contient ou √† quoi elle sert ! Votre code sans documentation, c'est exactement pareil : m√™me si vous l'avez √©crit, dans quelques mois vous ne vous souviendrez plus de ce qu'il fait ni comment l'utiliser.

Les **docstrings** (cha√Ænes de documentation) sont comme des √©tiquettes intelligentes pour votre code. Elles expliquent ce que fait chaque fonction, comment l'utiliser, et quoi attendre en retour. Elles transforment votre code en une biblioth√®que bien organis√©e o√π tout est clairement √©tiquet√© !

## Qu'est-ce qu'une docstring ?

### D√©finition simple
Une docstring est une cha√Æne de caract√®res qui appara√Æt en premi√®re position dans une fonction, classe ou module pour expliquer ce qu'elle fait.

### Exemple basique
```python
def additionner(a, b):
    """
    Additionne deux nombres et retourne le r√©sultat.

    Cette fonction prend deux nombres en param√®tres
    et retourne leur somme.
    """
    return a + b

# La docstring est accessible avec help() ou __doc__
print(additionner.__doc__)
help(additionner)
```

### Pourquoi les docstrings sont importantes

#### 1. Pour vous dans 6 mois
```python
# ‚ùå Sans docstring - myst√©rieux
def calcul_tva(p, t):
    return p * (1 + t)

# ‚úÖ Avec docstring - clair !
def calcul_tva(prix_ht, taux_tva):
    """
    Calcule le prix TTC √† partir du prix HT et du taux de TVA.

    Args:
        prix_ht (float): Prix hors taxes en euros
        taux_tva (float): Taux de TVA (ex: 0.20 pour 20%)

    Returns:
        float: Prix toutes taxes comprises

    Example:
        >>> calcul_tva(100, 0.20)
        120.0
    """
    return prix_ht * (1 + taux_tva)
```

#### 2. Pour vos coll√®gues
```python
class GestionnaireUtilisateurs:
    """
    Gestionnaire pour les op√©rations sur les utilisateurs.

    Cette classe fournit des m√©thodes pour cr√©er, modifier,
    supprimer et rechercher des utilisateurs dans le syst√®me.

    Attributes:
        users (dict): Dictionnaire stockant les utilisateurs
        next_id (int): Prochain ID disponible pour un nouvel utilisateur

    Example:
        >>> gestionnaire = GestionnaireUtilisateurs()
        >>> user_id = gestionnaire.ajouter_utilisateur("Alice", "alice@test.com")
        >>> utilisateur = gestionnaire.obtenir_utilisateur(user_id)
    """

    def __init__(self):
        """Initialise un gestionnaire vide."""
        self.users = {}
        self.next_id = 1
```

#### 3. Pour les outils automatiques
```python
def diviser(a, b):
    """
    Divise le premier nombre par le second.

    Args:
        a (float): Le dividende
        b (float): Le diviseur

    Returns:
        float: Le r√©sultat de la division

    Raises:
        ZeroDivisionError: Si b est √©gal √† z√©ro
        TypeError: Si a ou b ne sont pas des nombres

    Example:
        >>> diviser(10, 2)
        5.0
        >>> diviser(7, 2)
        3.5
    """
    if b == 0:
        raise ZeroDivisionError("Division par z√©ro impossible")
    return a / b

# Les IDE peuvent utiliser cette documentation pour l'autocompl√©tion !
```

## Formats de docstrings

### 1. Format Google (recommand√© pour les d√©butants)

```python
def rechercher_utilisateur(nom, age_min=None, age_max=None, actif=True):
    """
    Recherche des utilisateurs selon des crit√®res.

    Cette fonction permet de chercher des utilisateurs dans la base
    en appliquant diff√©rents filtres optionnels.

    Args:
        nom (str): Nom ou partie du nom √† rechercher
        age_min (int, optional): √Çge minimum. D√©faut √† None.
        age_max (int, optional): √Çge maximum. D√©faut √† None.
        actif (bool, optional): Rechercher seulement les utilisateurs actifs.
            D√©faut √† True.

    Returns:
        list[dict]: Liste des utilisateurs trouv√©s. Chaque utilisateur
            est repr√©sent√© par un dictionnaire avec les cl√©s:
            - 'id': Identifiant unique
            - 'nom': Nom complet
            - 'age': √Çge en ann√©es
            - 'email': Adresse email

    Raises:
        ValueError: Si nom est vide ou si age_min > age_max
        DatabaseError: Si la connexion √† la base √©choue

    Example:
        >>> utilisateurs = rechercher_utilisateur("Alice")
        >>> print(len(utilisateurs))
        2

        >>> seniors = rechercher_utilisateur("", age_min=65)
        >>> for user in seniors:
        ...     print(user['nom'])
        Robert Dupont
        Marie Martin

    Note:
        La recherche est insensible √† la casse pour le nom.
        Les utilisateurs supprim√©s ne sont jamais retourn√©s.
    """
    if not nom.strip():
        raise ValueError("Le nom ne peut pas √™tre vide")

    if age_min and age_max and age_min > age_max:
        raise ValueError("age_min ne peut pas √™tre sup√©rieur √† age_max")

    # Impl√©mentation de la recherche...
    return []
```

### 2. Format NumPy (pour la documentation scientifique)

```python
def calculer_statistiques(donnees, inclure_ecart_type=True):
    """
    Calcule des statistiques descriptives sur un ensemble de donn√©es.

    Cette fonction analyse un tableau de nombres et calcule
    diverses mesures statistiques utiles pour l'analyse.

    Parameters
    ----------
    donnees : array_like
        Tableau de nombres √† analyser. Peut √™tre une liste,
        un tuple ou un array NumPy.
    inclure_ecart_type : bool, optional
        Si True, calcule l'√©cart-type en plus des autres statistiques.
        Par d√©faut True.

    Returns
    -------
    dict
        Dictionnaire contenant les statistiques calcul√©es:

        - 'moyenne' : float
            Moyenne arithm√©tique des donn√©es
        - 'mediane' : float
            Valeur m√©diane des donn√©es
        - 'min' : float
            Valeur minimale
        - 'max' : float
            Valeur maximale
        - 'ecart_type' : float, optional
            √âcart-type (seulement si inclure_ecart_type=True)

    Raises
    ------
    ValueError
        Si la liste de donn√©es est vide
    TypeError
        Si les donn√©es contiennent des √©l√©ments non num√©riques

    Examples
    --------
    >>> donnees = [1, 2, 3, 4, 5]
    >>> stats = calculer_statistiques(donnees)
    >>> print(stats['moyenne'])
    3.0

    >>> stats_simples = calculer_statistiques([10, 20, 30], inclure_ecart_type=False)
    >>> 'ecart_type' in stats_simples
    False

    Notes
    -----
    L'√©cart-type est calcul√© avec la formule de l'√©cart-type
    de la population (division par N), pas de l'√©chantillon (N-1).
    """
    import statistics

    if not donnees:
        raise ValueError("La liste de donn√©es ne peut pas √™tre vide")

    # V√©rifier que tous les √©l√©ments sont num√©riques
    try:
        donnees_numeriques = [float(x) for x in donnees]
    except (ValueError, TypeError):
        raise TypeError("Tous les √©l√©ments doivent √™tre num√©riques")

    resultats = {
        'moyenne': statistics.mean(donnees_numeriques),
        'mediane': statistics.median(donnees_numeriques),
        'min': min(donnees_numeriques),
        'max': max(donnees_numeriques)
    }

    if inclure_ecart_type:
        resultats['ecart_type'] = statistics.stdev(donnees_numeriques)

    return resultats
```

### 3. Format Sphinx (format flexible)

```python
def telecharger_fichier(url, destination, timeout=30, retry=3):
    """
    T√©l√©charge un fichier depuis une URL vers le syst√®me local.

    :param url: URL du fichier √† t√©l√©charger
    :type url: str
    :param destination: Chemin local o√π sauvegarder le fichier
    :type destination: str or Path
    :param timeout: D√©lai d'attente en secondes pour la requ√™te
    :type timeout: int
    :param retry: Nombre de tentatives en cas d'√©chec
    :type retry: int
    :return: True si le t√©l√©chargement a r√©ussi, False sinon
    :rtype: bool
    :raises ValueError: Si l'URL est invalide
    :raises FileNotFoundError: Si le dossier de destination n'existe pas
    :raises requests.RequestException: En cas d'erreur r√©seau

    .. note::
       Le fichier est t√©l√©charg√© en mode streaming pour √©conomiser
       la m√©moire avec les gros fichiers.

    .. warning::
       Cette fonction √©crase le fichier de destination s'il existe d√©j√†.

    Example:
        >>> success = telecharger_fichier(
        ...     'https://example.com/data.csv',
        ...     '/tmp/ma_donnee.csv',
        ...     timeout=60
        ... )
        >>> if success:
        ...     print("T√©l√©chargement r√©ussi !")
    """
    import requests
    from pathlib import Path

    # Validation de l'URL
    if not url.startswith(('http://', 'https://')):
        raise ValueError("URL invalide : doit commencer par http:// ou https://")

    # Validation du dossier de destination
    dest_path = Path(destination)
    if not dest_path.parent.exists():
        raise FileNotFoundError(f"Le dossier {dest_path.parent} n'existe pas")

    # Tentatives de t√©l√©chargement
    for tentative in range(retry):
        try:
            response = requests.get(url, timeout=timeout, stream=True)
            response.raise_for_status()

            with open(dest_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)

            return True

        except requests.RequestException as e:
            if tentative == retry - 1:  # Derni√®re tentative
                raise e
            continue

    return False
```

## Docstrings pour les classes

### Classe compl√®te avec docstrings

```python
class CompteBancaire:
    """
    Repr√©sente un compte bancaire avec les op√©rations de base.

    Cette classe permet de g√©rer un compte bancaire simple avec
    des op√©rations de d√©p√¥t, retrait et consultation du solde.
    Un historique des transactions est automatiquement maintenu.

    Attributes:
        numero_compte (str): Num√©ro unique du compte
        titulaire (str): Nom du titulaire du compte
        solde (float): Solde actuel du compte en euros
        historique (list): Liste des transactions effectu√©es

    Example:
        >>> compte = CompteBancaire("123456", "Alice Dupont", 1000.0)
        >>> compte.deposer(500.0)
        1500.0
        >>> compte.retirer(200.0)
        1300.0
        >>> print(len(compte.historique))
        2
    """

    def __init__(self, numero_compte, titulaire, solde_initial=0.0):
        """
        Initialise un nouveau compte bancaire.

        Args:
            numero_compte (str): Num√©ro unique du compte
            titulaire (str): Nom du titulaire
            solde_initial (float, optional): Solde de d√©part. D√©faut √† 0.0.

        Raises:
            ValueError: Si le solde initial est n√©gatif
            TypeError: Si numero_compte ou titulaire ne sont pas des cha√Ænes

        Example:
            >>> compte = CompteBancaire("123456", "Alice", 1000.0)
            >>> compte.solde
            1000.0
        """
        if not isinstance(numero_compte, str):
            raise TypeError("Le num√©ro de compte doit √™tre une cha√Æne")

        if not isinstance(titulaire, str):
            raise TypeError("Le titulaire doit √™tre une cha√Æne")

        if solde_initial < 0:
            raise ValueError("Le solde initial ne peut pas √™tre n√©gatif")

        self.numero_compte = numero_compte
        self.titulaire = titulaire
        self.solde = float(solde_initial)
        self.historique = []

        # Enregistrer la cr√©ation du compte
        self._ajouter_transaction("OUVERTURE", solde_initial)

    def deposer(self, montant):
        """
        Effectue un d√©p√¥t sur le compte.

        Args:
            montant (float): Montant √† d√©poser (doit √™tre positif)

        Returns:
            float: Nouveau solde apr√®s le d√©p√¥t

        Raises:
            ValueError: Si le montant est n√©gatif ou nul
            TypeError: Si le montant n'est pas un nombre

        Example:
            >>> compte = CompteBancaire("123", "Alice", 100)
            >>> nouveau_solde = compte.deposer(50)
            >>> print(nouveau_solde)
            150.0
        """
        if not isinstance(montant, (int, float)):
            raise TypeError("Le montant doit √™tre un nombre")

        if montant <= 0:
            raise ValueError("Le montant doit √™tre positif")

        self.solde += montant
        self._ajouter_transaction("DEPOT", montant)
        return self.solde

    def retirer(self, montant):
        """
        Effectue un retrait du compte.

        Args:
            montant (float): Montant √† retirer (doit √™tre positif)

        Returns:
            float: Nouveau solde apr√®s le retrait

        Raises:
            ValueError: Si le montant est n√©gatif, nul, ou sup√©rieur au solde
            TypeError: Si le montant n'est pas un nombre

        Example:
            >>> compte = CompteBancaire("123", "Alice", 100)
            >>> nouveau_solde = compte.retirer(30)
            >>> print(nouveau_solde)
            70.0
        """
        if not isinstance(montant, (int, float)):
            raise TypeError("Le montant doit √™tre un nombre")

        if montant <= 0:
            raise ValueError("Le montant doit √™tre positif")

        if montant > self.solde:
            raise ValueError("Solde insuffisant")

        self.solde -= montant
        self._ajouter_transaction("RETRAIT", -montant)
        return self.solde

    def obtenir_solde(self):
        """
        Retourne le solde actuel du compte.

        Returns:
            float: Solde actuel en euros

        Example:
            >>> compte = CompteBancaire("123", "Alice", 100)
            >>> print(compte.obtenir_solde())
            100.0
        """
        return self.solde

    def obtenir_historique(self):
        """
        Retourne l'historique des transactions.

        Returns:
            list[dict]: Liste des transactions. Chaque transaction
                est un dictionnaire avec les cl√©s:
                - 'type': Type de transaction ('DEPOT', 'RETRAIT', 'OUVERTURE')
                - 'montant': Montant de la transaction
                - 'date': Date et heure de la transaction
                - 'solde_apres': Solde apr√®s la transaction

        Example:
            >>> compte = CompteBancaire("123", "Alice", 100)
            >>> compte.deposer(50)
            150.0
            >>> historique = compte.obtenir_historique()
            >>> len(historique)
            2
            >>> historique[0]['type']
            'OUVERTURE'
        """
        return self.historique.copy()

    def _ajouter_transaction(self, type_transaction, montant):
        """
        Ajoute une transaction √† l'historique (m√©thode priv√©e).

        Args:
            type_transaction (str): Type de transaction
            montant (float): Montant de la transaction

        Note:
            Cette m√©thode est priv√©e (pr√©fixe _) et ne devrait pas
            √™tre appel√©e directement par les utilisateurs de la classe.
        """
        from datetime import datetime

        transaction = {
            'type': type_transaction,
            'montant': montant,
            'date': datetime.now(),
            'solde_apres': self.solde
        }
        self.historique.append(transaction)

    def __str__(self):
        """
        Retourne une repr√©sentation textuelle du compte.

        Returns:
            str: Description du compte

        Example:
            >>> compte = CompteBancaire("123456", "Alice Dupont", 1000)
            >>> print(compte)
            Compte 123456 - Alice Dupont - Solde: 1000.00‚Ç¨
        """
        return f"Compte {self.numero_compte} - {self.titulaire} - Solde: {self.solde:.2f}‚Ç¨"

    def __repr__(self):
        """
        Retourne une repr√©sentation technique du compte.

        Returns:
            str: Repr√©sentation technique pour le debugging

        Example:
            >>> compte = CompteBancaire("123456", "Alice", 1000)
            >>> repr(compte)
            "CompteBancaire('123456', 'Alice', 1000.0)"
        """
        return f"CompteBancaire('{self.numero_compte}', '{self.titulaire}', {self.solde})"
```

## Docstrings pour les modules

```python
"""
Module de gestion des comptes bancaires.

Ce module fournit des classes et fonctions pour g√©rer
des comptes bancaires simples avec les op√©rations de base.

Classes:
    CompteBancaire: Repr√©sente un compte bancaire individuel
    GestionnaireComptes: Gestionnaire pour plusieurs comptes

Fonctions:
    calculer_interets: Calcule les int√©r√™ts sur un solde
    valider_numero_compte: Valide le format d'un num√©ro de compte

Example:
    >>> from banking import CompteBancaire, calculer_interets
    >>> compte = CompteBancaire("123456", "Alice", 1000)
    >>> interets = calculer_interets(compte.obtenir_solde(), 0.02)
    >>> print(f"Int√©r√™ts: {interets}‚Ç¨")
    Int√©r√™ts: 20.0‚Ç¨

Author: Votre Nom
Date: 2025-01-07
Version: 1.0.0
"""

__version__ = "1.0.0"
__author__ = "Votre Nom"
__email__ = "votre.email@example.com"

# Le reste du code du module...
```

## Doctests : Tests dans la documentation

### Concept des doctests

```python
def factorielle(n):
    """
    Calcule la factorielle d'un nombre entier positif.

    La factorielle de n (not√©e n!) est le produit de tous
    les entiers positifs inf√©rieurs ou √©gaux √† n.

    Args:
        n (int): Nombre entier positif

    Returns:
        int: Factorielle de n

    Raises:
        ValueError: Si n est n√©gatif
        TypeError: Si n n'est pas un entier

    Example:
        >>> factorielle(0)
        1
        >>> factorielle(1)
        1
        >>> factorielle(5)
        120
        >>> factorielle(3)
        6

        # Test d'erreur
        >>> factorielle(-1)
        Traceback (most recent call last):
            ...
        ValueError: n doit √™tre positif ou nul

        >>> factorielle("abc")
        Traceback (most recent call last):
            ...
        TypeError: n doit √™tre un entier
    """
    if not isinstance(n, int):
        raise TypeError("n doit √™tre un entier")

    if n < 0:
        raise ValueError("n doit √™tre positif ou nul")

    if n <= 1:
        return 1

    resultat = 1
    for i in range(2, n + 1):
        resultat *= i

    return resultat

# Ex√©cution des doctests
if __name__ == "__main__":
    import doctest
    doctest.testmod(verbose=True)
```

### Doctests avanc√©s

```python
def formater_prix(prix, devise="EUR", precision=2):
    """
    Formate un prix avec devise et pr√©cision.

    Args:
        prix (float): Prix √† formater
        devise (str): Code de devise (EUR, USD, etc.)
        precision (int): Nombre de d√©cimales

    Returns:
        str: Prix format√©

    Example:
        Tests basiques:
        >>> formater_prix(12.34)
        '12.34 EUR'

        >>> formater_prix(12.34, "USD")
        '12.34 USD'

        >>> formater_prix(12.3456, precision=3)
        '12.346 EUR'

        Tests avec diff√©rents types:
        >>> formater_prix(10)
        '10.00 EUR'

        >>> formater_prix(0)
        '0.00 EUR'

        Tests de cas limites:
        >>> formater_prix(1234.5678, "JPY", 0)
        '1235 JPY'

        >>> formater_prix(0.001, precision=3)
        '0.001 EUR'

        Tests avec des valeurs particuli√®res:
        >>> import math
        >>> formater_prix(math.pi, precision=4)
        '3.1416 EUR'
    """
    prix_arrondi = round(float(prix), precision)

    if precision == 0:
        return f"{prix_arrondi:.0f} {devise}"
    else:
        format_str = f"{{:.{precision}f}} {{}}"
        return format_str.format(prix_arrondi, devise)

# Test des doctests
if __name__ == "__main__":
    import doctest
    # Test avec reporting d√©taill√©
    doctest.testmod(verbose=True)
```

## G√©n√©ration automatique de documentation

### Utilisation de Sphinx

#### Installation
```bash
pip install sphinx sphinx-autodoc-typehints
```

#### Configuration de base (conf.py)
```python
# conf.py pour Sphinx
import os
import sys
sys.path.insert(0, os.path.abspath('..'))

project = 'Mon Projet'
copyright = '2025, Mon Nom'
author = 'Mon Nom'
version = '1.0.0'

extensions = [
    'sphinx.ext.autodoc',       # G√©n√©ration auto depuis docstrings
    'sphinx.ext.viewcode',      # Liens vers code source
    'sphinx.ext.napoleon',      # Support Google/NumPy style
    'sphinx.ext.doctest',       # Support des doctests
    'sphinx_autodoc_typehints', # Support des type hints
]

html_theme = 'sphinx_rtd_theme'  # Th√®me Read The Docs

# Configuration Napoleon pour Google style
napoleon_google_docstring = True
napoleon_numpy_docstring = True
napoleon_include_init_with_doc = False
napoleon_include_private_with_doc = False
```

#### Structure pour Sphinx
```
docs/
‚îú‚îÄ‚îÄ conf.py
‚îú‚îÄ‚îÄ index.rst
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ banking.rst
‚îÇ   ‚îî‚îÄ‚îÄ utils.rst
‚îî‚îÄ‚îÄ _build/
```

#### Fichier index.rst
```rst
Mon Projet Documentation
========================

Bienvenue dans la documentation de Mon Projet !

.. toctree::
   :maxdepth: 2
   :caption: Contenu:

   modules/banking
   modules/utils

Indices et tables
=================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
```

#### Fichier banking.rst
```rst
Module Banking
==============

.. automodule:: banking
   :members:
   :undoc-members:
   :show-inheritance:
```

### G√©n√©ration de la documentation
```bash
# Initialisation
sphinx-quickstart docs

# G√©n√©ration
cd docs
make html

# La documentation est g√©n√©r√©e dans docs/_build/html/
```

## Type hints et documentation

### Combinaison type hints + docstrings

```python
from typing import List, Dict, Optional, Union
from datetime import datetime

def analyser_ventes(
    ventes: List[Dict[str, Union[str, float, datetime]]],
    periode_debut: Optional[datetime] = None,
    periode_fin: Optional[datetime] = None,
    grouper_par: str = "mois"
) -> Dict[str, float]:
    """
    Analyse les donn√©es de ventes et retourne des statistiques.

    Cette fonction traite une liste de ventes et calcule diverses
    m√©triques selon les param√®tres fournis.

    Args:
        ventes: Liste des ventes. Chaque vente est un dictionnaire
            contenant au minimum les cl√©s 'date', 'montant', et 'produit'.
        periode_debut: Date de d√©but pour filtrer les ventes.
            Si None, toutes les ventes depuis le d√©but sont incluses.
        periode_fin: Date de fin pour filtrer les ventes.
            Si None, toutes les ventes jusqu'√† maintenant sont incluses.
        grouper_par: M√©thode de regroupement des donn√©es.
            Valeurs possibles: "jour", "semaine", "mois", "annee".

    Returns:
        Dictionnaire contenant les m√©triques calcul√©es:
        - 'total': Montant total des ventes
        - 'moyenne': Montant moyen par vente
        - 'nombre_ventes': Nombre total de ventes
        - 'meilleur_produit': Nom du produit le plus vendu

    Raises:
        ValueError: Si grouper_par n'est pas une valeur valide
        KeyError: Si les dictionnaires de ventes n'ont pas les cl√©s requises
        TypeError: Si les types des param√®tres ne correspondent pas

    Example:
        >>> ventes = [
        ...     {'date': datetime(2023, 1, 15), 'montant': 100.0, 'produit': 'A'},
        ...     {'date': datetime(2023, 1, 20), 'montant': 150.0, 'produit': 'B'}
        ... ]
        >>> stats = analyser_ventes(ventes)
        >>> stats['total']
        250.0
        >>> stats['nombre_ventes']
        2
    """
    # Validation des param√®tres
    if grouper_par not in ["jour", "semaine", "mois", "annee"]:
        raise ValueError(f"grouper_par doit √™tre 'jour', 'semaine', 'mois' ou 'annee', re√ßu: {grouper_par}")

    # Validation de la structure des ventes
    if not all(isinstance(vente, dict) for vente in ventes):
        raise TypeError("Toutes les ventes doivent √™tre des dictionnaires")

    required_keys = {'date', 'montant', 'produit'}
    for i, vente in enumerate(ventes):
        if not required_keys.issubset(vente.keys()):
            missing = required_keys - vente.keys()
            raise KeyError(f"Vente {i} manque les cl√©s: {missing}")

    # Filtrage par p√©riode
    ventes_filtrees = ventes
    if periode_debut:
        ventes_filtrees = [v for v in ventes_filtrees if v['date'] >= periode_debut]
    if periode_fin:
        ventes_filtrees = [v for v in ventes_filtrees if v['date'] <= periode_fin]

    if not ventes_filtrees:
        return {
            'total': 0.0,
            'moyenne': 0.0,
            'nombre_ventes': 0,
            'meilleur_produit': None
        }

    # Calculs
    total = sum(vente['montant'] for vente in ventes_filtrees)
    nombre_ventes = len(ventes_filtrees)
    moyenne = total / nombre_ventes

    # Produit le plus vendu
    compteur_produits = {}
    for vente in ventes_filtrees:
        produit = vente['produit']
        compteur_produits[produit] = compteur_produits.get(produit, 0) + 1

    meilleur_produit = max(compteur_produits.items(), key=lambda x: x[1])[0]

    return {
        'total': total,
        'moyenne': moyenne,
        'nombre_ventes': nombre_ventes,
        'meilleur_produit': meilleur_produit
    }
```

## Bonnes pratiques pour les docstrings

### 1. Soyez pr√©cis et utiles

```python
# ‚ùå Docstring inutile
def get_user(id):
    """Gets a user by id"""
    return database.find_user(id)

# ‚úÖ Docstring utile
def obtenir_utilisateur(user_id):
    """
    R√©cup√®re un utilisateur par son identifiant unique.

    Args:
        user_id (int): Identifiant unique de l'utilisateur

    Returns:
        dict or None: Dictionnaire contenant les informations utilisateur
            (nom, email, date_creation) ou None si non trouv√©

    Raises:
        DatabaseError: Si la connexion √† la base √©choue
        ValueError: Si user_id n'est pas un entier positif
    """
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("user_id doit √™tre un entier positif")

    try:
        return database.find_user(user_id)
    except DatabaseError:
        raise DatabaseError("Impossible de se connecter √† la base de donn√©es")
```

### 2. Expliquez le "pourquoi", pas seulement le "quoi"

```python
# ‚ùå Explique seulement ce que fait le code
def normaliser_texte(texte):
    """Convertit le texte en minuscules et supprime les espaces"""
    return texte.lower().strip()

# ‚úÖ Explique pourquoi c'est important
def normaliser_texte(texte):
    """
    Normalise un texte pour faciliter les comparaisons et recherches.

    Cette fonction standardise le texte en √©liminant les variations
    de casse et d'espacement qui pourraient emp√™cher de reconna√Ætre
    des entr√©es identiques (ex: "Alice" vs " alice ").

    Args:
        texte (str): Texte √† normaliser

    Returns:
        str: Texte normalis√© (minuscules, sans espaces en d√©but/fin)

    Example:
        >>> normaliser_texte("  Alice DUPONT  ")
        'alice dupont'

        # Utile pour les comparaisons
        >>> normaliser_texte("Alice") == normaliser_texte(" ALICE ")
        True
    """
    return texte.lower().strip()
```

### 3. Documentez les cas particuliers et limitations

```python
def calculer_age(date_naissance):
    """
    Calcule l'√¢ge en ann√©es √† partir de la date de naissance.

    Args:
        date_naissance (datetime.date): Date de naissance

    Returns:
        int: √Çge en ann√©es r√©volues

    Note:
        L'√¢ge est calcul√© par rapport √† la date actuelle.
        Pour une personne n√©e le 29 f√©vrier, l'anniversaire
        est consid√©r√© le 28 f√©vrier les ann√©es non bissextiles.

    Warning:
        Cette fonction ne g√®re pas les fuseaux horaires.
        Pour des calculs pr√©cis internationaux, utilisez
        des biblioth√®ques sp√©cialis√©es comme pytz.

    Example:
        >>> from datetime import date
        >>> naissance = date(1990, 5, 15)
        >>> age = calculer_age(naissance)
        >>> isinstance(age, int)
        True
        >>> age >= 0
        True
    """
    from datetime import date

    aujourd_hui = date.today()
    age = aujourd_hui.year - date_naissance.year

    # Ajustement si l'anniversaire n'est pas encore pass√© cette ann√©e
    if (aujourd_hui.month, aujourd_hui.day) < (date_naissance.month, date_naissance.day):
        age -= 1

    return age
```

### 4. Utilisez des exemples concrets

```python
def calculer_remise(prix_initial, pourcentage_remise, remise_max=None):
    """
    Calcule le prix final apr√®s application d'une remise.

    Args:
        prix_initial (float): Prix de d√©part en euros
        pourcentage_remise (float): Pourcentage de remise (0.0 √† 1.0)
        remise_max (float, optional): Montant maximum de la remise en euros.
            Si None, aucune limite.

    Returns:
        float: Prix final apr√®s remise, arrondi √† 2 d√©cimales

    Example:
        Remise simple de 20% :
        >>> calculer_remise(100.0, 0.20)
        80.0

        Remise avec plafond :
        >>> calculer_remise(1000.0, 0.50, remise_max=300.0)
        700.0

        # Sans plafond, la remise aurait √©t√© de 500‚Ç¨
        # Avec plafond de 300‚Ç¨, remise limit√©e √† 300‚Ç¨

        Cas particuliers :
        >>> calculer_remise(50.0, 0.0)  # Pas de remise
        50.0
        >>> calculer_remise(0.0, 0.50)  # Prix nul
        0.0
    """
    if pourcentage_remise < 0 or pourcentage_remise > 1:
        raise ValueError("Le pourcentage de remise doit √™tre entre 0 et 1")

    montant_remise = prix_initial * pourcentage_remise

    if remise_max is not None and montant_remise > remise_max:
        montant_remise = remise_max

    prix_final = prix_initial - montant_remise
    return round(prix_final, 2)
```

### 5. Organisez vos sections logiquement

```python
def traiter_commande(commande_id, options=None):
    """
    Traite une commande client avec validation et notifications.

    Cette fonction constitue le point d'entr√©e principal pour le
    traitement des commandes. Elle orchestre la validation, le calcul
    des prix, la mise √† jour des stocks et l'envoi des notifications.

    Args:
        commande_id (str): Identifiant unique de la commande (format: CMD-XXXX)
        options (dict, optional): Options de traitement personnalis√©es.
            Cl√©s support√©es:
            - 'skip_validation' (bool): Ignore la validation (d√©faut: False)
            - 'force_stock' (bool): Force le traitement m√™me si stock insuffisant
            - 'notification_email' (str): Email alternatif pour notifications

    Returns:
        dict: R√©sultat du traitement avec les cl√©s:
            - 'success' (bool): True si traitement r√©ussi
            - 'order_number' (str): Num√©ro de commande g√©n√©r√©
            - 'total_amount' (float): Montant total factur√©
            - 'estimated_delivery' (datetime): Date de livraison estim√©e
            - 'tracking_code' (str): Code de suivi si exp√©dition

    Raises:
        ValueError: Si commande_id est invalide ou commande inexistante
        StockError: Si stock insuffisant et force_stock=False
        PaymentError: Si le paiement √©choue
        ValidationError: Si la validation des donn√©es √©choue

    Example:
        Traitement standard :
        >>> result = traiter_commande("CMD-1234")
        >>> result['success']
        True
        >>> 'order_number' in result
        True

        Avec options personnalis√©es :
        >>> options = {
        ...     'skip_validation': True,
        ...     'notification_email': 'admin@example.com'
        ... }
        >>> result = traiter_commande("CMD-5678", options)

    Note:
        - Le traitement peut prendre plusieurs secondes pour les grosses commandes
        - Les notifications sont envoy√©es de mani√®re asynchrone
        - Les logs d√©taill√©s sont enregistr√©s dans le fichier system.log

    See Also:
        valider_commande(): Pour validation manuelle
        calculer_frais_livraison(): Pour calcul des frais de port
        annuler_commande(): Pour annulation d'une commande
    """
    # Impl√©mentation...
    pass
```

## Documentation pour diff√©rents types de code

### API et services web

```python
from typing import Dict, List, Optional
from datetime import datetime

class APIManager:
    """
    Gestionnaire d'API pour les services web de l'application.

    Cette classe fournit une interface unifi√©e pour interagir avec
    les diff√©rents services web utilis√©s par l'application. Elle g√®re
    l'authentification, les retry automatiques et la limitation de d√©bit.

    Attributes:
        base_url (str): URL de base de l'API
        timeout (int): D√©lai d'attente par d√©faut en secondes
        max_retries (int): Nombre maximum de tentatives en cas d'√©chec
        rate_limit (int): Limite de requ√™tes par minute

    Example:
        >>> api = APIManager("https://api.example.com", timeout=30)
        >>> api.authenticate("token_123")
        >>> users = api.get_users(active=True)
        >>> len(users) > 0
        True
    """

    def __init__(self, base_url: str, timeout: int = 10, max_retries: int = 3):
        """
        Initialise le gestionnaire d'API.

        Args:
            base_url: URL de base de l'API (doit inclure le protocole)
            timeout: D√©lai d'attente pour les requ√™tes en secondes
            max_retries: Nombre de tentatives en cas d'√©chec

        Raises:
            ValueError: Si base_url ne commence pas par http:// ou https://
        """
        if not base_url.startswith(('http://', 'https://')):
            raise ValueError("base_url doit commencer par http:// ou https://")

        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.max_retries = max_retries
        self._session = None
        self._token = None

    def authenticate(self, token: str) -> bool:
        """
        Authentifie le client avec un token d'acc√®s.

        Args:
            token: Token d'authentification obtenu s√©par√©ment

        Returns:
            True si l'authentification r√©ussit, False sinon

        Example:
            >>> api = APIManager("https://api.example.com")
            >>> success = api.authenticate("valid_token_123")
            >>> success
            True

        Note:
            Le token est stock√© en m√©moire et utilis√© pour toutes
            les requ√™tes suivantes. Il n'est pas persist√©.
        """
        # Test du token avec une requ√™te de validation
        headers = {'Authorization': f'Bearer {token}'}
        try:
            response = self._make_request('GET', '/auth/validate', headers=headers)
            if response.status_code == 200:
                self._token = token
                return True
        except Exception:
            pass

        return False

    def get_users(self,
                  active: Optional[bool] = None,
                  limit: int = 100,
                  offset: int = 0) -> List[Dict]:
        """
        R√©cup√®re la liste des utilisateurs avec filtres optionnels.

        Args:
            active: Si sp√©cifi√©, filtre par statut actif/inactif
            limit: Nombre maximum d'utilisateurs √† retourner (1-1000)
            offset: D√©calage pour la pagination (commence √† 0)

        Returns:
            Liste de dictionnaires repr√©sentant les utilisateurs.
            Chaque utilisateur contient au minimum:
            - id (int): Identifiant unique
            - name (str): Nom complet
            - email (str): Adresse email
            - active (bool): Statut actif
            - created_at (str): Date de cr√©ation (ISO format)

        Raises:
            AuthenticationError: Si pas authentifi√© ou token expir√©
            ValueError: Si limit n'est pas dans la plage 1-1000
            APIError: Si erreur c√¥t√© serveur (5xx) ou requ√™te invalide (4xx)

        Example:
            R√©cup√©ration basique :
            >>> api = APIManager("https://api.example.com")
            >>> api.authenticate("token")
            True
            >>> users = api.get_users()
            >>> len(users) <= 100
            True

            Avec filtres :
            >>> active_users = api.get_users(active=True, limit=50)
            >>> all(user['active'] for user in active_users)
            True

            Pagination :
            >>> page1 = api.get_users(limit=10, offset=0)
            >>> page2 = api.get_users(limit=10, offset=10)
            >>> len(page1) <= 10 and len(page2) <= 10
            True

        Note:
            - La pagination est bas√©e sur offset/limit
            - Les r√©sultats sont tri√©s par date de cr√©ation (plus r√©cent en premier)
            - Le cache c√¥t√© serveur peut causer un d√©lai de 5 minutes pour les nouveaux utilisateurs
        """
        if not self._token:
            raise AuthenticationError("Non authentifi√© - appelez authenticate() d'abord")

        if not 1 <= limit <= 1000:
            raise ValueError("limit doit √™tre entre 1 et 1000")

        params = {'limit': limit, 'offset': offset}
        if active is not None:
            params['active'] = active

        response = self._make_request('GET', '/users', params=params)
        return response.json()['users']
```

### Algorithmes et traitement de donn√©es

```python
def trier_fusion(liste):
    """
    Trie une liste en utilisant l'algorithme de tri fusion (merge sort).

    Le tri fusion est un algorithme de tri stable avec une complexit√©
    temporelle garantie de O(n log n) dans tous les cas. Il utilise
    la strat√©gie "diviser pour r√©gner".

    Args:
        liste (list): Liste d'√©l√©ments comparables √† trier

    Returns:
        list: Nouvelle liste tri√©e par ordre croissant

    Time Complexity:
        - Meilleur cas: O(n log n)
        - Cas moyen: O(n log n)
        - Pire cas: O(n log n)

    Space Complexity:
        O(n) - N√©cessite un espace suppl√©mentaire pour la fusion

    Example:
        >>> trier_fusion([64, 34, 25, 12, 22, 11, 90])
        [11, 12, 22, 25, 34, 64, 90]

        >>> trier_fusion([5, 2, 8, 1, 9])
        [1, 2, 5, 8, 9]

        >>> trier_fusion([])  # Liste vide
        []

        >>> trier_fusion([42])  # Un seul √©l√©ment
        [42]

        Fonctionne avec diff√©rents types :
        >>> trier_fusion(['z', 'a', 'm', 'b'])
        ['a', 'b', 'm', 'z']

    Note:
        - L'algorithme est stable : l'ordre relatif des √©l√©ments √©gaux est pr√©serv√©
        - Fonctionne avec tout type d'√©l√©ments comparables (int, float, str, etc.)
        - Pour de petites listes (< 50 √©l√©ments), l'insertion sort peut √™tre plus rapide
        - La liste originale n'est pas modifi√©e

    See Also:
        trier_rapide(): Alternative avec complexit√© O(n log n) en moyenne
        sorted(): Fonction built-in Python (utilise Timsort)
    """
    # Cas de base : liste de 0 ou 1 √©l√©ment
    if len(liste) <= 1:
        return liste.copy()

    # Diviser la liste en deux moiti√©s
    milieu = len(liste) // 2
    gauche = liste[:milieu]
    droite = liste[milieu:]

    # R√©cursivement trier les deux moiti√©s
    gauche_triee = trier_fusion(gauche)
    droite_triee = trier_fusion(droite)

    # Fusionner les deux moiti√©s tri√©es
    return _fusionner(gauche_triee, droite_triee)

def _fusionner(gauche, droite):
    """
    Fusionne deux listes tri√©es en une seule liste tri√©e.

    Args:
        gauche (list): Premi√®re liste tri√©e
        droite (list): Deuxi√®me liste tri√©e

    Returns:
        list: Liste fusionn√©e et tri√©e

    Note:
        Fonction auxiliaire pour trier_fusion().
        Ne devrait pas √™tre appel√©e directement.
    """
    resultat = []
    i = j = 0

    # Comparer et fusionner √©l√©ment par √©l√©ment
    while i < len(gauche) and j < len(droite):
        if gauche[i] <= droite[j]:
            resultat.append(gauche[i])
            i += 1
        else:
            resultat.append(droite[j])
            j += 1

    # Ajouter les √©l√©ments restants
    resultat.extend(gauche[i:])
    resultat.extend(droite[j:])

    return resultat
```

### Code de configuration et utilitaires

```python
import os
import json
from pathlib import Path
from typing import Any, Dict, Optional

class ConfigManager:
    """
    Gestionnaire de configuration centralis√© pour l'application.

    Cette classe g√®re le chargement, la validation et l'acc√®s aux
    param√®tres de configuration depuis plusieurs sources :
    fichiers JSON, variables d'environnement, et valeurs par d√©faut.

    La priorit√© des sources (de la plus haute √† la plus basse) :
    1. Variables d'environnement
    2. Fichier de configuration local
    3. Fichier de configuration par d√©faut
    4. Valeurs par d√©faut du code

    Example:
        Configuration basique :
        >>> config = ConfigManager()
        >>> database_url = config.get('database.url')
        >>> api_timeout = config.get('api.timeout', 30)

        Avec fichier personnalis√© :
        >>> config = ConfigManager('my_config.json')
        >>> config.get('app.debug', False)
        False
    """

    def __init__(self, config_file: Optional[str] = None):
        """
        Initialise le gestionnaire de configuration.

        Args:
            config_file: Chemin vers le fichier de configuration principal.
                Si None, utilise 'config.json' dans le r√©pertoire courant.

        Example:
            >>> config = ConfigManager()  # Utilise config.json
            >>> config = ConfigManager('/etc/myapp/config.json')  # Fichier sp√©cifique
        """
        self.config_file = config_file or 'config.json'
        self._config = {}
        self._load_config()

    def get(self, key: str, default: Any = None) -> Any:
        """
        R√©cup√®re une valeur de configuration par sa cl√©.

        La cl√© peut utiliser la notation point√©e pour acc√©der aux
        valeurs imbriqu√©es (ex: 'database.connection.timeout').

        Args:
            key: Cl√© de configuration (notation point√©e support√©e)
            default: Valeur par d√©faut si la cl√© n'existe pas

        Returns:
            Valeur de configuration ou valeur par d√©faut

        Example:
            Configuration simple :
            >>> config.get('debug')
            True

            Configuration imbriqu√©e :
            >>> config.get('database.host')
            'localhost'
            >>> config.get('database.port', 5432)
            5432

            Avec valeur par d√©faut :
            >>> config.get('inexistant.parametre', 'defaut')
            'defaut'
        """
        # V√©rifier d'abord les variables d'environnement
        env_key = key.upper().replace('.', '_')
        env_value = os.getenv(env_key)
        if env_value is not None:
            return self._parse_env_value(env_value)

        # Puis chercher dans la configuration charg√©e
        return self._get_nested_value(self._config, key, default)

    def set(self, key: str, value: Any) -> None:
        """
        D√©finit une valeur de configuration.

        Args:
            key: Cl√© de configuration (notation point√©e support√©e)
            value: Valeur √† d√©finir

        Example:
            >>> config.set('database.timeout', 60)
            >>> config.get('database.timeout')
            60

            >>> config.set('new.nested.value', 'test')
            >>> config.get('new.nested.value')
            'test'

        Note:
            Cette modification n'est que temporaire (en m√©moire).
            Utilisez save() pour persister les changements.
        """
        self._set_nested_value(self._config, key, value)

    def save(self, file_path: Optional[str] = None) -> None:
        """
        Sauvegarde la configuration actuelle dans un fichier JSON.

        Args:
            file_path: Chemin de sauvegarde. Si None, utilise le fichier
                de configuration original.

        Raises:
            PermissionError: Si pas de permission d'√©criture
            OSError: Si erreur d'√©criture du fichier

        Example:
            >>> config.set('app.version', '2.0.0')
            >>> config.save()  # Sauvegarde dans le fichier original
            >>> config.save('/backup/config.json')  # Sauvegarde ailleurs
        """
        target_file = file_path or self.config_file

        try:
            with open(target_file, 'w', encoding='utf-8') as f:
                json.dump(self._config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            raise OSError(f"Impossible de sauvegarder la configuration : {e}")

    def _load_config(self) -> None:
        """
        Charge la configuration depuis le fichier JSON.

        Charge d'abord les valeurs par d√©faut, puis les √©crase
        avec les valeurs du fichier de configuration s'il existe.
        """
        # Valeurs par d√©faut
        self._config = {
            'app': {
                'name': 'MyApp',
                'version': '1.0.0',
                'debug': False
            },
            'database': {
                'host': 'localhost',
                'port': 5432,
                'timeout': 30
            },
            'api': {
                'timeout': 10,
                'max_retries': 3
            }
        }

        # Charger depuis le fichier si il existe
        if Path(self.config_file).exists():
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    file_config = json.load(f)
                    self._merge_config(self._config, file_config)
            except (json.JSONDecodeError, OSError) as e:
                print(f"Attention : Impossible de charger {self.config_file}: {e}")
                print("Utilisation des valeurs par d√©faut uniquement.")

    def _get_nested_value(self, config_dict: Dict, key: str, default: Any) -> Any:
        """
        R√©cup√®re une valeur imbriqu√©e en utilisant la notation point√©e.

        Args:
            config_dict: Dictionnaire de configuration
            key: Cl√© avec notation point√©e (ex: 'a.b.c')
            default: Valeur par d√©faut

        Returns:
            Valeur trouv√©e ou valeur par d√©faut
        """
        keys = key.split('.')
        current = config_dict

        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default

        return current

    def _set_nested_value(self, config_dict: Dict, key: str, value: Any) -> None:
        """
        D√©finit une valeur imbriqu√©e en utilisant la notation point√©e.
        """
        keys = key.split('.')
        current = config_dict

        # Naviguer jusqu'au dernier niveau
        for k in keys[:-1]:
            if k not in current:
                current[k] = {}
            current = current[k]

        # D√©finir la valeur finale
        current[keys[-1]] = value

    def _merge_config(self, base: Dict, override: Dict) -> None:
        """
        Fusionne r√©cursivement deux dictionnaires de configuration.
        """
        for key, value in override.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                self._merge_config(base[key], value)
            else:
                base[key] = value

    def _parse_env_value(self, value: str) -> Any:
        """
        Parse une valeur de variable d'environnement en type Python appropri√©.

        Conversions support√©es :
        - 'true'/'false' -> bool
        - Nombres -> int ou float
        - JSON valide -> dict/list
        - Autres -> str
        """
        # Bool√©ens
        if value.lower() in ('true', '1', 'yes', 'on'):
            return True
        if value.lower() in ('false', '0', 'no', 'off'):
            return False

        # Nombres
        try:
            if '.' in value:
                return float(value)
            else:
                return int(value)
        except ValueError:
            pass

        # JSON
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            pass

        # Cha√Æne par d√©faut
        return value
```

## Outils pour maintenir la documentation

### Scripts de v√©rification

```python
#!/usr/bin/env python3
"""
Script de v√©rification de la qualit√© de la documentation.

Ce script analyse le code Python pour d√©tecter les fonctions
et classes sans docstrings ou avec des docstrings incompl√®tes.

Usage:
    python check_docs.py [r√©pertoire]

Example:
    python check_docs.py src/
    python check_docs.py .  # R√©pertoire courant
"""

import ast
import sys
from pathlib import Path
from typing import List, Tuple

class DocStringChecker:
    """
    V√©rificateur de qualit√© des docstrings.

    Analyse les fichiers Python pour d√©tecter :
    - Fonctions/classes sans docstring
    - Docstrings trop courtes
    - Docstrings sans sections Args/Returns
    """

    def __init__(self):
        self.issues = []

    def check_file(self, file_path: Path) -> List[Tuple[str, int, str]]:
        """
        V√©rifie un fichier Python.

        Args:
            file_path: Chemin vers le fichier Python

        Returns:
            Liste des probl√®mes trouv√©s (type, ligne, message)
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)
            checker = DocStringVisitor(str(file_path))
            checker.visit(tree)
            return checker.issues

        except Exception as e:
            return [('error', 0, f"Erreur lors de l'analyse : {e}")]

class DocStringVisitor(ast.NodeVisitor):
    """Visiteur AST pour analyser les docstrings."""

    def __init__(self, filename: str):
        self.filename = filename
        self.issues = []

    def visit_FunctionDef(self, node):
        """Visite une d√©finition de fonction."""
        self._check_docstring(node, 'function')
        self.generic_visit(node)

    def visit_ClassDef(self, node):
        """Visite une d√©finition de classe."""
        self._check_docstring(node, 'class')
        self.generic_visit(node)

    def _check_docstring(self, node, node_type):
        """V√©rifie la docstring d'un n≈ìud."""
        docstring = ast.get_docstring(node)

        # Ignorer les m√©thodes priv√©es et sp√©ciales pour les fonctions
        if node_type == 'function' and node.name.startswith('_'):
            return

        if not docstring:
            self.issues.append((
                'missing',
                node.lineno,
                f"{node_type.capitalize()} '{node.name}' sans docstring"
            ))
            return

        # V√©rifier la longueur
        if len(docstring.strip()) < 20:
            self.issues.append((
                'short',
                node.lineno,
                f"{node_type.capitalize()} '{node.name}' avec docstring trop courte"
            ))

        # V√©rifier la pr√©sence de sections pour les fonctions publiques
        if node_type == 'function' and not node.name.startswith('_'):
            if len(node.args.args) > 1:  # Plus que 'self'
                if 'Args:' not in docstring and 'Parameters:' not in docstring:
                    self.issues.append((
                        'no_args',
                        node.lineno,
                        f"Fonction '{node.name}' sans section Args/Parameters"
                    ))

            # V√©rifier Returns pour fonctions non-void
            has_return = any(isinstance(n, ast.Return) for n in ast.walk(node) if n != node)
            if has_return:
                if 'Returns:' not in docstring and 'Return:' not in docstring:
                    self.issues.append((
                        'no_returns',
                        node.lineno,
                        f"Fonction '{node.name}' sans section Returns"
                    ))

# 10.4 : Documentation avec docstrings (suite)

## Bonnes pratiques pour les docstrings

### 1. Soyez pr√©cis et utiles

```python
# ‚ùå Docstring inutile
def get_user(id):
    """Gets a user by id"""
    return database.find_user(id)

# ‚úÖ Docstring utile
def obtenir_utilisateur(user_id):
    """
    R√©cup√®re un utilisateur par son identifiant unique.

    Args:
        user_id (int): Identifiant unique de l'utilisateur

    Returns:
        dict or None: Dictionnaire contenant les informations utilisateur
            (nom, email, date_creation) ou None si non trouv√©

    Raises:
        DatabaseError: Si la connexion √† la base √©choue
        ValueError: Si user_id n'est pas un entier positif
    """
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("user_id doit √™tre un entier positif")

    try:
        return database.find_user(user_id)
    except DatabaseError:
        raise DatabaseError("Impossible de se connecter √† la base de donn√©es")
```

### 2. Expliquez le "pourquoi", pas seulement le "quoi"

```python
# ‚ùå Explique seulement ce que fait le code
def normaliser_texte(texte):
    """Convertit le texte en minuscules et supprime les espaces"""
    return texte.lower().strip()

# ‚úÖ Explique pourquoi c'est important
def normaliser_texte(texte):
    """
    Normalise un texte pour faciliter les comparaisons et recherches.

    Cette fonction standardise le texte en √©liminant les variations
    de casse et d'espacement qui pourraient emp√™cher de reconna√Ætre
    des entr√©es identiques (ex: "Alice" vs " alice ").

    Args:
        texte (str): Texte √† normaliser

    Returns:
        str: Texte normalis√© (minuscules, sans espaces en d√©but/fin)

    Example:
        >>> normaliser_texte("  Alice DUPONT  ")
        'alice dupont'

        # Utile pour les comparaisons
        >>> normaliser_texte("Alice") == normaliser_texte(" ALICE ")
        True
    """
    return texte.lower().strip()
```

### 3. Documentez les cas particuliers et limitations

```python
def calculer_age(date_naissance):
    """
    Calcule l'√¢ge en ann√©es √† partir de la date de naissance.

    Args:
        date_naissance (datetime.date): Date de naissance

    Returns:
        int: √Çge en ann√©es r√©volues

    Note:
        L'√¢ge est calcul√© par rapport √† la date actuelle.
        Pour une personne n√©e le 29 f√©vrier, l'anniversaire
        est consid√©r√© le 28 f√©vrier les ann√©es non bissextiles.

    Warning:
        Cette fonction ne g√®re pas les fuseaux horaires.
        Pour des calculs pr√©cis internationaux, utilisez
        des biblioth√®ques sp√©cialis√©es comme pytz.

    Example:
        >>> from datetime import date
        >>> naissance = date(1990, 5, 15)
        >>> age = calculer_age(naissance)
        >>> isinstance(age, int)
        True
        >>> age >= 0
        True
    """
    from datetime import date

    aujourd_hui = date.today()
    age = aujourd_hui.year - date_naissance.year

    # Ajustement si l'anniversaire n'est pas encore pass√© cette ann√©e
    if (aujourd_hui.month, aujourd_hui.day) < (date_naissance.month, date_naissance.day):
        age -= 1

    return age
```

### 4. Utilisez des exemples concrets

```python
def calculer_remise(prix_initial, pourcentage_remise, remise_max=None):
    """
    Calcule le prix final apr√®s application d'une remise.

    Args:
        prix_initial (float): Prix de d√©part en euros
        pourcentage_remise (float): Pourcentage de remise (0.0 √† 1.0)
        remise_max (float, optional): Montant maximum de la remise en euros.
            Si None, aucune limite.

    Returns:
        float: Prix final apr√®s remise, arrondi √† 2 d√©cimales

    Example:
        Remise simple de 20% :
        >>> calculer_remise(100.0, 0.20)
        80.0

        Remise avec plafond :
        >>> calculer_remise(1000.0, 0.50, remise_max=300.0)
        700.0

        # Sans plafond, la remise aurait √©t√© de 500‚Ç¨
        # Avec plafond de 300‚Ç¨, remise limit√©e √† 300‚Ç¨

        Cas particuliers :
        >>> calculer_remise(50.0, 0.0)  # Pas de remise
        50.0
        >>> calculer_remise(0.0, 0.50)  # Prix nul
        0.0
    """
    if pourcentage_remise < 0 or pourcentage_remise > 1:
        raise ValueError("Le pourcentage de remise doit √™tre entre 0 et 1")

    montant_remise = prix_initial * pourcentage_remise

    if remise_max is not None and montant_remise > remise_max:
        montant_remise = remise_max

    prix_final = prix_initial - montant_remise
    return round(prix_final, 2)
```

### 5. Organisez vos sections logiquement

```python
def traiter_commande(commande_id, options=None):
    """
    Traite une commande client avec validation et notifications.

    Cette fonction constitue le point d'entr√©e principal pour le
    traitement des commandes. Elle orchestre la validation, le calcul
    des prix, la mise √† jour des stocks et l'envoi des notifications.

    Args:
        commande_id (str): Identifiant unique de la commande (format: CMD-XXXX)
        options (dict, optional): Options de traitement personnalis√©es.
            Cl√©s support√©es:
            - 'skip_validation' (bool): Ignore la validation (d√©faut: False)
            - 'force_stock' (bool): Force le traitement m√™me si stock insuffisant
            - 'notification_email' (str): Email alternatif pour notifications

    Returns:
        dict: R√©sultat du traitement avec les cl√©s:
            - 'success' (bool): True si traitement r√©ussi
            - 'order_number' (str): Num√©ro de commande g√©n√©r√©
            - 'total_amount' (float): Montant total factur√©
            - 'estimated_delivery' (datetime): Date de livraison estim√©e
            - 'tracking_code' (str): Code de suivi si exp√©dition

    Raises:
        ValueError: Si commande_id est invalide ou commande inexistante
        StockError: Si stock insuffisant et force_stock=False
        PaymentError: Si le paiement √©choue
        ValidationError: Si la validation des donn√©es √©choue

    Example:
        Traitement standard :
        >>> result = traiter_commande("CMD-1234")
        >>> result['success']
        True
        >>> 'order_number' in result
        True

        Avec options personnalis√©es :
        >>> options = {
        ...     'skip_validation': True,
        ...     'notification_email': 'admin@example.com'
        ... }
        >>> result = traiter_commande("CMD-5678", options)

    Note:
        - Le traitement peut prendre plusieurs secondes pour les grosses commandes
        - Les notifications sont envoy√©es de mani√®re asynchrone
        - Les logs d√©taill√©s sont enregistr√©s dans le fichier system.log

    See Also:
        valider_commande(): Pour validation manuelle
        calculer_frais_livraison(): Pour calcul des frais de port
        annuler_commande(): Pour annulation d'une commande
    """
    # Impl√©mentation...
    pass
```

## Documentation pour diff√©rents types de code

### API et services web

```python
from typing import Dict, List, Optional
from datetime import datetime

class APIManager:
    """
    Gestionnaire d'API pour les services web de l'application.

    Cette classe fournit une interface unifi√©e pour interagir avec
    les diff√©rents services web utilis√©s par l'application. Elle g√®re
    l'authentification, les retry automatiques et la limitation de d√©bit.

    Attributes:
        base_url (str): URL de base de l'API
        timeout (int): D√©lai d'attente par d√©faut en secondes
        max_retries (int): Nombre maximum de tentatives en cas d'√©chec
        rate_limit (int): Limite de requ√™tes par minute

    Example:
        >>> api = APIManager("https://api.example.com", timeout=30)
        >>> api.authenticate("token_123")
        >>> users = api.get_users(active=True)
        >>> len(users) > 0
        True
    """

    def __init__(self, base_url: str, timeout: int = 10, max_retries: int = 3):
        """
        Initialise le gestionnaire d'API.

        Args:
            base_url: URL de base de l'API (doit inclure le protocole)
            timeout: D√©lai d'attente pour les requ√™tes en secondes
            max_retries: Nombre de tentatives en cas d'√©chec

        Raises:
            ValueError: Si base_url ne commence pas par http:// ou https://
        """
        if not base_url.startswith(('http://', 'https://')):
            raise ValueError("base_url doit commencer par http:// ou https://")

        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.max_retries = max_retries
        self._session = None
        self._token = None

    def authenticate(self, token: str) -> bool:
        """
        Authentifie le client avec un token d'acc√®s.

        Args:
            token: Token d'authentification obtenu s√©par√©ment

        Returns:
            True si l'authentification r√©ussit, False sinon

        Example:
            >>> api = APIManager("https://api.example.com")
            >>> success = api.authenticate("valid_token_123")
            >>> success
            True

        Note:
            Le token est stock√© en m√©moire et utilis√© pour toutes
            les requ√™tes suivantes. Il n'est pas persist√©.
        """
        # Test du token avec une requ√™te de validation
        headers = {'Authorization': f'Bearer {token}'}
        try:
            response = self._make_request('GET', '/auth/validate', headers=headers)
            if response.status_code == 200:
                self._token = token
                return True
        except Exception:
            pass

        return False

    def get_users(self,
                  active: Optional[bool] = None,
                  limit: int = 100,
                  offset: int = 0) -> List[Dict]:
        """
        R√©cup√®re la liste des utilisateurs avec filtres optionnels.

        Args:
            active: Si sp√©cifi√©, filtre par statut actif/inactif
            limit: Nombre maximum d'utilisateurs √† retourner (1-1000)
            offset: D√©calage pour la pagination (commence √† 0)

        Returns:
            Liste de dictionnaires repr√©sentant les utilisateurs.
            Chaque utilisateur contient au minimum:
            - id (int): Identifiant unique
            - name (str): Nom complet
            - email (str): Adresse email
            - active (bool): Statut actif
            - created_at (str): Date de cr√©ation (ISO format)

        Raises:
            AuthenticationError: Si pas authentifi√© ou token expir√©
            ValueError: Si limit n'est pas dans la plage 1-1000
            APIError: Si erreur c√¥t√© serveur (5xx) ou requ√™te invalide (4xx)

        Example:
            R√©cup√©ration basique :
            >>> api = APIManager("https://api.example.com")
            >>> api.authenticate("token")
            True
            >>> users = api.get_users()
            >>> len(users) <= 100
            True

            Avec filtres :
            >>> active_users = api.get_users(active=True, limit=50)
            >>> all(user['active'] for user in active_users)
            True

            Pagination :
            >>> page1 = api.get_users(limit=10, offset=0)
            >>> page2 = api.get_users(limit=10, offset=10)
            >>> len(page1) <= 10 and len(page2) <= 10
            True

        Note:
            - La pagination est bas√©e sur offset/limit
            - Les r√©sultats sont tri√©s par date de cr√©ation (plus r√©cent en premier)
            - Le cache c√¥t√© serveur peut causer un d√©lai de 5 minutes pour les nouveaux utilisateurs
        """
        if not self._token:
            raise AuthenticationError("Non authentifi√© - appelez authenticate() d'abord")

        if not 1 <= limit <= 1000:
            raise ValueError("limit doit √™tre entre 1 et 1000")

        params = {'limit': limit, 'offset': offset}
        if active is not None:
            params['active'] = active

        response = self._make_request('GET', '/users', params=params)
        return response.json()['users']
```

### Algorithmes et traitement de donn√©es

```python
def trier_fusion(liste):
    """
    Trie une liste en utilisant l'algorithme de tri fusion (merge sort).

    Le tri fusion est un algorithme de tri stable avec une complexit√©
    temporelle garantie de O(n log n) dans tous les cas. Il utilise
    la strat√©gie "diviser pour r√©gner".

    Args:
        liste (list): Liste d'√©l√©ments comparables √† trier

    Returns:
        list: Nouvelle liste tri√©e par ordre croissant

    Time Complexity:
        - Meilleur cas: O(n log n)
        - Cas moyen: O(n log n)
        - Pire cas: O(n log n)

    Space Complexity:
        O(n) - N√©cessite un espace suppl√©mentaire pour la fusion

    Example:
        >>> trier_fusion([64, 34, 25, 12, 22, 11, 90])
        [11, 12, 22, 25, 34, 64, 90]

        >>> trier_fusion([5, 2, 8, 1, 9])
        [1, 2, 5, 8, 9]

        >>> trier_fusion([])  # Liste vide
        []

        >>> trier_fusion([42])  # Un seul √©l√©ment
        [42]

        Fonctionne avec diff√©rents types :
        >>> trier_fusion(['z', 'a', 'm', 'b'])
        ['a', 'b', 'm', 'z']

    Note:
        - L'algorithme est stable : l'ordre relatif des √©l√©ments √©gaux est pr√©serv√©
        - Fonctionne avec tout type d'√©l√©ments comparables (int, float, str, etc.)
        - Pour de petites listes (< 50 √©l√©ments), l'insertion sort peut √™tre plus rapide
        - La liste originale n'est pas modifi√©e

    See Also:
        trier_rapide(): Alternative avec complexit√© O(n log n) en moyenne
        sorted(): Fonction built-in Python (utilise Timsort)
    """
    # Cas de base : liste de 0 ou 1 √©l√©ment
    if len(liste) <= 1:
        return liste.copy()

    # Diviser la liste en deux moiti√©s
    milieu = len(liste) // 2
    gauche = liste[:milieu]
    droite = liste[milieu:]

    # R√©cursivement trier les deux moiti√©s
    gauche_triee = trier_fusion(gauche)
    droite_triee = trier_fusion(droite)

    # Fusionner les deux moiti√©s tri√©es
    return _fusionner(gauche_triee, droite_triee)

def _fusionner(gauche, droite):
    """
    Fusionne deux listes tri√©es en une seule liste tri√©e.

    Args:
        gauche (list): Premi√®re liste tri√©e
        droite (list): Deuxi√®me liste tri√©e

    Returns:
        list: Liste fusionn√©e et tri√©e

    Note:
        Fonction auxiliaire pour trier_fusion().
        Ne devrait pas √™tre appel√©e directement.
    """
    resultat = []
    i = j = 0

    # Comparer et fusionner √©l√©ment par √©l√©ment
    while i < len(gauche) and j < len(droite):
        if gauche[i] <= droite[j]:
            resultat.append(gauche[i])
            i += 1
        else:
            resultat.append(droite[j])
            j += 1

    # Ajouter les √©l√©ments restants
    resultat.extend(gauche[i:])
    resultat.extend(droite[j:])

    return resultat
```

### Code de configuration et utilitaires

```python
import os
import json
from pathlib import Path
from typing import Any, Dict, Optional

class ConfigManager:
    """
    Gestionnaire de configuration centralis√© pour l'application.

    Cette classe g√®re le chargement, la validation et l'acc√®s aux
    param√®tres de configuration depuis plusieurs sources :
    fichiers JSON, variables d'environnement, et valeurs par d√©faut.

    La priorit√© des sources (de la plus haute √† la plus basse) :
    1. Variables d'environnement
    2. Fichier de configuration local
    3. Fichier de configuration par d√©faut
    4. Valeurs par d√©faut du code

    Example:
        Configuration basique :
        >>> config = ConfigManager()
        >>> database_url = config.get('database.url')
        >>> api_timeout = config.get('api.timeout', 30)

        Avec fichier personnalis√© :
        >>> config = ConfigManager('my_config.json')
        >>> config.get('app.debug', False)
        False
    """

    def __init__(self, config_file: Optional[str] = None):
        """
        Initialise le gestionnaire de configuration.

        Args:
            config_file: Chemin vers le fichier de configuration principal.
                Si None, utilise 'config.json' dans le r√©pertoire courant.

        Example:
            >>> config = ConfigManager()  # Utilise config.json
            >>> config = ConfigManager('/etc/myapp/config.json')  # Fichier sp√©cifique
        """
        self.config_file = config_file or 'config.json'
        self._config = {}
        self._load_config()

    def get(self, key: str, default: Any = None) -> Any:
        """
        R√©cup√®re une valeur de configuration par sa cl√©.

        La cl√© peut utiliser la notation point√©e pour acc√©der aux
        valeurs imbriqu√©es (ex: 'database.connection.timeout').

        Args:
            key: Cl√© de configuration (notation point√©e support√©e)
            default: Valeur par d√©faut si la cl√© n'existe pas

        Returns:
            Valeur de configuration ou valeur par d√©faut

        Example:
            Configuration simple :
            >>> config.get('debug')
            True

            Configuration imbriqu√©e :
            >>> config.get('database.host')
            'localhost'
            >>> config.get('database.port', 5432)
            5432

            Avec valeur par d√©faut :
            >>> config.get('inexistant.parametre', 'defaut')
            'defaut'
        """
        # V√©rifier d'abord les variables d'environnement
        env_key = key.upper().replace('.', '_')
        env_value = os.getenv(env_key)
        if env_value is not None:
            return self._parse_env_value(env_value)

        # Puis chercher dans la configuration charg√©e
        return self._get_nested_value(self._config, key, default)

    def set(self, key: str, value: Any) -> None:
        """
        D√©finit une valeur de configuration.

        Args:
            key: Cl√© de configuration (notation point√©e support√©e)
            value: Valeur √† d√©finir

        Example:
            >>> config.set('database.timeout', 60)
            >>> config.get('database.timeout')
            60

            >>> config.set('new.nested.value', 'test')
            >>> config.get('new.nested.value')
            'test'

        Note:
            Cette modification n'est que temporaire (en m√©moire).
            Utilisez save() pour persister les changements.
        """
        self._set_nested_value(self._config, key, value)

    def save(self, file_path: Optional[str] = None) -> None:
        """
        Sauvegarde la configuration actuelle dans un fichier JSON.

        Args:
            file_path: Chemin de sauvegarde. Si None, utilise le fichier
                de configuration original.

        Raises:
            PermissionError: Si pas de permission d'√©criture
            OSError: Si erreur d'√©criture du fichier

        Example:
            >>> config.set('app.version', '2.0.0')
            >>> config.save()  # Sauvegarde dans le fichier original
            >>> config.save('/backup/config.json')  # Sauvegarde ailleurs
        """
        target_file = file_path or self.config_file

        try:
            with open(target_file, 'w', encoding='utf-8') as f:
                json.dump(self._config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            raise OSError(f"Impossible de sauvegarder la configuration : {e}")

    def _load_config(self) -> None:
        """
        Charge la configuration depuis le fichier JSON.

        Charge d'abord les valeurs par d√©faut, puis les √©crase
        avec les valeurs du fichier de configuration s'il existe.
        """
        # Valeurs par d√©faut
        self._config = {
            'app': {
                'name': 'MyApp',
                'version': '1.0.0',
                'debug': False
            },
            'database': {
                'host': 'localhost',
                'port': 5432,
                'timeout': 30
            },
            'api': {
                'timeout': 10,
                'max_retries': 3
            }
        }

        # Charger depuis le fichier si il existe
        if Path(self.config_file).exists():
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    file_config = json.load(f)
                    self._merge_config(self._config, file_config)
            except (json.JSONDecodeError, OSError) as e:
                print(f"Attention : Impossible de charger {self.config_file}: {e}")
                print("Utilisation des valeurs par d√©faut uniquement.")

    def _get_nested_value(self, config_dict: Dict, key: str, default: Any) -> Any:
        """
        R√©cup√®re une valeur imbriqu√©e en utilisant la notation point√©e.

        Args:
            config_dict: Dictionnaire de configuration
            key: Cl√© avec notation point√©e (ex: 'a.b.c')
            default: Valeur par d√©faut

        Returns:
            Valeur trouv√©e ou valeur par d√©faut
        """
        keys = key.split('.')
        current = config_dict

        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default

        return current

    def _set_nested_value(self, config_dict: Dict, key: str, value: Any) -> None:
        """
        D√©finit une valeur imbriqu√©e en utilisant la notation point√©e.
        """
        keys = key.split('.')
        current = config_dict

        # Naviguer jusqu'au dernier niveau
        for k in keys[:-1]:
            if k not in current:
                current[k] = {}
            current = current[k]

        # D√©finir la valeur finale
        current[keys[-1]] = value

    def _merge_config(self, base: Dict, override: Dict) -> None:
        """
        Fusionne r√©cursivement deux dictionnaires de configuration.
        """
        for key, value in override.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                self._merge_config(base[key], value)
            else:
                base[key] = value

    def _parse_env_value(self, value: str) -> Any:
        """
        Parse une valeur de variable d'environnement en type Python appropri√©.

        Conversions support√©es :
        - 'true'/'false' -> bool
        - Nombres -> int ou float
        - JSON valide -> dict/list
        - Autres -> str
        """
        # Bool√©ens
        if value.lower() in ('true', '1', 'yes', 'on'):
            return True
        if value.lower() in ('false', '0', 'no', 'off'):
            return False

        # Nombres
        try:
            if '.' in value:
                return float(value)
            else:
                return int(value)
        except ValueError:
            pass

        # JSON
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            pass

        # Cha√Æne par d√©faut
        return value
```

## Outils pour maintenir la documentation

### Scripts de v√©rification

```python
#!/usr/bin/env python3
"""
Script de v√©rification de la qualit√© de la documentation.

Ce script analyse le code Python pour d√©tecter les fonctions
et classes sans docstrings ou avec des docstrings incompl√®tes.

Usage:
    python check_docs.py [r√©pertoire]

Example:
    python check_docs.py src/
    python check_docs.py .  # R√©pertoire courant
"""

import ast
import sys
from pathlib import Path
from typing import List, Tuple

class DocStringChecker:
    """
    V√©rificateur de qualit√© des docstrings.

    Analyse les fichiers Python pour d√©tecter :
    - Fonctions/classes sans docstring
    - Docstrings trop courtes
    - Docstrings sans sections Args/Returns
    """

    def __init__(self):
        self.issues = []

    def check_file(self, file_path: Path) -> List[Tuple[str, int, str]]:
        """
        V√©rifie un fichier Python.

        Args:
            file_path: Chemin vers le fichier Python

        Returns:
            Liste des probl√®mes trouv√©s (type, ligne, message)
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)
            checker = DocStringVisitor(str(file_path))
            checker.visit(tree)
            return checker.issues

        except Exception as e:
            return [('error', 0, f"Erreur lors de l'analyse : {e}")]

class DocStringVisitor(ast.NodeVisitor):
    """Visiteur AST pour analyser les docstrings."""

    def __init__(self, filename: str):
        self.filename = filename
        self.issues = []

    def visit_FunctionDef(self, node):
        """Visite une d√©finition de fonction."""
        self._check_docstring(node, 'function')
        self.generic_visit(node)

    def visit_ClassDef(self, node):
        """Visite une d√©finition de classe."""
        self._check_docstring(node, 'class')
        self.generic_visit(node)

    def _check_docstring(self, node, node_type):
        """V√©rifie la docstring d'un n≈ìud."""
        docstring = ast.get_docstring(node)

        # Ignorer les m√©thodes priv√©es et sp√©ciales pour les fonctions
        if node_type == 'function' and node.name.startswith('_'):
            return

        if not docstring:
            self.issues.append((
                'missing',
                node.lineno,
                f"{node_type.capitalize()} '{node.name}' sans docstring"
            ))
            return

        # V√©rifier la longueur
        if len(docstring.strip()) < 20:
            self.issues.append((
                'short',
                node.lineno,
                f"{node_type.capitalize()} '{node.name}' avec docstring trop courte"
            ))

        # V√©rifier la pr√©sence de sections pour les fonctions publiques
        if node_type == 'function' and not node.name.startswith('_'):
            if len(node.args.args) > 1:  # Plus que 'self'
                if 'Args:' not in docstring and 'Parameters:' not in docstring:
                    self.issues.append((
                        'no_args',
                        node.lineno,
                        f"Fonction '{node.name}' sans section Args/Parameters"
                    ))

            # V√©rifier Returns pour fonctions non-void
            has_return = any(isinstance(n, ast.Return) for n in ast.walk(node) if n != node)
            if has_return:
                if 'Returns:' not in docstring and 'Return:' not in docstring:
                    self.issues.append((
                        'no_returns',
                        node.lineno,
                        f"Fonction '{node.name}' sans section Returns"
                    ))

def main():
    """Point d'entr√©e principal du script."""
    if len(sys.argv) > 1:
        target = Path(sys.argv[1])
    else:
        target = Path('.')

    if not target.exists():
        print(f"Erreur : {target} n'existe pas")
        sys.exit(1)

    checker = DocStringChecker()
    total_issues = 0

    # Trouver tous les fichiers Python
    python_files = []
    if target.is_file() and target.suffix == '.py':
        python_files = [target]
    else:
        python_files = list(target.rglob('*.py'))

    print(f"V√©rification de {len(python_files)} fichiers Python...")
    print("=" * 60)

    for file_path in python_files:
        issues = checker.check_file(file_path)
        if issues:
            print(f"\nüìÅ {file_path}")
            for issue_type, line_no, message in issues:
                emoji = {
                    'missing': '‚ùå',
                    'short': '‚ö†Ô∏è ',
                    'no_args': 'üìù',
                    'no_returns': '‚Ü©Ô∏è ',
                    'error': 'üí•'
                }.get(issue_type, '‚ö†Ô∏è')

                print(f"  {emoji} Ligne {line_no:3d}: {message}")
                total_issues += 1

    print("\n" + "=" * 60)
    if total_issues == 0:
        print("‚úÖ Aucun probl√®me de documentation trouv√© !")
        sys.exit(0)
    else:
        print(f"‚ùå {total_issues} probl√®me(s) de documentation trouv√©(s)")
        sys.exit(1)

if __name__ == '__main__':
    main()
```

## Int√©gration dans le workflow de d√©veloppement

### Pre-commit hook pour documentation

```python
#!/usr/bin/env python3
"""
Pre-commit hook pour v√©rifier la qualit√© de la documentation.

Ce script est ex√©cut√© automatiquement avant chaque commit
pour s'assurer que le code ajout√©/modifi√© a une documentation adequate.
"""

import subprocess
import sys
from pathlib import Path

def check_staged_files():
    """
    V√©rifie les fichiers Python modifi√©s dans le commit.

    Returns:
        bool: True si tous les fichiers ont une doc adequade, False sinon
    """
    # Obtenir la liste des fichiers Python modifi√©s
    result = subprocess.run(
        ['git', 'diff', '--cached', '--name-only', '--diff-filter=AM'],
        capture_output=True,
        text=True
    )

    modified_files = [
        f for f in result.stdout.strip().split('\n')
        if f.endswith('.py') and Path(f).exists()
    ]

    if not modified_files:
        print("‚úÖ Aucun fichier Python modifi√©")
        return True

    print(f"üîç V√©rification de {len(modified_files)} fichier(s) Python...")

    # Ex√©cuter le v√©rificateur de documentation
    issues_found = False
    for file_path in modified_files:
        checker = DocStringChecker()
        issues = checker.check_file(Path(file_path))

        if issues:
            if not issues_found:
                print("\n‚ùå Probl√®mes de documentation d√©tect√©s :")
                issues_found = True

            print(f"\nüìÅ {file_path}")
            for issue_type, line_no, message in issues:
                print(f"  ‚Ä¢ Ligne {line_no}: {message}")

    if issues_found:
        print("\nüí° Ajoutez des docstrings appropri√©es avant de commiter.")
        print("   Consultez le guide de style dans la documentation du projet.")
        return False
    else:
        print("‚úÖ Documentation adequade pour tous les fichiers modifi√©s")
        return True

if __name__ == '__main__':
    if not check_staged_files():
        sys.exit(1)
```

### Configuration dans setup.cfg/pyproject.toml

```toml
# pyproject.toml
[tool.doc-check]
# Configuration pour le v√©rificateur de documentation
min_docstring_length = 20
check_args = true
check_returns = true
ignore_private = true
ignore_tests = true

[tool.sphinx]
# Configuration pour la g√©n√©ration automatique
source_dir = "docs/source"
build_dir = "docs/build"
auto_build = true
```

## Maintenance de la documentation

### Script de g√©n√©ration automatique

```python
#!/usr/bin/env python3
"""
G√©n√©rateur automatique de documentation de base.

Ce script g√©n√®re des docstrings de base pour les fonctions
et classes qui n'en ont pas, en se basant sur l'analyse
du code (signatures, type hints, etc.).
"""

import ast
import re
from pathlib import Path
from typing import List, Optional

class DocStringGenerator:
    """
    G√©n√©rateur de docstrings de base pour code Python.

    Analyse le code existant et g√©n√®re des templates de docstrings
    bas√©s sur les signatures de fonctions et type hints.
    """

    def generate_function_docstring(self, func_node: ast.FunctionDef) -> str:
        """
        G√©n√®re une docstring de base pour une fonction.

        Args:
            func_node: N≈ìud AST de la fonction

        Returns:
            str: Template de docstring g√©n√©r√©
        """
        lines = []

        # Description g√©n√©rique bas√©e sur le nom
        func_name_readable = self._humanize_name(func_node.name)
        lines.append(f'    """')
        lines.append(f'    {func_name_readable}.')
        lines.append(f'    ')

        # Section Args si la fonction a des param√®tres
        args = [arg.arg for arg in func_node.args.args if arg.arg != 'self']
        if args:
            lines.append(f'    Args:')
            for arg in args:
                arg_desc = self._humanize_name(arg)
                lines.append(f'        {arg}: {arg_desc}')
            lines.append(f'    ')

        # Section Returns si la fonction a un return
        has_return = any(isinstance(node, ast.Return) and node.value
                        for node in ast.walk(func_node))
        if has_return:
            lines.append(f'    Returns:')
            lines.append(f'        Description du retour')
            lines.append(f'    ')

        # Exemple basique
        lines.append(f'    Example:')
        example_call = self._generate_example_call(func_node)
        lines.append(f'        >>> {example_call}')
        lines.append(f'        # TODO: Ajouter le r√©sultat attendu')
        lines.append(f'    """')

        return '\n'.join(lines)

    def generate_class_docstring(self, class_node: ast.ClassDef) -> str:
        """
        G√©n√®re une docstring de base pour une classe.

        Args:
            class_node: N≈ìud AST de la classe

        Returns:
            str: Template de docstring g√©n√©r√©
        """
        lines = []
        class_name_readable = self._humanize_name(class_node.name)

        lines.append(f'    """')
        lines.append(f'    {class_name_readable}.')
        lines.append(f'    ')
        lines.append(f'    TODO: D√©crire le r√¥le et la responsabilit√© de cette classe.')
        lines.append(f'    ')

        # Analyser les attributs d'instance depuis __init__
        init_method = None
        for node in class_node.body:
            if isinstance(node, ast.FunctionDef) and node.name == '__init__':
                init_method = node
                break

        if init_method:
            instance_attrs = self._extract_instance_attributes(init_method)
            if instance_attrs:
                lines.append(f'    Attributes:')
                for attr in instance_attrs:
                    attr_desc = self._humanize_name(attr)
                    lines.append(f'        {attr}: {attr_desc}')
                lines.append(f'    ')

        # Exemple d'utilisation
        lines.append(f'    Example:')
        lines.append(f'        >>> obj = {class_node.name}()')
        lines.append(f'        >>> # TODO: Ajouter exemple d\'utilisation')
        lines.append(f'    """')

        return '\n'.join(lines)

    def _humanize_name(self, name: str) -> str:
        """
        Convertit un nom de variable/fonction en description lisible.

        Args:
            name: Nom √† convertir

        Returns:
            str: Description lisible
        """
        # Convertir snake_case en mots
        words = name.replace('_', ' ').split()

        # Capitaliser la premi√®re lettre
        if words:
            words[0] = words[0].capitalize()

        return ' '.join(words)

    def _generate_example_call(self, func_node: ast.FunctionDef) -> str:
        """G√©n√®re un appel d'exemple pour une fonction."""
        args = [arg.arg for arg in func_node.args.args if arg.arg != 'self']

        # G√©n√©rer des valeurs d'exemple basiques
        example_args = []
        for arg in args:
            if 'id' in arg.lower():
                example_args.append('1')
            elif 'name' in arg.lower() or 'text' in arg.lower():
                example_args.append('"exemple"')
            elif 'count' in arg.lower() or 'num' in arg.lower():
                example_args.append('10')
            elif 'flag' in arg.lower() or 'enable' in arg.lower():
                example_args.append('True')
            else:
                example_args.append('...')

        args_str = ', '.join(example_args)
        return f"{func_node.name}({args_str})"

    def _extract_instance_attributes(self, init_node: ast.FunctionDef) -> List[str]:
        """
        Extrait les attributs d'instance depuis la m√©thode __init__.

        Args:
            init_node: N≈ìud AST de la m√©thode __init__

        Returns:
            List[str]: Liste des noms d'attributs
        """
        attributes = []

        for node in ast.walk(init_node):
            if (isinstance(node, ast.Assign) and
                len(node.targets) == 1 and
                isinstance(node.targets[0], ast.Attribute) and
                isinstance(node.targets[0].value, ast.Name) and
                node.targets[0].value.id == 'self'):

                attr_name = node.targets[0].attr
                attributes.append(attr_name)

        return sorted(set(attributes))

def process_file(file_path: Path, dry_run: bool = True) -> None:
    """
    Traite un fichier Python et g√©n√®re les docstrings manquantes.

    Args:
        file_path: Chemin vers le fichier Python
        dry_run: Si True, affiche seulement ce qui serait g√©n√©r√©
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    try:
        tree = ast.parse(content)
    except SyntaxError as e:
        print(f"‚ùå Erreur de syntaxe dans {file_path}: {e}")
        return

    generator = DocStringGenerator()
    suggestions = []

    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
            if not ast.get_docstring(node):
                # Ignorer les m√©thodes priv√©es
                if node.name.startswith('_') and not node.name.startswith('__'):
                    continue

                if isinstance(node, ast.FunctionDef):
                    docstring = generator.generate_function_docstring(node)
                    suggestions.append((node.lineno, 'function', node.name, docstring))
                else:
                    docstring = generator.generate_class_docstring(node)
                    suggestions.append((node.lineno, 'class', node.name, docstring))

    if suggestions:
        print(f"\nüìÅ {file_path}")
        print(f"   {len(suggestions)} docstring(s) √† ajouter :")

        for line_no, node_type, name, docstring in suggestions:
            print(f"\n   üîß {node_type.capitalize()} '{name}' (ligne {line_no}):")
            if dry_run:
                print("      " + "\n      ".join(docstring.split('\n')))
            else:
                # TODO: Impl√©menter l'insertion automatique
                print("      Docstring ajout√©e automatiquement")

    return suggestions

def main():
    """Point d'entr√©e principal."""
    import argparse

    parser = argparse.ArgumentParser(
        description="G√©n√®re des docstrings de base pour code Python"
    )
    parser.add_argument('path', help='Fichier ou r√©pertoire √† traiter')
    parser.add_argument('--apply', action='store_true',
                       help='Applique les modifications (par d√©faut: dry-run)')

    args = parser.parse_args()

    target = Path(args.path)
    if not target.exists():
        print(f"‚ùå {target} n'existe pas")
        return 1

    if target.is_file():
        files = [target]
    else:
        files = list(target.rglob('*.py'))

    print(f"üîç Analyse de {len(files)} fichier(s) Python...")

    total_suggestions = 0
    for file_path in files:
        suggestions = process_file(file_path, dry_run=not args.apply)
        if suggestions:
            total_suggestions += len(suggestions)

    print(f"\nüìä R√©sum√© : {total_suggestions} docstring(s) √† ajouter")
    if not args.apply and total_suggestions > 0:
        print("üí° Utilisez --apply pour appliquer les modifications")

if __name__ == '__main__':
    main()
```

## Documentation collaborative

### Templates de documentation

```python
# templates/function_template.py
"""
Template de docstring pour une fonction.

Copiez-collez ce template et adaptez-le √† votre fonction.
"""

def ma_fonction(param1, param2=None, **kwargs):
    """
    [DESCRIPTION COURTE EN UNE LIGNE]

    [DESCRIPTION D√âTAILL√âE OPTIONNELLE]
    Cette section explique en d√©tail ce que fait la fonction,
    pourquoi elle existe, et comment l'utiliser efficacement.

    Args:
        param1 (type): Description du premier param√®tre.
            Peut √™tre sur plusieurs lignes si n√©cessaire.
        param2 (type, optional): Description du param√®tre optionnel.
            D√©faut √† None.
        **kwargs: Arguments suppl√©mentaires pass√©s √† [autre_fonction].
            Cl√©s support√©es :
            - 'option1' (bool): Description de l'option
            - 'option2' (int): Description de l'autre option

    Returns:
        type: Description du retour.
            Peut d√©crire la structure si c'est complexe.

    Raises:
        ValueError: Si param1 est invalide
        TypeError: Si les types ne correspondent pas
        CustomError: Description de l'erreur personnalis√©e

    Example:
        Utilisation basique :
        >>> resultat = ma_fonction("test", param2=42)
        >>> print(resultat)
        "r√©sultat attendu"

        Avec options avanc√©es :
        >>> resultat = ma_fonction("test", option1=True, option2=100)
        >>> isinstance(resultat, str)
        True

    Note:
        Informations importantes sur l'utilisation,
        les limitations ou les consid√©rations de performance.

    Warning:
        Avertissements sur les risques ou effets de bord.

    See Also:
        fonction_related(): Description de la fonction li√©e
        autre_module.fonction(): R√©f√©rence externe
    """
    pass
```

### Guide de style pour l'√©quipe

```markdown
# Guide de style pour la documentation

## Principes g√©n√©raux

1. **Clart√© avant tout** : √âcrivez pour quelqu'un qui d√©couvre le code
2. **Concision** : Soyez pr√©cis sans √™tre verbeux
3. **Consistance** : Utilisez le m√™me style dans tout le projet
4. **Exemples** : Incluez des exemples pratiques quand c'est utile

## Format standard

Nous utilisons le format Google pour les docstrings :

```python
def ma_fonction(param1, param2=None):
    """
    Description courte sur une ligne.

    Description d√©taill√©e optionnelle sur plusieurs lignes.

    Args:
        param1 (type): Description
        param2 (type, optional): Description. D√©faut √† None.

    Returns:
        type: Description du retour

    Raises:
        ErrorType: Condition d'erreur

    Example:
        >>> ma_fonction("test")
        "r√©sultat"
    """
```

## R√®gles sp√©cifiques

### Description courte
- Une seule ligne
- Commence par une majuscule
- Se termine par un point
- Utilise l'imp√©ratif ("Calcule", "Retourne", "V√©rifie")

### Arguments (Args)
- Format : `nom (type): Description`
- Pour les optionnels : `nom (type, optional): Description. D√©faut √† valeur.`
- Types complexes : utilisez les type hints du module `typing`

### Retours (Returns)
- Format : `type: Description`
- D√©crivez la structure pour les types complexes
- Omettez pour les fonctions qui ne retournent rien

### Exemples
- Utilisez la notation doctest (`>>>`)
- Montrez les cas d'usage typiques
- Incluez le r√©sultat attendu
- Testez vos exemples avec `python -m doctest fichier.py`

### Notes et avertissements
- `Note:` pour les informations importantes
- `Warning:` pour les risques ou limitations
- `See Also:` pour les r√©f√©rences

## V√©rification

Avant de commit :
```bash
# V√©rifier la documentation
python scripts/check_docs.py

# Tester les doctests
python -m doctest src/*.py

# G√©n√©rer la documentation
cd docs && make html
```
```

## Exercices pratiques

### Exercice 1 : Am√©liorer des docstrings existantes

```python
# Exercice : Am√©liorez ces docstrings
def calculate_discount(price, discount_rate, max_discount=None):
    """Calculates discount"""
    # √Ä am√©liorer !
    pass

class UserAccount:
    """User account"""
    # √Ä am√©liorer !

    def __init__(self, username, email):
        # √Ä documenter !
        pass

    def change_password(self, old_password, new_password):
        """Changes password"""
        # √Ä am√©liorer !
        pass

# Votre mission :
# 1. R√©√©crivez ces docstrings selon les bonnes pratiques
# 2. Ajoutez des sections Args, Returns, Raises appropri√©es
# 3. Incluez des exemples d'utilisation
# 4. Documentez les cas particuliers
```

### Exercice 2 : Documentation d'une API

```python
# Exercice : Documentez compl√®tement cette API
class TaskManager:
    def __init__(self, storage_backend="memory"):
        # TODO: Documenter
        pass

    def create_task(self, title, description="", priority=1, due_date=None):
        # TODO: Documenter
        # Cette m√©thode cr√©e une nouvelle t√¢che
        # priority: 1=low, 2=medium, 3=high
        # Retourne l'ID de la t√¢che cr√©√©e
        pass

    def update_task(self, task_id, **kwargs):
        # TODO: Documenter
        # Met √† jour les champs sp√©cifi√©s d'une t√¢che
        # L√®ve TaskNotFound si la t√¢che n'existe pas
        pass

    def get_tasks(self, status=None, priority=None):
        # TODO: Documenter
        # Retourne une liste de t√¢ches filtr√©es
        pass

    def mark_completed(self, task_id):
        # TODO: Documenter
        pass

# Votre mission :
# 1. Ajoutez des docstrings compl√®tes pour la classe et toutes les m√©thodes
# 2. Documentez les exceptions personnalis√©es
# 3. Cr√©ez des exemples d'utilisation de l'API
# 4. Expliquez les diff√©rents backends de stockage
```

## R√©sum√©

La documentation avec docstrings est essentielle pour un code maintenable :

### **Points cl√©s :**
- **Docstrings** : Documentation int√©gr√©e au code
- **Formats** : Google, NumPy, Sphinx selon les besoins
- **Contenu** : Description, Args, Returns, Raises, Examples
- **Outils** : Sphinx pour g√©n√©ration, doctests pour validation

### **Bonnes pratiques :**
- √âcrivez pour votre futur vous et vos coll√®gues
- Expliquez le "pourquoi", pas seulement le "quoi"
- Incluez des exemples concrets et testables
- Documentez les cas particuliers et limitations
- Maintenez la documentation √† jour avec le code

### **Workflow recommand√© :**
1. **√âcrivez** les docstrings en m√™me temps que le code
2. **V√©rifiez** avec des outils automatiques
3. **Testez** les exemples avec doctest
4. **G√©n√©rez** la documentation avec Sphinx
5. **Int√©grez** les v√©rifications dans votre CI/CD

### **Outils essentiels :**
- Scripts de v√©rification automatique
- Pre-commit hooks pour la qualit√©
- Sphinx pour g√©n√©ration HTML
- Doctests pour validation des exemples

### **Pour l'√©quipe :**
- Guide de style partag√©
- Templates standardis√©s
- Processus de review incluant la documentation
- Formation sur les bonnes pratiques

Une bonne documentation est un investissement qui se rentabilise rapidement. Elle facilite la maintenance, r√©duit les bugs, et am√©liore la collaboration en √©quipe !

Dans la section suivante, nous verrons comment maintenir la qualit√© du code avec PEP 8 et les outils de linting.

---

**√Ä retenir :** Une bonne docstring, c'est comme un bon mode d'emploi : elle vous fait gagner du temps au lieu d'en perdre !

‚è≠Ô∏è
