```python

# Exercice 3 : Coordonn√©es g√©ographiques - Solution compl√®te

import math

# Base de donn√©es des villes : nom_ville -> (latitude, longitude, pays)
villes = {
    "Paris": (48.8566, 2.3522, "France"),
    "Londres": (51.5074, -0.1278, "Royaume-Uni"),
    "New York": (40.7128, -74.0060, "√âtats-Unis"),
    "Tokyo": (35.6762, 139.6503, "Japon"),
    "Sydney": (-33.8688, 151.2093, "Australie"),
    "Le Caire": (30.0444, 31.2357, "√âgypte"),
    "Mexico": (19.4326, -99.1332, "Mexique"),
    "Rio de Janeiro": (-22.9068, -43.1729, "Br√©sil"),
    "Moscou": (55.7558, 37.6176, "Russie"),
    "P√©kin": (39.9042, 116.4074, "Chine"),
    "Mumbai": (19.0760, 72.8777, "Inde"),
    "Lagos": (6.5244, 3.3792, "Nigeria"),
    "Berlin": (52.5200, 13.4050, "Allemagne"),
    "Madrid": (40.4168, -3.7038, "Espagne"),
    "Rome": (41.9028, 12.4964, "Italie")
}

def calculer_distance(coord1, coord2):
    """
    Calcule la distance entre deux coordonn√©es g√©ographiques avec la formule de Haversine.

    Args:
        coord1 (tuple): (latitude1, longitude1)
        coord2 (tuple): (latitude2, longitude2)

    Returns:
        float: Distance en kilom√®tres
    """
    lat1, lon1 = coord1
    lat2, lon2 = coord2

    # Rayon de la Terre en kilom√®tres
    R = 6371

    # Conversion en radians
    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    delta_lat = math.radians(lat2 - lat1)
    delta_lon = math.radians(lon2 - lon1)

    # Formule de Haversine
    a = (math.sin(delta_lat/2)**2 +
         math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon/2)**2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))

    return R * c

def distance_entre_villes(ville1, ville2):
    """
    Calcule la distance entre deux villes nomm√©es.

    Args:
        ville1 (str): Nom de la premi√®re ville
        ville2 (str): Nom de la deuxi√®me ville

    Returns:
        float: Distance en kilom√®tres
    """
    if ville1 not in villes:
        print(f"‚ùå Ville '{ville1}' non trouv√©e.")
        return None
    if ville2 not in villes:
        print(f"‚ùå Ville '{ville2}' non trouv√©e.")
        return None

    coord1 = (villes[ville1][0], villes[ville1][1])
    coord2 = (villes[ville2][0], villes[ville2][1])

    return calculer_distance(coord1, coord2)

def ville_la_plus_proche(position):
    """
    Trouve la ville la plus proche d'une position donn√©e.

    Args:
        position (tuple): (latitude, longitude)

    Returns:
        tuple: (nom_ville, distance) ou (None, None) si erreur
    """
    latitude, longitude = position

    # Validation des coordonn√©es
    if not (-90 <= latitude <= 90):
        print(f"‚ùå Latitude invalide : {latitude} (doit √™tre entre -90 et 90)")
        return None, None
    if not (-180 <= longitude <= 180):
        print(f"‚ùå Longitude invalide : {longitude} (doit √™tre entre -180 et 180)")
        return None, None

    if not villes:
        print("‚ùå Aucune ville dans la base de donn√©es.")
        return None, None

    ville_proche = None
    distance_min = float('inf')

    for nom_ville, (lat, lon, pays) in villes.items():
        coord_ville = (lat, lon)
        distance = calculer_distance(position, coord_ville)

        if distance < distance_min:
            distance_min = distance
            ville_proche = nom_ville

    return ville_proche, distance_min

def villes_dans_rayon(centre, rayon):
    """
    Trouve toutes les villes dans un rayon donn√© autour d'un centre.

    Args:
        centre (tuple): (latitude, longitude) du centre
        rayon (float): Rayon en kilom√®tres

    Returns:
        list: Liste de tuples (nom_ville, distance) tri√©e par distance
    """
    latitude, longitude = centre

    # Validation des coordonn√©es
    if not (-90 <= latitude <= 90):
        print(f"‚ùå Latitude invalide : {latitude}")
        return []
    if not (-180 <= longitude <= 180):
        print(f"‚ùå Longitude invalide : {longitude}")
        return []

    if rayon <= 0:
        print("‚ùå Le rayon doit √™tre positif.")
        return []

    villes_proches = []

    for nom_ville, (lat, lon, pays) in villes.items():
        coord_ville = (lat, lon)
        distance = calculer_distance(centre, coord_ville)

        if distance <= rayon:
            villes_proches.append((nom_ville, distance))

    # Trier par distance
    villes_proches.sort(key=lambda x: x[1])

    return villes_proches

def ajouter_ville(nom, latitude, longitude, pays):
    """
    Ajoute une nouvelle ville √† la base de donn√©es.

    Args:
        nom (str): Nom de la ville
        latitude (float): Latitude
        longitude (float): Longitude
        pays (str): Pays

    Returns:
        bool: True si ajout√© avec succ√®s, False sinon
    """
    # Validation des entr√©es
    if not nom.strip():
        print("‚ùå Le nom de la ville ne peut pas √™tre vide.")
        return False
    if not pays.strip():
        print("‚ùå Le nom du pays ne peut pas √™tre vide.")
        return False

    nom = nom.strip().title()
    pays = pays.strip().title()

    # Validation des coordonn√©es
    if not (-90 <= latitude <= 90):
        print(f"‚ùå Latitude invalide : {latitude} (doit √™tre entre -90 et 90)")
        return False
    if not (-180 <= longitude <= 180):
        print(f"‚ùå Longitude invalide : {longitude} (doit √™tre entre -180 et 180)")
        return False

    # V√©rifier si la ville existe d√©j√†
    if nom in villes:
        print(f"‚ùå La ville '{nom}' existe d√©j√†.")
        return False

    # Ajouter la ville
    villes[nom] = (latitude, longitude, pays)
    print(f"‚úÖ Ville '{nom}' ajout√©e avec succ√®s.")
    return True

def supprimer_ville(nom):
    """
    Supprime une ville de la base de donn√©es.

    Args:
        nom (str): Nom de la ville √† supprimer

    Returns:
        bool: True si supprim√©e avec succ√®s, False sinon
    """
    if not nom.strip():
        print("‚ùå Le nom de la ville ne peut pas √™tre vide.")
        return False

    nom = nom.strip().title()

    if nom not in villes:
        print(f"‚ùå Ville '{nom}' non trouv√©e.")
        return False

    del villes[nom]
    print(f"‚úÖ Ville '{nom}' supprim√©e avec succ√®s.")
    return True

def afficher_villes():
    """Affiche toutes les villes avec leurs coordonn√©es."""
    print("\n" + "="*70)
    print("                    üåç LISTE DES VILLES üåç")
    print("="*70)

    if not villes:
        print("Aucune ville dans la base de donn√©es.")
        return

    print(f"Nombre total de villes : {len(villes)}")
    print()
    print(f"{'Ville':<20} {'Latitude':<12} {'Longitude':<12} {'Pays':<20}")
    print("-" * 70)

    for nom, (lat, lon, pays) in sorted(villes.items()):
        print(f"{nom:<20} {lat:>8.4f}¬∞ {lon:>9.4f}¬∞ {pays:<20}")

def rechercher_ville(nom):
    """
    Recherche une ville et affiche ses informations.

    Args:
        nom (str): Nom de la ville √† rechercher
    """
    if not nom.strip():
        print("‚ùå Le nom de la ville ne peut pas √™tre vide.")
        return

    nom = nom.strip().title()

    print(f"\nüîç Recherche de '{nom}' :")

    if nom in villes:
        lat, lon, pays = villes[nom]

        print(f"‚úÖ Ville trouv√©e :")
        print(f"   üìç Nom : {nom}")
        print(f"   üåç Pays : {pays}")
        print(f"   üìê Coordonn√©es : {lat:.4f}¬∞, {lon:.4f}¬∞")

        # Trouver les 3 villes les plus proches
        villes_proches = []
        for autre_nom, (autre_lat, autre_lon, autre_pays) in villes.items():
            if autre_nom != nom:
                distance = calculer_distance((lat, lon), (autre_lat, autre_lon))
                villes_proches.append((autre_nom, distance))

        villes_proches.sort(key=lambda x: x[1])

        print(f"\nüèôÔ∏è  3 villes les plus proches :")
        for i, (ville_proche, dist) in enumerate(villes_proches[:3], 1):
            print(f"   {i}. {ville_proche} : {dist:.2f} km")
    else:
        print("‚ùå Ville non trouv√©e.")

        # Sugg√©rer des villes similaires
        suggestions = [v for v in villes.keys() if nom.lower() in v.lower()]
        if suggestions:
            print("üí° Suggestions :")
            for suggestion in suggestions[:5]:
                print(f"   - {suggestion}")

def villes_par_pays(pays):
    """
    Trouve toutes les villes d'un pays donn√©.

    Args:
        pays (str): Nom du pays

    Returns:
        list: Liste des noms des villes
    """
    if not pays.strip():
        return []

    pays = pays.strip().title()
    villes_pays = []

    for nom_ville, (lat, lon, ville_pays) in villes.items():
        if ville_pays.lower() == pays.lower():
            villes_pays.append(nom_ville)

    return sorted(villes_pays)

def calculer_itineraire(villes_etapes):
    """
    Calcule la distance totale d'un itin√©raire passant par plusieurs villes.

    Args:
        villes_etapes (list): Liste des noms des villes dans l'ordre

    Returns:
        float: Distance totale en kilom√®tres, ou None si erreur
    """
    if len(villes_etapes) < 2:
        print("‚ùå Il faut au moins 2 villes pour calculer un itin√©raire.")
        return None

    # V√©rifier que toutes les villes existent
    for ville in villes_etapes:
        if ville not in villes:
            print(f"‚ùå Ville '{ville}' non trouv√©e.")
            return None

    distance_totale = 0.0

    for i in range(len(villes_etapes) - 1):
        ville_depart = villes_etapes[i]
        ville_arrivee = villes_etapes[i + 1]

        distance = distance_entre_villes(ville_depart, ville_arrivee)
        if distance is None:
            return None
        distance_totale += distance

    return distance_totale

def afficher_itineraire_detaille(villes_etapes):
    """Affiche un itin√©raire d√©taill√© avec les distances entre chaque √©tape."""
    print("\n" + "="*60)
    print("              üó∫Ô∏è  ITIN√âRAIRE D√âTAILL√â üó∫Ô∏è")
    print("="*60)

    if len(villes_etapes) < 2:
        print("‚ùå Il faut au moins 2 villes pour un itin√©raire.")
        return

    print(f"üìç Nombre d'√©tapes : {len(villes_etapes)}")
    print(f"üö© D√©part : {villes_etapes[0]}")
    print(f"üèÅ Arriv√©e : {villes_etapes[-1]}")
    print()

    distance_totale = 0
    etapes_valides = True

    for i in range(len(villes_etapes) - 1):
        ville_depart = villes_etapes[i]
        ville_arrivee = villes_etapes[i + 1]

        distance = distance_entre_villes(ville_depart, ville_arrivee)
        if distance is None:
            etapes_valides = False
            break

        distance_totale += distance

        print(f"üìç √âtape {i+1:2d} : {ville_depart} ‚Üí {ville_arrivee}")
        print(f"   üìè Distance : {distance:8.2f} km")
        print(f"   üìä Cumul√©  : {distance_totale:8.2f} km")
        print()

    if etapes_valides:
        print("="*60)
        print(f"üèÅ Distance totale : {distance_totale:.2f} km")

def statistiques():
    """Affiche des statistiques sur la base de donn√©es des villes."""
    print("\n" + "="*60)
    print("              üìä STATISTIQUES üìä")
    print("="*60)

    if not villes:
        print("‚ùå Aucune ville dans la base de donn√©es.")
        return

    # Statistiques g√©n√©rales
    nb_villes = len(villes)
    print(f"üìä Nombre total de villes : {nb_villes}")

    # R√©partition par pays
    pays_count = {}
    for nom, (lat, lon, pays) in villes.items():
        pays_count[pays] = pays_count.get(pays, 0) + 1

    print(f"\nüåç R√©partition par pays :")
    for pays, count in sorted(pays_count.items(), key=lambda x: x[1], reverse=True):
        print(f"   {pays:<20} : {count:2d} ville{'s' if count > 1 else ''}")

    # Calcul de quelques distances remarquables si on a assez de villes
    if nb_villes >= 2:
        print(f"\nüìè Distances entre quelques villes :")
        villes_list = list(villes.keys())

        # Afficher 5 distances au hasard
        for i in range(min(5, len(villes_list)-1)):
            ville1 = villes_list[i]
            ville2 = villes_list[i+1]
            distance = distance_entre_villes(ville1, ville2)
            if distance:
                print(f"   {ville1} ‚Üî {ville2} : {distance:.2f} km")

def saisir_coordonnees():
    """Interface pour saisir des coordonn√©es avec validation."""
    while True:
        try:
            print("üìç Saisie des coordonn√©es :")
            lat_str = input("   Latitude (-90 √† 90) : ").strip()
            lon_str = input("   Longitude (-180 √† 180) : ").strip()

            latitude = float(lat_str)
            longitude = float(lon_str)

            if not (-90 <= latitude <= 90):
                print(f"‚ùå Latitude invalide : {latitude}")
                continue
            if not (-180 <= longitude <= 180):
                print(f"‚ùå Longitude invalide : {longitude}")
                continue

            return latitude, longitude

        except ValueError:
            print("‚ùå Veuillez entrer des nombres valides.")

def saisir_villes_itineraire():
    """Interface pour saisir les villes d'un itin√©raire."""
    print("\nüìã Villes disponibles :")
    villes_list = sorted(villes.keys())

    for i, ville in enumerate(villes_list, 1):
        print(f"   {i:2d}. {ville}")

    print("\nSaisissez les villes de votre itin√©raire :")
    print("(Vous pouvez utiliser les num√©ros ou les noms des villes)")

    villes_etapes = []

    while True:
        if not villes_etapes:
            prompt = "Ville de d√©part : "
        else:
            prompt = f"Ville suivante (ou 'fin' pour terminer) : "

        entree = input(prompt).strip()

        if entree.lower() == 'fin' and len(villes_etapes) >= 2:
            break
        elif entree.lower() == 'fin':
            print("‚ùå Il faut au moins 2 villes pour un itin√©raire.")
            continue

        # Essayer d'abord de parser comme un num√©ro
        try:
            num = int(entree)
            if 1 <= num <= len(villes_list):
                ville = villes_list[num - 1]
                villes_etapes.append(ville)
                print(f"‚úÖ Ajout√© : {ville}")
            else:
                print(f"‚ùå Num√©ro {num} invalide.")
        except ValueError:
            # Si ce n'est pas un num√©ro, essayer le nom
            ville = entree.title()
            if ville in villes:
                villes_etapes.append(ville)
                print(f"‚úÖ Ajout√© : {ville}")
            else:
                print(f"‚ùå Ville '{ville}' non trouv√©e.")

    return villes_etapes

def main():
    """Programme principal avec menu interactif."""
    print("üåç Bienvenue dans le gestionnaire de coordonn√©es g√©ographiques!")

    while True:
        print("\n" + "="*60)
        print("    üåç GESTIONNAIRE DE COORDONN√âES G√âOGRAPHIQUES üåç")
        print("="*60)
        print("1.  üåç Afficher toutes les villes")
        print("2.  üìè Calculer la distance entre deux villes")
        print("3.  üéØ Trouver la ville la plus proche")
        print("4.  üìç Villes dans un rayon")
        print("5.  ‚ûï Ajouter une nouvelle ville")
        print("6.  ‚ûñ Supprimer une ville")
        print("7.  üîç Rechercher une ville")
        print("8.  üåé Villes par pays")
        print("9.  üó∫Ô∏è  Calculer un itin√©raire")
        print("10. üìä Statistiques")
        print("11. üö™ Quitter")
        print("="*60)
        print(f"üìä Base de donn√©es : {len(villes)} villes")

        choix = input("\nChoisissez une option (1-11) : ").strip()

        try:
            if choix == "1":
                afficher_villes()

            elif choix == "2":
                print("\nüìè CALCUL DE DISTANCE ENTRE DEUX VILLES")
                print("Villes disponibles :", ", ".join(sorted(villes.keys())))
                ville1 = input("Premi√®re ville : ").strip().title()
                ville2 = input("Deuxi√®me ville : ").strip().title()

                distance = distance_entre_villes(ville1, ville2)
                if distance is not None:
                    print(f"‚úÖ Distance entre {ville1} et {ville2} : {distance:.2f} km")

            elif choix == "3":
                print("\nüéØ TROUVER LA VILLE LA PLUS PROCHE")
                lat, lon = saisir_coordonnees()

                ville_proche, distance = ville_la_plus_proche((lat, lon))
                if ville_proche:
                    print(f"‚úÖ Ville la plus proche : {ville_proche}")
                    print(f"üìè Distance : {distance:.2f} km")

            elif choix == "4":
                print("\nüìç VILLES DANS UN RAYON")
                lat, lon = saisir_coordonnees()

                try:
                    rayon = float(input("Rayon en km : "))
                    villes_proches = villes_dans_rayon((lat, lon), rayon)

                    if villes_proches:
                        print(f"\n‚úÖ {len(villes_proches)} ville(s) trouv√©e(s) dans un rayon de {rayon} km :")
                        for ville, dist in villes_proches:
                            print(f"   üìç {ville:<20} : {dist:7.2f} km")
                    else:
                        print(f"‚ùå Aucune ville trouv√©e dans un rayon de {rayon} km.")

                except ValueError:
                    print("‚ùå Rayon invalide.")

            elif choix == "5":
                print("\n‚ûï AJOUTER UNE NOUVELLE VILLE")
                nom = input("Nom de la ville : ").strip()
                pays = input("Pays : ").strip()

                try:
                    lat_str = input("Latitude (-90 √† 90) : ").strip()
                    lon_str = input("Longitude (-180 √† 180) : ").strip()
                    lat = float(lat_str)
                    lon = float(lon_str)

                    ajouter_ville(nom, lat, lon, pays)
                except ValueError:
                    print("‚ùå Coordonn√©es invalides.")

            elif choix == "6":
                print("\n‚ûñ SUPPRIMER UNE VILLE")
                print("Villes disponibles :", ", ".join(sorted(villes.keys())))
                nom = input("Nom de la ville √† supprimer : ").strip()
                supprimer_ville(nom)

            elif choix == "7":
                print("\nüîç RECHERCHER UNE VILLE")
                nom = input("Nom de la ville : ").strip()
                rechercher_ville(nom)

            elif choix == "8":
                print("\nüåé VILLES PAR PAYS")
                pays_uniques = sorted(set(pays for _, _, pays in villes.values()))
                print("Pays disponibles :", ", ".join(pays_uniques))

                pays = input("Pays : ").strip()
                villes_pays = villes_par_pays(pays)

                if villes_pays:
                    print(f"\n‚úÖ Villes en {pays.title()} ({len(villes_pays)}) :")
                    for ville in villes_pays:
                        lat, lon, _ = villes[ville]
                        print(f"   üìç {ville} ({lat:.2f}¬∞, {lon:.2f}¬∞)")
                else:
                    print(f"‚ùå Aucune ville trouv√©e pour '{pays}'.")

            elif choix == "9":
                print("\nüó∫Ô∏è  CALCULER UN ITIN√âRAIRE")
                villes_etapes = saisir_villes_itineraire()

                if len(villes_etapes) >= 2:
                    print(f"\nüìã Itin√©raire : {' ‚Üí '.join(villes_etapes)}")
                    afficher_itineraire_detaille(villes_etapes)
                else:
                    print("‚ùå Itin√©raire annul√©.")

            elif choix == "10":
                statistiques()

            elif choix == "11":
                print("üåç Merci d'avoir utilis√© le gestionnaire de coordonn√©es g√©ographiques!")
                print("√Ä bient√¥t! üëã")
                break

            else:
                print("‚ùå Option invalide. Veuillez choisir entre 1 et 11.")

        except KeyboardInterrupt:
            print("\n\nüõë Programme interrompu par l'utilisateur.")
            break
        except Exception as e:
            print(f"‚ùå Une erreur inattendue s'est produite : {e}")

        # Pause pour lire les r√©sultats
        if choix != "11":
            input("\nAppuyez sur Entr√©e pour continuer...")

def tests_unitaires():
    """Tests pour v√©rifier le bon fonctionnement des fonctions."""
    print("üß™ Ex√©cution des tests unitaires...")

    # Test 1: Distance Paris-Londres
    distance = distance_entre_villes("Paris", "Londres")
    assert distance is not None and 340 <= distance <= 350, f"Distance Paris-Londres incorrecte: {distance}"
    print("‚úÖ Test 1 r√©ussi : Distance Paris-Londres")

    # Test 2: Ville la plus proche
    ville, dist = ville_la_plus_proche((48.85, 2.35))  # Pr√®s de Paris
    assert ville == "Paris" and dist < 10, f"Test ville la plus proche √©chou√©: {ville}, {dist}"
    print("‚úÖ Test 2 r√©ussi : Ville la plus proche")

    # Test 3: Villes dans un rayon
    villes_proches = villes_dans_rayon((48.85, 2.35), 500)
    assert len(villes_proches) > 0, "Aucune ville trouv√©e dans le rayon"
    print("‚úÖ Test 3 r√©ussi : Villes dans un rayon")

    # Test 4: Itin√©raire
    distance_itineraire = calculer_itineraire(["Paris", "Londres"])
    assert distance_itineraire is not None and distance_itineraire > 300, f"Distance itin√©raire incorrecte: {distance_itineraire}"
    print("‚úÖ Test 4 r√©ussi : Calcul d'itin√©raire")

    # Test 5: Validation des coordonn√©es
    ville, dist = ville_la_plus_proche((91, 0))  # Latitude > 90
    assert ville is None, "Validation des coordonn√©es √©chou√©e"
    print("‚úÖ Test 5 r√©ussi : Validation des coordonn√©es")

    print("üéâ Tous les tests sont pass√©s avec succ√®s!")

if __name__ == "__main__":
    # Ex√©cuter les tests d'abord
    try:
        tests_unitaires()
        print()
    except Exception as e:
        print(f"‚ùå Erreur dans les tests : {e}")
        print()

    # Lancer le programme principal
    main()

```
