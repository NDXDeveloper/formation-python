üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.2.1 DataFrames et Series

## Introduction √† Pandas

**Pandas** est la biblioth√®que incontournable pour la manipulation et l'analyse de donn√©es en Python. Son nom vient de "Panel Data" (donn√©es de panel) et "Python Data Analysis". Pandas est construite sur NumPy et apporte des structures de donn√©es puissantes et intuitives pour travailler avec des donn√©es tabulaires.

### Installation de Pandas

```bash
pip install pandas
```

### Importation conventionnelle

Par convention, Pandas est import√© avec l'alias `pd` :

```python
import pandas as pd
import numpy as np  # Souvent utilis√© avec Pandas
```

## Les deux structures de donn√©es principales

Pandas repose sur deux structures de donn√©es fondamentales :

1. **Series** : Tableau √† une dimension (comme une colonne)
2. **DataFrame** : Tableau √† deux dimensions (comme une table Excel)

```python
# Visualisation conceptuelle

# Series (1D)
# Index  Valeurs
#   0      10
#   1      20
#   2      30

# DataFrame (2D)
# Index  Nom      √Çge    Ville
#   0    Alice    25     Paris
#   1    Bob      30     Lyon
#   2    Charlie  35     Marseille
```

---

## Les Series

### Qu'est-ce qu'une Series ?

Une **Series** est un array unidimensionnel √©tiquet√©, capable de contenir n'importe quel type de donn√©es. C'est similaire √† une colonne dans un tableur Excel ou une colonne dans une base de donn√©es.

**Caract√©ristiques d'une Series :**
- Peut contenir des entiers, floats, strings, objets Python, etc.
- Poss√®de un index qui √©tiquette chaque √©l√©ment
- Supporte les op√©rations vectoris√©es comme NumPy

### Cr√©ation d'une Series

#### M√©thode 1 : √Ä partir d'une liste

```python
import pandas as pd

# Series simple √† partir d'une liste
temperatures = pd.Series([15, 18, 22, 20, 17])
print(temperatures)
```

**Sortie :**
```
0    15
1    18
2    22
3    20
4    17
dtype: int64
```

L'index par d√©faut est 0, 1, 2, 3, 4...

#### M√©thode 2 : Avec un index personnalis√©

```python
# Series avec index personnalis√©
temperatures = pd.Series([15, 18, 22, 20, 17],
                         index=['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi'])
print(temperatures)
```

**Sortie :**
```
Lundi        15
Mardi        18
Mercredi     22
Jeudi        20
Vendredi     17
dtype: int64
```

#### M√©thode 3 : √Ä partir d'un dictionnaire

```python
# Le dictionnaire : cl√©s deviennent l'index, valeurs deviennent les donn√©es
villes_population = pd.Series({
    'Paris': 2_161_000,
    'Marseille': 869_000,
    'Lyon': 516_000,
    'Toulouse': 475_000
})
print(villes_population)
```

**Sortie :**
```
Paris         2161000
Marseille      869000
Lyon           516000
Toulouse       475000
dtype: int64
```

#### M√©thode 4 : √Ä partir d'un array NumPy

```python
import numpy as np

# √Ä partir d'un array NumPy
arr = np.array([10, 20, 30, 40, 50])
serie = pd.Series(arr, index=['a', 'b', 'c', 'd', 'e'])
print(serie)
```

#### M√©thode 5 : Series constante

```python
# Cr√©er une Series avec une valeur constante
serie_constante = pd.Series(100, index=['a', 'b', 'c', 'd'])
print(serie_constante)
```

**Sortie :**
```
a    100
b    100
c    100
d    100
dtype: int64
```

### Acc√®s aux donn√©es d'une Series

```python
temperatures = pd.Series([15, 18, 22, 20, 17],
                         index=['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi'])

# Acc√®s par index de position
print("Premier √©l√©ment:", temperatures[0])  # 15

# Acc√®s par √©tiquette
print("Temp√©rature mardi:", temperatures['Mardi'])  # 18

# Acc√®s multiple
print("Lundi et Vendredi:")
print(temperatures[['Lundi', 'Vendredi']])

# Slicing
print("Lundi √† Mercredi:")
print(temperatures['Lundi':'Mercredi'])  # Inclut la fin !
```

### Propri√©t√©s d'une Series

```python
temperatures = pd.Series([15, 18, 22, 20, 17],
                         index=['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi'])

# Valeurs (array NumPy)
print("Valeurs:", temperatures.values)  # [15 18 22 20 17]

# Index
print("Index:", temperatures.index)  # Index(['Lundi', 'Mardi', ...])

# Type de donn√©es
print("Type:", temperatures.dtype)  # int64

# Taille
print("Taille:", temperatures.size)  # 5

# Forme
print("Forme:", temperatures.shape)  # (5,)

# Nom de la Series
temperatures.name = "Temp√©ratures"
print(temperatures)
```

### Op√©rations sur les Series

#### Op√©rations arithm√©tiques

```python
temperatures = pd.Series([15, 18, 22, 20, 17],
                         index=['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi'])

# Addition
print("Temp√©ratures + 5:")
print(temperatures + 5)

# Multiplication
print("Temp√©ratures √ó 2:")
print(temperatures * 2)

# Conversion Celsius vers Fahrenheit
fahrenheit = temperatures * 9/5 + 32
print("En Fahrenheit:")
print(fahrenheit)
```

#### Op√©rations entre Series

```python
ventes_janvier = pd.Series([100, 150, 200], index=['Produit A', 'Produit B', 'Produit C'])
ventes_fevrier = pd.Series([120, 140, 210], index=['Produit A', 'Produit B', 'Produit C'])

# Addition de deux Series
ventes_totales = ventes_janvier + ventes_fevrier
print("Ventes totales:")
print(ventes_totales)

# Diff√©rence
evolution = ventes_fevrier - ventes_janvier
print("√âvolution:")
print(evolution)
```

#### Statistiques descriptives

```python
temperatures = pd.Series([15, 18, 22, 20, 17, 19, 21])

# Statistiques de base
print("Moyenne:", temperatures.mean())  # 18.857...
print("M√©diane:", temperatures.median())  # 19.0
print("√âcart-type:", temperatures.std())  # 2.478...
print("Minimum:", temperatures.min())  # 15
print("Maximum:", temperatures.max())  # 22
print("Somme:", temperatures.sum())  # 132

# R√©sum√© statistique complet
print(temperatures.describe())
```

**Sortie de describe() :**
```
count     7.000000
mean     18.857143
std       2.478232
min      15.000000
25%      17.500000
50%      19.000000
75%      20.500000
max      22.000000
dtype: float64
```

#### Filtrage

```python
temperatures = pd.Series([15, 18, 22, 20, 17],
                         index=['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi'])

# Temp√©ratures > 18
jours_chauds = temperatures[temperatures > 18]
print("Jours chauds (>18¬∞C):")
print(jours_chauds)

# Temp√©ratures entre 17 et 20
jours_doux = temperatures[(temperatures >= 17) & (temperatures <= 20)]
print("Jours doux (17-20¬∞C):")
print(jours_doux)
```

---

## Les DataFrames

### Qu'est-ce qu'un DataFrame ?

Un **DataFrame** est une structure de donn√©es bidimensionnelle, similaire √† un tableur Excel ou une table SQL. C'est la structure la plus utilis√©e dans Pandas.

**Caract√©ristiques d'un DataFrame :**
- Tableau 2D avec des lignes et des colonnes
- Chaque colonne est une Series
- Peut contenir diff√©rents types de donn√©es dans diff√©rentes colonnes
- Poss√®de un index pour les lignes et des noms pour les colonnes

```python
# Visualisation d'un DataFrame
#        Nom      √Çge    Ville
# 0      Alice    25     Paris
# 1      Bob      30     Lyon
# 2      Charlie  35     Marseille
```

### Cr√©ation d'un DataFrame

#### M√©thode 1 : √Ä partir d'un dictionnaire de listes

```python
import pandas as pd

# Dictionnaire : cl√©s = noms des colonnes, valeurs = donn√©es
donnees = {
    'Nom': ['Alice', 'Bob', 'Charlie', 'David'],
    '√Çge': [25, 30, 35, 28],
    'Ville': ['Paris', 'Lyon', 'Marseille', 'Toulouse']
}

df = pd.DataFrame(donnees)
print(df)
```

**Sortie :**
```
       Nom  √Çge       Ville
0    Alice   25       Paris
1      Bob   30        Lyon
2  Charlie   35  Marseille
3    David   28    Toulouse
```

#### M√©thode 2 : √Ä partir d'une liste de dictionnaires

```python
# Chaque dictionnaire repr√©sente une ligne
etudiants = [
    {'nom': 'Alice', 'note': 15, 'matiere': 'Math'},
    {'nom': 'Bob', 'note': 12, 'matiere': 'Math'},
    {'nom': 'Alice', 'note': 18, 'matiere': 'Physique'}
]

df = pd.DataFrame(etudiants)
print(df)
```

**Sortie :**
```
     nom  note   matiere
0  Alice    15      Math
1    Bob    12      Math
2  Alice    18  Physique
```

#### M√©thode 3 : √Ä partir d'un dictionnaire de Series

```python
# Cr√©er des Series
noms = pd.Series(['Alice', 'Bob', 'Charlie'])
ages = pd.Series([25, 30, 35])
villes = pd.Series(['Paris', 'Lyon', 'Marseille'])

# Cr√©er le DataFrame
df = pd.DataFrame({
    'Nom': noms,
    '√Çge': ages,
    'Ville': villes
})
print(df)
```

#### M√©thode 4 : √Ä partir d'un array NumPy

```python
import numpy as np

# Array 2D
data = np.array([[1, 2, 3],
                 [4, 5, 6],
                 [7, 8, 9]])

df = pd.DataFrame(data,
                  columns=['A', 'B', 'C'],
                  index=['Ligne1', 'Ligne2', 'Ligne3'])
print(df)
```

**Sortie :**
```
        A  B  C
Ligne1  1  2  3
Ligne2  4  5  6
Ligne3  7  8  9
```

#### M√©thode 5 : √Ä partir d'un fichier CSV

```python
# Lecture d'un fichier CSV (tr√®s courant)
# df = pd.read_csv('donnees.csv')

# Exemple de cr√©ation puis sauvegarde
df = pd.DataFrame({
    'Produit': ['Pomme', 'Banane', 'Orange'],
    'Prix': [2.5, 1.8, 3.2],
    'Stock': [100, 150, 80]
})

# Sauvegarder en CSV
# df.to_csv('produits.csv', index=False)
```

### Index personnalis√©

```python
# DataFrame avec index personnalis√©
donnees = {
    'Nom': ['Alice', 'Bob', 'Charlie'],
    '√Çge': [25, 30, 35],
    'Ville': ['Paris', 'Lyon', 'Marseille']
}

df = pd.DataFrame(donnees, index=['E001', 'E002', 'E003'])
print(df)
```

**Sortie :**
```
         Nom  √Çge       Ville
E001   Alice   25       Paris
E002     Bob   30        Lyon
E003 Charlie   35  Marseille
```

### Propri√©t√©s d'un DataFrame

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie', 'David'],
    '√Çge': [25, 30, 35, 28],
    'Ville': ['Paris', 'Lyon', 'Marseille', 'Toulouse'],
    'Salaire': [35000, 42000, 48000, 38000]
})

# Dimensions (lignes, colonnes)
print("Shape:", df.shape)  # (4, 4)

# Nombre de lignes
print("Nombre de lignes:", len(df))  # 4

# Nombre de colonnes
print("Nombre de colonnes:", len(df.columns))  # 4

# Noms des colonnes
print("Colonnes:", df.columns.tolist())  # ['Nom', '√Çge', 'Ville', 'Salaire']

# Index
print("Index:", df.index.tolist())  # [0, 1, 2, 3]

# Types de donn√©es
print("\nTypes de donn√©es:")
print(df.dtypes)

# Informations g√©n√©rales
print("\nInformations:")
df.info()

# Taille (nombre total d'√©l√©ments)
print("Taille:", df.size)  # 16 (4 lignes √ó 4 colonnes)
```

**Sortie de df.dtypes :**
```
Nom         object
√Çge          int64
Ville       object
Salaire      int64
dtype: object
```

### Visualisation des donn√©es

#### head() et tail()

```python
df = pd.DataFrame({
    'Jour': ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'],
    'Temp√©rature': [15, 18, 22, 20, 17, 19, 21],
    'Pluie': [0, 0, 5, 2, 0, 0, 1]
})

# Afficher les 5 premi√®res lignes (par d√©faut)
print("Premi√®res lignes:")
print(df.head())

# Afficher les 3 premi√®res lignes
print("\n3 premi√®res lignes:")
print(df.head(3))

# Afficher les 5 derni√®res lignes
print("\nDerni√®res lignes:")
print(df.tail())

# Afficher les 2 derni√®res lignes
print("\n2 derni√®res lignes:")
print(df.tail(2))
```

#### Aper√ßu des donn√©es

```python
# R√©sum√© statistique des colonnes num√©riques
print(df.describe())

# Informations sur les types et valeurs manquantes
df.info()

# Compter les valeurs uniques dans une colonne
print("\nVilles uniques:")
print(df['Ville'].value_counts())
```

### Acc√®s aux donn√©es

#### Acc√®s aux colonnes

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie'],
    '√Çge': [25, 30, 35],
    'Ville': ['Paris', 'Lyon', 'Marseille']
})

# M√©thode 1 : Notation par crochets (recommand√©e)
print("Colonne √Çge:")
print(df['√Çge'])

# M√©thode 2 : Notation par attribut (si pas d'espace dans le nom)
print("\nColonne Nom:")
print(df.Nom)

# S√©lectionner plusieurs colonnes
print("\nNom et Ville:")
print(df[['Nom', 'Ville']])
```

#### Acc√®s aux lignes

##### M√©thode .loc[] - Par √©tiquette

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie'],
    '√Çge': [25, 30, 35],
    'Ville': ['Paris', 'Lyon', 'Marseille']
}, index=['E001', 'E002', 'E003'])

# Acc√®s √† une ligne par son √©tiquette
print("Ligne E002:")
print(df.loc['E002'])

# Acc√®s √† plusieurs lignes
print("\nLignes E001 et E003:")
print(df.loc[['E001', 'E003']])

# Acc√®s avec slicing (la fin est INCLUSE)
print("\nE001 √† E002:")
print(df.loc['E001':'E002'])
```

##### M√©thode .iloc[] - Par position

```python
# Acc√®s √† une ligne par sa position (commence √† 0)
print("Premi√®re ligne (position 0):")
print(df.iloc[0])

# Acc√®s √† plusieurs lignes
print("\nLignes 0 et 2:")
print(df.iloc[[0, 2]])

# Slicing par position (la fin est EXCLUE, comme Python)
print("\nPositions 0 √† 2 (exclus):")
print(df.iloc[0:2])
```

#### Acc√®s √† des cellules sp√©cifiques

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie'],
    '√Çge': [25, 30, 35],
    'Ville': ['Paris', 'Lyon', 'Marseille']
})

# .loc[ligne, colonne]
print("√Çge de Bob (index 1):")
print(df.loc[1, '√Çge'])  # 30

# .iloc[position_ligne, position_colonne]
print("√âl√©ment √† la position [0, 2]:")
print(df.iloc[0, 2])  # 'Paris'

# Acc√®s √† un bloc
print("\nLignes 0-1, colonnes Nom et √Çge:")
print(df.loc[0:1, ['Nom', '√Çge']])
```

### Ajout et modification de donn√©es

#### Ajouter une colonne

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie'],
    '√Çge': [25, 30, 35]
})

# Ajouter une colonne
df['Ville'] = ['Paris', 'Lyon', 'Marseille']
print(df)

# Ajouter une colonne calcul√©e
df['√Çge_dans_10_ans'] = df['√Çge'] + 10
print(df)

# Ajouter une colonne avec une valeur constante
df['Pays'] = 'France'
print(df)
```

#### Modifier des valeurs

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie'],
    '√Çge': [25, 30, 35],
    'Ville': ['Paris', 'Lyon', 'Marseille']
})

# Modifier une cellule
df.loc[0, '√Çge'] = 26
print(df)

# Modifier toute une colonne
df['√Çge'] = df['√Çge'] + 1
print(df)

# Modifier plusieurs cellules
df.loc[df['Nom'] == 'Bob', 'Ville'] = 'Nice'
print(df)
```

#### Ajouter une ligne

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob'],
    '√Çge': [25, 30],
    'Ville': ['Paris', 'Lyon']
})

# Cr√©er une nouvelle ligne
nouvelle_ligne = pd.DataFrame({
    'Nom': ['Charlie'],
    '√Çge': [35],
    'Ville': ['Marseille']
})

# Ajouter la ligne avec concat
df = pd.concat([df, nouvelle_ligne], ignore_index=True)
print(df)
```

#### Supprimer des colonnes ou lignes

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie'],
    '√Çge': [25, 30, 35],
    'Ville': ['Paris', 'Lyon', 'Marseille'],
    'Code': ['A1', 'B2', 'C3']
})

# Supprimer une colonne
df_sans_code = df.drop('Code', axis=1)  # axis=1 pour colonnes
print(df_sans_code)

# Supprimer plusieurs colonnes
df_reduit = df.drop(['Code', 'Ville'], axis=1)
print(df_reduit)

# Supprimer des lignes
df_sans_premiere = df.drop(0, axis=0)  # axis=0 pour lignes
print(df_sans_premiere)

# Supprimer avec inplace=True modifie l'original
df.drop('Code', axis=1, inplace=True)
print(df)
```

### Filtrage de DataFrames

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
    '√Çge': [25, 30, 35, 28, 22],
    'Ville': ['Paris', 'Lyon', 'Paris', 'Marseille', 'Lyon'],
    'Salaire': [35000, 42000, 48000, 38000, 32000]
})

# Filtrage simple
personnes_plus_30 = df[df['√Çge'] > 30]
print("Personnes de plus de 30 ans:")
print(personnes_plus_30)

# Conditions multiples avec &
parisiens_jeunes = df[(df['Ville'] == 'Paris') & (df['√Çge'] < 30)]
print("\nParisiens de moins de 30 ans:")
print(parisiens_jeunes)

# Conditions multiples avec |
lyon_ou_marseille = df[(df['Ville'] == 'Lyon') | (df['Ville'] == 'Marseille')]
print("\nPersonnes √† Lyon ou Marseille:")
print(lyon_ou_marseille)

# Utiliser isin() pour plusieurs valeurs
grandes_villes = df[df['Ville'].isin(['Paris', 'Lyon'])]
print("\nPersonnes dans les grandes villes:")
print(grandes_villes)

# Filtrage avec contains (contient une cha√Æne)
noms_avec_a = df[df['Nom'].str.contains('a', case=False)]
print("\nNoms contenant 'a':")
print(noms_avec_a)
```

### Tri des donn√©es

```python
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie', 'David'],
    '√Çge': [25, 30, 35, 28],
    'Ville': ['Paris', 'Lyon', 'Marseille', 'Toulouse'],
    'Salaire': [35000, 42000, 48000, 38000]
})

# Trier par une colonne
df_trie_age = df.sort_values('√Çge')
print("Tri√© par √¢ge (croissant):")
print(df_trie_age)

# Trier en ordre d√©croissant
df_trie_salaire = df.sort_values('Salaire', ascending=False)
print("\nTri√© par salaire (d√©croissant):")
print(df_trie_salaire)

# Trier par plusieurs colonnes
df_trie_multiple = df.sort_values(['Ville', '√Çge'])
print("\nTri√© par ville puis √¢ge:")
print(df_trie_multiple)

# R√©initialiser l'index apr√®s le tri
df_trie_reset = df.sort_values('√Çge').reset_index(drop=True)
print("\nTri√© avec index r√©initialis√©:")
print(df_trie_reset)
```

### Op√©rations sur les colonnes

```python
df = pd.DataFrame({
    'Produit': ['Pomme', 'Banane', 'Orange', 'Poire'],
    'Prix_unitaire': [2.5, 1.8, 3.2, 2.8],
    'Quantite': [10, 15, 8, 12]
})

# Cr√©er une nouvelle colonne calcul√©e
df['Total'] = df['Prix_unitaire'] * df['Quantite']
print(df)

# Op√©rations math√©matiques sur une colonne
print("\nPrix moyen:", df['Prix_unitaire'].mean())
print("Prix total:", df['Total'].sum())
print("Quantit√© max:", df['Quantite'].max())

# Appliquer une fonction personnalis√©e
df['Prix_arrondi'] = df['Prix_unitaire'].round(0)
print("\nAvec prix arrondi:")
print(df)

# Renommer des colonnes
df_renomme = df.rename(columns={
    'Prix_unitaire': 'Prix',
    'Quantite': 'Qt√©'
})
print("\nColonnes renomm√©es:")
print(df_renomme)
```

### Valeurs manquantes

```python
# Cr√©er un DataFrame avec des valeurs manquantes (NaN)
df = pd.DataFrame({
    'Nom': ['Alice', 'Bob', 'Charlie', 'David'],
    '√Çge': [25, None, 35, 28],
    'Ville': ['Paris', 'Lyon', None, 'Toulouse'],
    'Salaire': [35000, 42000, 48000, None]
})

print("DataFrame avec valeurs manquantes:")
print(df)

# D√©tecter les valeurs manquantes
print("\nValeurs manquantes (True = manquant):")
print(df.isnull())

# Compter les valeurs manquantes par colonne
print("\nNombre de valeurs manquantes:")
print(df.isnull().sum())

# Supprimer les lignes avec des valeurs manquantes
df_sans_nan = df.dropna()
print("\nSans lignes contenant NaN:")
print(df_sans_nan)

# Remplir les valeurs manquantes
df_rempli = df.fillna(0)
print("\nNaN remplac√©s par 0:")
print(df_rempli)

# Remplir avec une valeur sp√©cifique par colonne
df_rempli2 = df.fillna({
    '√Çge': df['√Çge'].mean(),
    'Ville': 'Inconnu',
    'Salaire': df['Salaire'].median()
})
print("\nNaN remplis avec des valeurs appropri√©es:")
print(df_rempli2)
```

### Op√©rations par groupe (aper√ßu)

```python
df = pd.DataFrame({
    'Ville': ['Paris', 'Lyon', 'Paris', 'Lyon', 'Marseille'],
    'Produit': ['A', 'A', 'B', 'B', 'A'],
    'Ventes': [100, 150, 120, 180, 90],
    'Prix': [10, 15, 12, 18, 9]
})

# Moyenne des ventes par ville
moyenne_par_ville = df.groupby('Ville')['Ventes'].mean()
print("Moyenne des ventes par ville:")
print(moyenne_par_ville)

# Somme par produit
somme_par_produit = df.groupby('Produit')['Ventes'].sum()
print("\nSomme des ventes par produit:")
print(somme_par_produit)

# Plusieurs agr√©gations
stats_par_ville = df.groupby('Ville').agg({
    'Ventes': ['mean', 'sum'],
    'Prix': ['min', 'max']
})
print("\nStatistiques par ville:")
print(stats_par_ville)
```

## Exemples pratiques complets

### Exemple 1 : Analyse de ventes

```python
# Cr√©er un DataFrame de ventes
ventes = pd.DataFrame({
    'Date': ['2024-01-01', '2024-01-02', '2024-01-03', '2024-01-04', '2024-01-05'],
    'Produit': ['Laptop', 'Souris', 'Clavier', 'Laptop', '√âcran'],
    'Quantite': [2, 10, 5, 1, 3],
    'Prix_unitaire': [800, 25, 60, 800, 250]
})

# Calculer le montant total
ventes['Montant'] = ventes['Quantite'] * ventes['Prix_unitaire']

# Afficher
print("Tableau des ventes:")
print(ventes)

# Statistiques
print("\n--- Analyse ---")
print(f"Revenu total: {ventes['Montant'].sum()}‚Ç¨")
print(f"Vente moyenne: {ventes['Montant'].mean():.2f}‚Ç¨")
print(f"Produit le plus vendu: {ventes.loc[ventes['Quantite'].idxmax(), 'Produit']}")

# Ventes par produit
ventes_par_produit = ventes.groupby('Produit')['Montant'].sum().sort_values(ascending=False)
print("\nVentes par produit:")
print(ventes_par_produit)
```

### Exemple 2 : Carnet d'adresses

```python
# Cr√©er un carnet d'adresses
contacts = pd.DataFrame({
    'Nom': ['Dupont', 'Martin', 'Bernard', 'Thomas'],
    'Pr√©nom': ['Jean', 'Marie', 'Pierre', 'Sophie'],
    'T√©l√©phone': ['0601020304', '0602030405', '0603040506', '0604050607'],
    'Ville': ['Paris', 'Lyon', 'Paris', 'Marseille'],
    '√Çge': [35, 28, 42, 31]
})

print("Carnet d'adresses:")
print(contacts)

# Cr√©er une colonne nom complet
contacts['Nom_complet'] = contacts['Pr√©nom'] + ' ' + contacts['Nom']

# Filtrer les contacts parisiens
parisiens = contacts[contacts['Ville'] == 'Paris']
print("\nContacts √† Paris:")
print(parisiens[['Nom_complet', 'T√©l√©phone']])

# Trier par √¢ge
contacts_tries = contacts.sort_values('√Çge')
print("\nContacts tri√©s par √¢ge:")
print(contacts_tries[['Nom_complet', '√Çge']])
```

### Exemple 3 : Notes d'√©tudiants

```python
# Notes d'√©tudiants
notes = pd.DataFrame({
    '√âtudiant': ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve'],
    'Math': [15, 12, 18, 14, 16],
    'Physique': [13, 14, 16, 15, 12],
    'Chimie': [16, 11, 17, 13, 15],
    'Anglais': [14, 15, 15, 16, 14]
})

print("Tableau des notes:")
print(notes)

# Calculer la moyenne de chaque √©tudiant
notes['Moyenne'] = notes[['Math', 'Physique', 'Chimie', 'Anglais']].mean(axis=1)
print("\nAvec moyennes:")
print(notes)

# Moyenne par mati√®re
print("\nMoyenne de classe par mati√®re:")
print(notes[['Math', 'Physique', 'Chimie', 'Anglais']].mean())

# Meilleur √©tudiant
meilleur = notes.loc[notes['Moyenne'].idxmax()]
print(f"\nMeilleur √©tudiant: {meilleur['√âtudiant']} avec {meilleur['Moyenne']:.2f}")

# √âtudiants avec moyenne >= 15
mentions = notes[notes['Moyenne'] >= 15]
print("\n√âtudiants avec mention (‚â•15):")
print(mentions[['√âtudiant', 'Moyenne']])
```

### Exemple 4 : Suivi d'activit√© physique

```python
# Suivi sportif hebdomadaire
activite = pd.DataFrame({
    'Jour': ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'],
    'Sport': ['Course', 'Repos', 'V√©lo', 'Course', 'Repos', 'Natation', 'Randonn√©e'],
    'Dur√©e_min': [30, 0, 45, 30, 0, 60, 120],
    'Calories': [300, 0, 400, 300, 0, 500, 600]
})

print("Suivi d'activit√©:")
print(activite)

# Statistiques de la semaine
print("\n--- Statistiques hebdomadaires ---")
print(f"Temps total d'exercice: {activite['Dur√©e_min'].sum()} minutes")
print(f"Calories br√ªl√©es: {activite['Calories'].sum()} kcal")
print(f"Dur√©e moyenne par s√©ance: {activite[activite['Dur√©e_min'] > 0]['Dur√©e_min'].mean():.1f} min")

# Jours actifs
jours_actifs = activite[activite['Dur√©e_min'] > 0]
print(f"\nNombre de jours actifs: {len(jours_actifs)}")

# Sport le plus pratiqu√© (hors repos)
sports_actifs = activite[activite['Sport'] != 'Repos']
sport_favoris = sports_actifs.groupby('Sport')['Dur√©e_min'].sum().idxmax()
print(f"Sport le plus pratiqu√©: {sport_favoris}")
```

## Bonnes pratiques

### 1. Nommer clairement les DataFrames et colonnes

```python
# ‚ùå Moins bon
df = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})

# ‚úÖ Mieux
ventes = pd.DataFrame({'produit': [1, 2], 'quantite': [3, 4]})
```

### 2. V√©rifier les donn√©es apr√®s import

```python
# Toujours v√©rifier apr√®s avoir charg√© des donn√©es
# df = pd.read_csv('data.csv')
# print(df.head())
# print(df.info())
# print(df.describe())
```

### 3. Utiliser des copies pour √©viter les modifications involontaires

```python
# Si vous voulez modifier sans affecter l'original
df_original = pd.DataFrame({'A': [1, 2, 3]})
df_copie = df_original.copy()
df_copie['A'] = df_copie['A'] * 2  # N'affecte pas df_original
```

### 4. Cha√Æner les op√©rations pour plus de lisibilit√©

```python
# Au lieu de :
df_filtre = df[df['√Çge'] > 25]
df_trie = df_filtre.sort_values('Salaire')
resultat = df_trie[['Nom', 'Salaire']]

# On peut faire :
resultat = (df[df['√Çge'] > 25]
            .sort_values('Salaire')
            [['Nom', 'Salaire']])
```

### 5. Attention aux SettingWithCopyWarning

```python
# ‚ùå Peut causer des probl√®mes
# df[df['A'] > 0]['B'] = 5  # Warning !

# ‚úÖ Utiliser .loc[]
# df.loc[df['A'] > 0, 'B'] = 5
```

## R√©sum√©

Dans cette section, nous avons explor√© les deux structures de donn√©es fondamentales de Pandas :

### Series
- Tableau unidimensionnel √©tiquet√©
- Similaire √† une colonne
- Supporte les op√©rations vectoris√©es
- Poss√®de un index

### DataFrames
- Tableau bidimensionnel (lignes et colonnes)
- Similaire √† une table Excel ou SQL
- Chaque colonne est une Series
- Permet des manipulations puissantes de donn√©es

**Op√©rations cl√©s apprises :**
- Cr√©ation de Series et DataFrames
- Acc√®s aux donn√©es (.loc, .iloc, [])
- Ajout et modification de colonnes/lignes
- Filtrage et tri
- Statistiques descriptives
- Gestion des valeurs manquantes

Ces concepts constituent la base de l'analyse de donn√©es avec Pandas. Dans les sections suivantes, nous approfondirons le nettoyage et la transformation de donn√©es, ainsi que les op√©rations de regroupement plus avanc√©es.

‚è≠Ô∏è [Nettoyage et transformation de donn√©es](/13-introduction-data-science/02.2-nettoyage-transformation.md)
