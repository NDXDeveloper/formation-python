üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.1.2 Indexation et slicing avanc√©s

## Introduction

L'indexation et le slicing sont des techniques essentielles pour acc√©der et manipuler les donn√©es dans les arrays NumPy. Dans cette section, nous allons explorer les diff√©rentes m√©thodes pour extraire, modifier et manipuler des parties sp√©cifiques d'un array.

```python
import numpy as np
```

## Indexation de base (rappel)

### Arrays 1D

Pour les arrays √† une dimension, l'indexation fonctionne comme pour les listes Python :

```python
arr = np.array([10, 20, 30, 40, 50])

# Acc√®s √† un √©l√©ment par son index (commence √† 0)
print("Premier √©l√©ment:", arr[0])      # 10
print("Troisi√®me √©l√©ment:", arr[2])    # 30

# Index n√©gatifs (partir de la fin)
print("Dernier √©l√©ment:", arr[-1])     # 50
print("Avant-dernier:", arr[-2])       # 40
```

### Modification d'√©l√©ments

```python
arr = np.array([10, 20, 30, 40, 50])

# Modifier un √©l√©ment
arr[0] = 100
print("Array modifi√©:", arr)  # [100 20 30 40 50]

# Modifier plusieurs √©l√©ments
arr[1] = 200
arr[3] = 400
print("Array modifi√©:", arr)  # [100 200 30 400 50]
```

## Indexation multidimensionnelle

### Arrays 2D (matrices)

Pour les arrays √† deux dimensions, on utilise la notation `[ligne, colonne]` :

```python
# Cr√©ation d'une matrice 3x4
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

print("Matrice:\n", matrice)

# Acc√®s √† un √©l√©ment sp√©cifique [ligne, colonne]
print("√âl√©ment ligne 0, colonne 2:", matrice[0, 2])    # 3
print("√âl√©ment ligne 1, colonne 1:", matrice[1, 1])    # 6
print("√âl√©ment ligne 2, colonne 3:", matrice[2, 3])    # 12

# Index n√©gatifs
print("Derni√®re ligne, derni√®re colonne:", matrice[-1, -1])  # 12
print("Premi√®re ligne, derni√®re colonne:", matrice[0, -1])   # 4
```

### Notation alternative (moins recommand√©e)

```python
# On peut aussi utiliser des crochets successifs (moins lisible)
print("√âl√©ment [1, 2]:", matrice[1][2])  # 7

# Mais la notation [ligne, colonne] est pr√©f√©r√©e
print("√âl√©ment [1, 2]:", matrice[1, 2])  # 7 (recommand√©)
```

### Acc√®s √† des lignes ou colonnes enti√®res

```python
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

# Acc√®s √† une ligne enti√®re
print("Ligne 0:", matrice[0])      # [1 2 3 4]
print("Ligne 1:", matrice[1])      # [5 6 7 8]
print("Derni√®re ligne:", matrice[-1])  # [9 10 11 12]

# Acc√®s √† une colonne enti√®re (avec :)
print("Colonne 0:", matrice[:, 0])   # [1 5 9]
print("Colonne 2:", matrice[:, 2])   # [3 7 11]
print("Derni√®re colonne:", matrice[:, -1])  # [4 8 12]
```

## Slicing (d√©coupage) de base

Le slicing permet d'extraire des portions d'un array. La syntaxe est `[d√©but:fin:pas]`.

### Slicing 1D

```python
arr = np.array([0, 10, 20, 30, 40, 50, 60, 70, 80, 90])

# Extraire une portion [d√©but:fin] (fin non incluse)
print("Indices 2 √† 5:", arr[2:5])     # [20 30 40]
print("Indices 0 √† 3:", arr[0:3])     # [0 10 20]

# Omission du d√©but (= 0)
print("Du d√©but √† 4:", arr[:4])       # [0 10 20 30]

# Omission de la fin (= jusqu'√† la fin)
print("De 6 √† la fin:", arr[6:])      # [60 70 80 90]

# Avec un pas
print("Tous les 2 √©l√©ments:", arr[::2])       # [0 20 40 60 80]
print("Indices 1 √† 8, par pas de 2:", arr[1:8:2])  # [10 30 50 70]

# Inverser un array
print("Array invers√©:", arr[::-1])    # [90 80 70 60 50 40 30 20 10 0]
```

### Slicing 2D

```python
matrice = np.array([[1,  2,  3,  4,  5],
                    [6,  7,  8,  9, 10],
                    [11, 12, 13, 14, 15],
                    [16, 17, 18, 19, 20]])

print("Matrice compl√®te:\n", matrice)

# Extraire les 2 premi√®res lignes
print("\nDeux premi√®res lignes:\n", matrice[:2])
# [[1 2 3 4 5]
#  [6 7 8 9 10]]

# Extraire les 3 premi√®res colonnes
print("\nTrois premi√®res colonnes:\n", matrice[:, :3])
# [[1  2  3]
#  [6  7  8]
#  [11 12 13]
#  [16 17 18]]

# Extraire une sous-matrice (lignes 1-2, colonnes 2-4)
print("\nSous-matrice [1:3, 2:5]:\n", matrice[1:3, 2:5])
# [[8  9 10]
#  [13 14 15]]

# Lignes 0 et 2, toutes les colonnes
print("\nLignes 0 et 2:\n", matrice[::2])
# [[1  2  3  4  5]
#  [11 12 13 14 15]]

# Toutes les lignes, colonnes paires
print("\nColonnes paires:\n", matrice[:, ::2])
# [[1  3  5]
#  [6  8 10]
#  [11 13 15]
#  [16 18 20]]
```

## Indexation avanc√©e avec des listes

Vous pouvez utiliser des listes ou des arrays pour s√©lectionner des √©l√©ments sp√©cifiques.

### Indexation par liste d'indices

```python
arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])

# S√©lectionner des √©l√©ments aux indices 1, 3, 5
indices = [1, 3, 5]
print("√âl√©ments aux indices 1, 3, 5:", arr[indices])  # [20 40 60]

# On peut aussi le faire directement
print("√âl√©ments:", arr[[0, 2, 4, 8]])  # [10 30 50 90]

# Les indices peuvent √™tre r√©p√©t√©s
print("Avec r√©p√©titions:", arr[[1, 1, 3, 3]])  # [20 20 40 40]
```

### Indexation avanc√©e 2D

```python
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

# S√©lectionner des lignes sp√©cifiques
lignes = [0, 2]
print("Lignes 0 et 2:\n", matrice[lignes])
# [[1 2 3 4]
#  [9 10 11 12]]

# S√©lectionner des √©l√©ments sp√©cifiques
# Format : lignes et colonnes comme deux listes
lignes = [0, 1, 2]
colonnes = [1, 2, 3]
print("√âl√©ments diagonaux:", matrice[lignes, colonnes])  # [2 7 12]

# S√©lectionner les coins de la matrice
lignes = [0, 0, 2, 2]
colonnes = [0, 3, 0, 3]
print("Les 4 coins:", matrice[lignes, colonnes])  # [1 4 9 12]
```

## Indexation bool√©enne

L'indexation bool√©enne utilise un array de bool√©ens (True/False) pour s√©lectionner des √©l√©ments.

### Principe de base

```python
arr = np.array([10, 25, 30, 15, 40, 5, 35])

# Cr√©er un masque bool√©en
masque = arr > 20
print("Masque (> 20):", masque)
# [False True True False True False True]

# Utiliser le masque pour filtrer
print("Valeurs > 20:", arr[masque])  # [25 30 40 35]

# √âcriture directe (plus courante)
print("Valeurs > 20:", arr[arr > 20])  # [25 30 40 35]
```

### Conditions multiples

```python
arr = np.array([10, 25, 30, 15, 40, 5, 35, 20])

# Op√©rateur ET : &
print("Valeurs entre 15 et 35:", arr[(arr >= 15) & (arr <= 35)])
# [25 30 15 35 20]

# Op√©rateur OU : |
print("Valeurs < 15 ou > 35:", arr[(arr < 15) | (arr > 35)])
# [10 5 40]

# Op√©rateur NON : ~
print("Valeurs PAS √©gales √† 25:", arr[arr != 25])
# [10 30 15 40 5 35 20]

print("Valeurs PAS > 30:", arr[~(arr > 30)])
# [10 25 30 15 5 20]
```

### Indexation bool√©enne 2D

```python
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

# S√©lectionner toutes les valeurs > 6
print("Valeurs > 6:", matrice[matrice > 6])  # [7 8 9 10 11 12]

# Cr√©er un masque bool√©en
masque = matrice % 2 == 0  # Valeurs paires
print("Masque des valeurs paires:\n", masque)
print("Valeurs paires:", matrice[masque])  # [2 4 6 8 10 12]

# S√©lectionner des lignes selon une condition
# Lignes dont la premi√®re colonne est > 5
masque_lignes = matrice[:, 0] > 5
print("Lignes o√π premi√®re colonne > 5:\n", matrice[masque_lignes])
# [[9 10 11 12]]
```

## Modification avec indexation

### Modification par slicing

```python
arr = np.array([0, 10, 20, 30, 40, 50])

# Modifier une tranche
arr[1:4] = 99
print("Apr√®s modification:", arr)  # [0 99 99 99 40 50]

# Modifier avec une s√©quence de valeurs
arr[1:4] = [11, 22, 33]
print("Apr√®s modification:", arr)  # [0 11 22 33 40 50]
```

### Modification avec indexation bool√©enne

```python
arr = np.array([10, 25, 30, 15, 40, 5, 35])

# Mettre toutes les valeurs > 30 √† 30
arr[arr > 30] = 30
print("Valeurs plafonn√©es √† 30:", arr)  # [10 25 30 15 30 5 30]

# Remplacer les valeurs n√©gatives par 0
arr = np.array([5, -2, 8, -7, 3, -1])
arr[arr < 0] = 0
print("N√©gatifs remplac√©s par 0:", arr)  # [5 0 8 0 3 0]

# Incr√©menter certaines valeurs
arr = np.array([10, 20, 30, 40, 50])
arr[arr < 35] += 5
print("Valeurs < 35 incr√©ment√©es:", arr)  # [15 25 35 40 50]
```

### Modification 2D

```python
matrice = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]])

# Modifier une ligne
matrice[1] = [40, 50, 60]
print("Ligne modifi√©e:\n", matrice)

# Modifier une colonne
matrice[:, 2] = [300, 600, 900]
print("Colonne modifi√©e:\n", matrice)

# Modifier une sous-matrice
matrice[0:2, 0:2] = [[11, 22], [44, 55]]
print("Sous-matrice modifi√©e:\n", matrice)
```

## Indexation fancy (combinaisons avanc√©es)

L'indexation fancy combine plusieurs techniques pour des s√©lections complexes.

### Combiner lignes et colonnes sp√©cifiques

```python
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12],
                    [13, 14, 15, 16]])

# S√©lectionner plusieurs lignes et colonnes
lignes = [0, 2, 3]
colonnes = [1, 3]

# M√©thode 1 : avec np.ix_ (grille)
resultat = matrice[np.ix_(lignes, colonnes)]
print("Sous-matrice avec np.ix_:\n", resultat)
# [[2  4]
#  [10 12]
#  [14 16]]

# M√©thode 2 : slicing multiple
resultat2 = matrice[lignes][:, colonnes]
print("M√™me r√©sultat:\n", resultat2)
```

### Indexation avec broadcasting

```python
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

# S√©lectionner la diagonale
indices = np.arange(3)
diagonale = matrice[indices, indices]
print("Diagonale:", diagonale)  # [1 6 11]

# Anti-diagonale
anti_diag = matrice[indices, [2, 1, 0]]
print("Anti-diagonale:", anti_diag)  # [3 6 9]
```

## Fonctions utiles pour l'indexation

### where() - Trouver les indices

```python
arr = np.array([10, 25, 30, 15, 40, 5, 35])

# Trouver les indices o√π la condition est vraie
indices = np.where(arr > 20)
print("Indices des valeurs > 20:", indices)  # (array([1, 2, 4, 6]),)
print("Valeurs correspondantes:", arr[indices])  # [25 30 40 35]

# where avec 2D
matrice = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]])

lignes, colonnes = np.where(matrice > 5)
print("Positions (lignes, colonnes) o√π valeur > 5:")
print("Lignes:", lignes)      # [1 2 2 2]
print("Colonnes:", colonnes)  # [2 0 1 2]
print("Valeurs:", matrice[lignes, colonnes])  # [6 7 8 9]
```

### argmax() et argmin() - Indices des extrema

```python
arr = np.array([30, 10, 50, 20, 40])

# Index du maximum
idx_max = np.argmax(arr)
print("Index du max:", idx_max)  # 2
print("Valeur max:", arr[idx_max])  # 50

# Index du minimum
idx_min = np.argmin(arr)
print("Index du min:", idx_min)  # 1
print("Valeur min:", arr[idx_min])  # 10

# Avec des arrays 2D
matrice = np.array([[1, 5, 3],
                    [9, 2, 7]])

# Maximum global
idx_max_global = np.argmax(matrice)
print("Index du max (aplati):", idx_max_global)  # 3

# Maximum par ligne
idx_max_lignes = np.argmax(matrice, axis=1)
print("Index max par ligne:", idx_max_lignes)  # [1 0]

# Maximum par colonne
idx_max_colonnes = np.argmax(matrice, axis=0)
print("Index max par colonne:", idx_max_colonnes)  # [1 0 1]
```

### nonzero() - Indices des √©l√©ments non nuls

```python
arr = np.array([0, 5, 0, 8, 0, 3, 0])

# Trouver les indices des √©l√©ments non nuls
indices_non_nuls = np.nonzero(arr)
print("Indices non nuls:", indices_non_nuls)  # (array([1, 3, 5]),)
print("Valeurs non nulles:", arr[indices_non_nuls])  # [5 8 3]

# Avec 2D
matrice = np.array([[0, 1, 0],
                    [2, 0, 3],
                    [0, 0, 4]])

lignes, colonnes = np.nonzero(matrice)
print("Lignes des non-nuls:", lignes)      # [0 1 1 2]
print("Colonnes des non-nuls:", colonnes)  # [1 0 2 2]
```

## Vues vs Copies

C'est un concept crucial en NumPy : comprendre quand on travaille avec une vue (r√©f√©rence) ou une copie.

### Les slices cr√©ent des vues

```python
arr = np.array([0, 10, 20, 30, 40])

# Un slice cr√©e une vue, pas une copie
vue = arr[1:4]
print("Vue:", vue)  # [10 20 30]

# Modifier la vue modifie l'original !
vue[0] = 999
print("Vue apr√®s modification:", vue)  # [999 20 30]
print("Array original:", arr)  # [0 999 20 30 40] ‚Üê modifi√© !
```

### Cr√©er une copie explicite

```python
arr = np.array([0, 10, 20, 30, 40])

# Cr√©er une vraie copie avec .copy()
copie = arr[1:4].copy()
print("Copie:", copie)  # [10 20 30]

# Modifier la copie ne modifie PAS l'original
copie[0] = 999
print("Copie apr√®s modification:", copie)  # [999 20 30]
print("Array original:", arr)  # [0 10 20 30 40] ‚Üê inchang√©
```

### L'indexation fancy cr√©e des copies

```python
arr = np.array([0, 10, 20, 30, 40])

# L'indexation avec une liste cr√©e une copie
indices = [1, 3]
copie = arr[indices]
copie[0] = 999
print("Array original:", arr)  # [0 10 20 30 40] ‚Üê inchang√©

# L'indexation bool√©enne cr√©e aussi une copie
arr = np.array([10, 20, 30, 40, 50])
copie = arr[arr > 25]
copie[0] = 999
print("Array original:", arr)  # [10 20 30 40 50] ‚Üê inchang√©
```

### V√©rifier si c'est une vue

```python
arr = np.array([0, 10, 20, 30, 40])

# Slice = vue
vue = arr[1:4]
print("Vue partage la base:", vue.base is arr)  # True

# Copie explicite
copie = arr[1:4].copy()
print("Copie partage la base:", copie.base is arr)  # False

# L'array original n'a pas de base
print("Original a une base:", arr.base is None)  # True
```

## Exemples pratiques

### Exemple 1 : Normalisation min-max

```python
# Normaliser des donn√©es entre 0 et 1
donnees = np.array([10, 25, 15, 30, 20, 35])

min_val = np.min(donnees)
max_val = np.max(donnees)

# Formule : (x - min) / (max - min)
donnees_normalisees = (donnees - min_val) / (max_val - min_val)
print("Donn√©es normalis√©es:", donnees_normalisees)
# [0.   0.6  0.2  0.8  0.4  1.  ]
```

### Exemple 2 : Remplacement conditionnel

```python
# Remplacer les valeurs aberrantes (outliers)
donnees = np.array([15, 18, 200, 19, -50, 17, 20, 16])

# D√©finir des seuils
seuil_bas = 10
seuil_haut = 100

# Cr√©er une copie pour ne pas modifier l'original
donnees_clean = donnees.copy()

# Remplacer les valeurs hors limites par la m√©diane
mediane = np.median(donnees[(donnees >= seuil_bas) & (donnees <= seuil_haut)])
donnees_clean[(donnees_clean < seuil_bas) | (donnees_clean > seuil_haut)] = mediane

print("Donn√©es originales:", donnees)
print("Donn√©es nettoy√©es:", donnees_clean)
# [15 18 17.5 19 17.5 17 20 16]
```

### Exemple 3 : Extraction de sous-matrices

```python
# Matrice repr√©sentant des scores d'√©tudiants
# Lignes = √©tudiants, Colonnes = mati√®res
scores = np.array([[85, 90, 78, 92],
                   [88, 75, 95, 87],
                   [70, 85, 80, 88],
                   [92, 88, 85, 90],
                   [78, 82, 88, 84]])

# Noms des mati√®res
matieres = ['Math', 'Physique', 'Chimie', 'Bio']

# Extraire les scores en Math et Chimie (colonnes 0 et 2)
math_chimie = scores[:, [0, 2]]
print("Scores Math et Chimie:\n", math_chimie)

# Trouver les √©tudiants avec plus de 85 en Math
bons_en_math = scores[scores[:, 0] > 85]
print("\n√âtudiants avec > 85 en Math:\n", bons_en_math)

# Moyenne de chaque √©tudiant
moyennes = np.mean(scores, axis=1)
print("\nMoyennes des √©tudiants:", moyennes)

# √âtudiants avec moyenne > 85
elite = scores[moyennes > 85]
print("\n√âtudiants d'√©lite (moyenne > 85):\n", elite)
```

### Exemple 4 : Grille de donn√©es

```python
# Cr√©er une grille de coordonn√©es
x = np.arange(0, 5)  # [0 1 2 3 4]
y = np.arange(0, 3)  # [0 1 2]

# Cr√©er un meshgrid
X, Y = np.meshgrid(x, y)

print("Grille X:\n", X)
# [[0 1 2 3 4]
#  [0 1 2 3 4]
#  [0 1 2 3 4]]

print("Grille Y:\n", Y)
# [[0 0 0 0 0]
#  [1 1 1 1 1]
#  [2 2 2 2 2]]

# Calculer des distances depuis l'origine
distances = np.sqrt(X**2 + Y**2)
print("Distances:\n", distances)

# S√©lectionner les points √† distance < 2.5
masque = distances < 2.5
print("\nPoints proches (distance < 2.5):")
print("X:", X[masque])
print("Y:", Y[masque])
```

### Exemple 5 : Traitement d'image simplifi√©

```python
# Simuler une image en niveaux de gris (8x8)
image = np.random.randint(0, 256, size=(8, 8))
print("Image originale:\n", image)

# Extraire une r√©gion d'int√©r√™t (ROI) - centre 4x4
roi = image[2:6, 2:6]
print("\nR√©gion d'int√©r√™t:\n", roi)

# Augmenter la luminosit√© de la ROI
image[2:6, 2:6] = np.clip(image[2:6, 2:6] + 50, 0, 255)
print("\nImage avec ROI √©claircie:\n", image)

# Cr√©er un masque pour les pixels sombres
sombre = image < 100
print("\nMasque pixels sombres:\n", sombre)

# √âclaircir les pixels sombres
image[sombre] = image[sombre] + 50
print("\nImage apr√®s √©claircissement des zones sombres:\n", image)
```

## Astuces et pi√®ges √† √©viter

### ‚ö†Ô∏è Pi√®ge 1 : Modifier une vue modifie l'original

```python
# ‚ùå Attention √† ce pi√®ge courant
arr = np.array([1, 2, 3, 4, 5])
sous_arr = arr[1:4]  # Vue, pas copie !
sous_arr[:] = 0      # Modifie l'original
# arr devient [1, 0, 0, 0, 5]

# ‚úÖ Solution : faire une copie
arr = np.array([1, 2, 3, 4, 5])
sous_arr = arr[1:4].copy()
sous_arr[:] = 0
# arr reste [1, 2, 3, 4, 5]
```

### ‚ö†Ô∏è Pi√®ge 2 : Conditions multiples sans parenth√®ses

```python
arr = np.array([10, 20, 30, 40])

# ‚ùå Erreur : oubli des parenth√®ses
# arr[arr > 15 & arr < 35]  # Erreur !

# ‚úÖ Correct : avec parenth√®ses
resultat = arr[(arr > 15) & (arr < 35)]
```

### ‚ö†Ô∏è Pi√®ge 3 : Taille incompatible lors de l'assignation

```python
arr = np.array([1, 2, 3, 4, 5])

# ‚ùå Erreur : nombre d'√©l√©ments diff√©rent
# arr[1:4] = [10, 20]  # Erreur !

# ‚úÖ Correct : m√™me taille
arr[1:4] = [10, 20, 30]

# ‚úÖ Ou : broadcasting avec une valeur unique
arr[1:4] = 99
```

## Bonnes pratiques

1. **Utilisez .copy() quand n√©cessaire** : Si vous devez modifier un sous-array sans affecter l'original
2. **Pr√©f√©rez l'indexation bool√©enne** : Plus lisible que les boucles pour filtrer
3. **Attention aux vues** : Souvenez-vous que les slices sont des vues
4. **Utilisez des noms explicites** : `arr[arr > 0]` plut√¥t que cr√©er un masque interm√©diaire si simple
5. **√âvitez les boucles** : L'indexation avanc√©e et bool√©enne remplace souvent les boucles

## R√©sum√©

L'indexation et le slicing dans NumPy offrent des outils puissants pour :

- **Indexation de base** : Acc√©der √† des √©l√©ments individuels avec `[i]` ou `[i, j]`
- **Slicing** : Extraire des portions avec `[d√©but:fin:pas]`
- **Indexation bool√©enne** : Filtrer avec des conditions `arr[arr > 5]`
- **Indexation fancy** : S√©lectionner avec des listes d'indices
- **Modification** : Changer des valeurs avec toutes ces techniques
- **Vues vs copies** : Comprendre quand l'original est affect√©

Ces techniques permettent de manipuler efficacement les donn√©es sans √©crire de boucles, ce qui rend le code plus rapide et plus lisible.

Dans la section suivante, nous explorerons la manipulation de donn√©es avec Pandas, qui s'appuie sur ces concepts NumPy pour offrir des fonctionnalit√©s encore plus puissantes.

‚è≠Ô∏è [Manipulation de donn√©es avec Pandas](/13-introduction-data-science/02-manipulation-donnees-pandas.md)
